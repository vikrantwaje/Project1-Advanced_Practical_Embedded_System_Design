#ifndef SRC_CLIENT_H_
#define	SRC_CLIENT_H_
/********************************************************************************************
*					FILENAME: Client.h
**********************************************************************************************/
/*
 * Author: Tanmay Chaturvedi, Vikrant Waje
 * Date Created: March 16, 2019
 * Course: Advanced Embedded Software Development
 * Project: 1

 * Reference[1]: http://www.it.uom.gr/teaching/distrubutedSite/dsIdaLiu/labs/lab2_1/sockets.html
 * Reference[2]: Based on code from https://riptutorial.com/posix/example/16306/posix-timer-with-sigev-thread-notification
 * 
 * 
 * */
/****************************************************************************************
*					HEADER FILE SECTION
*****************************************************************************************/
#include <stdio.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <signal.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <mqueue.h>
#include <time.h>
#include <unistd.h>
#include <netinet/in.h>
#include <sys/time.h>
#include <netdb.h>
#include <arpa/inet.h>

/***************************************************************************************
*					MACROS AND ENUMS
****************************************************************************************/
#define	LOG_FILE_NAME	"socketlog.txt"


typedef struct{
	char sensor_string[40];
	double sensor_data; 
}client_data_t;

/****************************************************************************************
* 					GLOBAL VARIABLES
*****************************************************************************************/

int sig_flag = 0;
int socket_fd;


/****************************************************************************************
* 					FUNCTION PROTOTYPES
*****************************************************************************************/



#endif

/********************************************************************************************
*					FILENAME: unittest.h
**********************************************************************************************/
/* Title:thread.h
 * Brief: Responsible for performing unit testing using CUnit unit testing framework
 * Author: Tanmay Chaturvedi, Vikrant Waje
 * Date Created: March 26, 2019
 * Course: Advanced Embedded Software Development
 * Project: 1
 * 
 * 
 * */
/****************************************************************************************
*					HEADER FILE SECTION
*****************************************************************************************/
#ifndef SRC_UNITTEST_H_
#define SRC_UNITTEST_H_

#include <stdio.h>
#include <stdlib.h>
#include <CUnit/Basic.h>
#include <CUnit/Automated.h>
#include <CUnit/CUnit.h>
#include "main.h"
#include "ipc.h"
#include <mqueue.h>
#include "temp_sensor.h"

/**************************************************************************************
*					FUNCTION PROTOTYPE
***************************************************************************************/
int cunit_add_testsuite();
int cunit_pthread_test(void);
int cunit_ipc_test(void);
int cunit_temp_test(void);

void pthread_create_test(void);
void message_queue_open_test(void);
void message_queue_close_test(void);
void temp_conversion_test(void);


#endif#ifndef SRC_TEMP_H_
#define SRC_TEMP_H_
/********************************************************************************************
 *					FILENAME:temp_sensor.h
 **********************************************************************************************/
/* Title: temp_sensor.h
 * Brief: Responsible for providing various helper function needed to communicate with temperature sensor
 * Author: Tanmay Chaturvedi, Vikrant Waje
 * Date Created: March 16, 2019
 * Course: Advanced Embedded Software Development
 * Project: 1

 * Reference[1]: http://www.sparkfun.com/products/13314
 * 
 * 
 * */
/****************************************************************************************
 *					HEADER FILE SECTION
 *****************************************************************************************/
#include<stdio.h>
#include<unistd.h>
#include<fcntl.h>
#include<sys/ioctl.h>
#include<linux/i2c-dev.h>
#include<stdint.h>
#include<stdlib.h>
#include"i2c_status.h"
#include"logger.h"
#include"server.h"
#include"ipc.h"
/****************************************************************************************
 *					MACROS AND ENUMS
 *****************************************************************************************/
#define TEMP_SENSOR_I2C_ADDRESS (0x48)
#define TEMPERATURE_REG		(0x00)
#define CONFIGURATION_REG	 (0x01)
#define TLOW_REG		(0x02)
#define THIGH_REG		(0x03)

#define CONVERSION_RATE_0_25	((0x00))
#define CONVERSION_RATE_1	((0x01))
#define CONVERSION_RATE_4	((0x02))
#define CONVERSION_RATE_8	((0x03))
#define CONVERSION_RATE_MASK	(0x03)


#define SHUTDOWN_ON		((0x01))
#define SHUTDOWN_OFF		((0x00))

#define EM_ON			((0x01))
#define EM_OFF			((0x00))
#define EM_MASK			(0x01)


#define FAULT_1			((0x00)) 
#define FAULT_2			((0x01))
#define FAULT_3			((0x02))
#define FAULT_4			((0x03))
#define FAULT_MASK		(0x03)

#define RESOLUTION_MASK			(0x03)
#define SENSOR_RESOLUTION_12_BIT	(0x03)

typedef enum{
	REQUEST_CELSIUS, REQUEST_KELVIN, REQUEST_FAHRENHEIT
}request_cmd_t;


typedef enum{
	FAULT,EM,CONVERSION_RATE,SD_MODE,RESOLUTION,ALL
}reg_read_cmd_t;



/****************************************************************************************
 *				GLOBAL VARIABLE SECTION
 *****************************************************************************************/


/*************************************************************************************
 *				FUNCTION PROTOTYPE SECTION
 *****************************************************************************************/

/***********************************************************************************************  * @brief Get temperature
 *
 * Read the value from temperature register
 *
 * @param request: Temperature value in kelvin, celsius and farhenheit to be returned
 * @return double: Value of converted temperature
 *********************************************************************************************/
double get_temperature(request_cmd_t request, uint16_t raw_data);



#endif	//SRC_TEMP_H_
#ifndef I2C_STATUS_H_
#define I2C_STATUS_H_

/********************************************************************************************
*					FILENAME: i2c_status.h
**********************************************************************************************/
/*
 * Author: Tanmay Chaturvedi, Vikrant Waje
 * Date Created: March 16, 2019
 * Course: Advanced Embedded Software Development
 * Project: 1

 * Reference[1]: http://www.it.uom.gr/teaching/distrubutedSite/dsIdaLiu/labs/lab2_1/sockets.html
 * Reference[2]: Based on code from https://riptutorial.com/posix/example/16306/posix-timer-with-sigev-thread-notification
 * 
 * 
 * */
/****************************************************************************************
*					HEADER FILE SECTION
*****************************************************************************************/

#include<stdint.h>

/***************************************************************************************
*					MACROS AND ENUMS
****************************************************************************************/
typedef enum{
	WRITE_REG_SUCCESS = 1, READ_REG_SUCCESS =2, WRITE_REG_FAIL=-1, READ_REG_FAIL=-2

}sensor_status_t;


/**************************************************************************************
*				GLOBAL VARIABLES
****************************************************************************************/

#endif //I2C_STATUS_H
#ifndef TIMER_H_
#define TIMER_H_
/********************************************************************************************
*					FILENAME: timer.h
**********************************************************************************************/
/* Title: timer.c
 * Brief: Responsible for providing various helper function needed for logger and heartbeat
 * Author: Tanmay Chaturvedi, Vikrant Waje
 * Date Created: March 16, 2019
 * Course: Advanced Embedded Software Development
 * Project: 1

 * Reference[1]: Professor's slides and notes 
 * 
 * */
/****************************************************************************************
*					HEADER FILE SECTION
*****************************************************************************************/

#include <signal.h>
#include <time.h>
#include <stdio.h>
#include<stdbool.h>
#include"logger.h"
#include"heartbeat.h"
/****************************************************************************************
*				     MACROS AND ENUMS
*****************************************************************************************/
#define SEC_TO_MILLISEC		(1000.0)
#define NANOSEC_TO_MILLISEC	(1000000.0)

/****************************************************************************************
*				GLOBAL VARIABLE SECTION
*****************************************************************************************/
//Flag variables
extern int log_timer_flag;
extern int heartbeat_timer_flag;
// Logger timer id
timer_t log_timer_id;
//Heartbeat timer id
timer_t heartbeat_timer_id;
//timespec struct for giving interval values
struct itimerspec timer_setting;
struct sigevent signal_specification;
/***************************************************************************************
*				FUNCTION PROTOTYPE
*****************************************************************************************/
/***********************************************************************************************
 * @brief logger  timer handler
 *
 * Handler that executes periodically to generate logging interval
 * @param null
 *
 * @return null
 *********************************************************************************************/
void log_timer_handler(int num);
/***********************************************************************************************
 * @brief heartbeat timer handler
 *
 * Handler that executes periodically to generate heartbeat interval
 * @param null
 *
 * @return null
 *********************************************************************************************/
void heartbeat_timer_handler(int num);
/***********************************************************************************************
 * @brief Create log timer
 *
 * Responsible for creating log timer which expires periodically to collect sensor information an
 * nd socket status that is logged into log file
 * @param null
 *
 * @return bool: Indicates whether intiialisation was successfull or not
 *********************************************************************************************/
bool create_log_timer();

/***********************************************************************************************
 * @brief Create heartbeat timer
 *
 * Responsible for generating heartbeat for each of the four thread
 * @param null
 *
 * @return bool: Indicates whether intiialisation was successfull or not
 *********************************************************************************************/
bool create_heartbeat_timer();
/***********************************************************************************************
 * @brief Record the timestamp value
 *
 * Record the timestamp value using clock_get_time function
 * @param null
 *
 * @return double: timestamp value
 *********************************************************************************************/
double record_time();

#endif //TIMER_H_
#ifndef SRC_IPC_H_
#define	SRC_IPC_H_
/********************************************************************************************
*					FILENAME: ipc.h
**********************************************************************************************/
/* Title: ipc.h
 * Brief: Responsible for implementing various helper function that helps in setting up interthread communication 
 * Author: Tanmay Chaturvedi, Vikrant Waje
 * Date Created: March 16, 2019
 * Course: Advanced Embedded Software Development
 * Project: 1
 *
 * 
 * 
 * */
/****************************************************************************************
*					HEADER FILE SECTION
***************************************************************************/

#include<stdint.h>
#include<sys/types.h>
#include<unistd.h>
#include<stdlib.h>
#include<mqueue.h>
#include<signal.h>
#include<string.h>
#include<stdio.h>
#include"logger.h"
#include"heartbeat.h"

/***************************************************************************************
*					MACROS AND ENUMS
***************************************************************************/

typedef struct{
	char sensor_string[40];
	double sensor_data;

}client_data_t;


typedef enum{

	MQ_SUCCESS, MQ_FAIL	
}ipc_return_t;

/*******************************************************************************************
*					GLOBAL VARIABLES
*******************************************************************************************/
extern mqd_t mqdes_server;

/*******************************************************************************************
*					FUNCTION DEFINITION
*******************************************************************************************/

ipc_return_t open_message_queue_server(mqd_t *mqdes, struct mq_attr * attribute);
ipc_return_t close_message_queue_server(mqd_t *mqdes);

#endif //SRC_IPC_H
/********************************************************************************************
*					FILENAME: heartbeat.h
**********************************************************************************************/
/* Title: heartbeat.h
 * Brief: Responsible for providing various helper function to support heartbeat functionality
 * Author: Tanmay Chaturvedi, Vikrant Waje
 * Date Created: March 16, 2019
 * Course: Advanced Embedded Software Development
 * Project: 1

 * Reference[1]: http://www.
 * 
 * */
/****************************************************************************************
*					HEADER FILE SECTION
*****************************************************************************************/
#ifndef HEARTBEAT_H_
#define HEARTBEAT_H_

#include<stdio.h>
#include<stdint.h>
#include<stdbool.h>
/**************************************************************************************
*					     MACROS
****************************************************************************************/


typedef struct{
	double timestamp;
	int log_level;
	uint8_t  source_ID[20];
	double sensor_data;
	bool error_flag;
}heartbeat_data_t;

typedef struct{
	bool heartbeat_temp_sensor_flag;
	bool heartbeat_light_sensor_flag;
}heartbeat_flag_t;

/**************************************************************************************
*					GLOBAL VARIABLES
****************************************************************************************/

/**************************************************************************************
*					FUNCTION PROTOTYPE
***************************************************************************************/

#endif /* HEARTBEAT_H_ */

/********************************************************************************************
*					FILENAME: thread.h
**********************************************************************************************/
/* Title:thread.h
 * Brief: Responsible for providing callback function for the four threads created in main function
 * Author: Tanmay Chaturvedi, Vikrant Waje
 * Date Created: March 16, 2019
 * Course: Advanced Embedded Software Development
 * Project: 1
 * 
 * 
 * */
/****************************************************************************************
*					HEADER FILE SECTION
*****************************************************************************************/
#ifndef THREAD_H_
#define THREAD_H_

#include <pthread.h>

/**************************************************************************************
*					     MACROS
****************************************************************************************/

/**************************************************************************************
*					GLOBAL VARIABLES
****************************************************************************************/
extern pthread_t thread1, thread2, thread3, thread4;
/**************************************************************************************
*					FUNCTION PROTOTYPE
***************************************************************************************/

/*******************************************************************************************
 * @brief Socket thread
 *
 * Waits for a connection initiated by an external client.
 * Once connected, accepts commands from client and acts accordingly.
 * If clients commands the connection to "close", server thread disconnects,
 * closes the socket connection and waits for a new connection.
 *
 * @param null
 *
 * @return null
 ********************************************************************************************/
void *socket_thread( void*);


/***********************************************************************************************
 * @brief Temperature thread
 *
 * Get the temperature value periodically from temperature sensor and logs 
 * into file opened by logger thread
 *
 * @param null
 *
 * @return null
 *********************************************************************************************/

void *temperature_thread( void*);



/***********************************************************************************************
 * @brief light sensor thread
 *
 * Get the LUX values from light sensor attached using I2C interface and report it periodically t * o logger thread
 *
 * @param null
 *
 * @return null
 *********************************************************************************************/

void *light_sensor_thread( void*);



/***********************************************************************************************
 * @brief logger thread
 *
 * Log the values of temperature, light sensor and socket status in log file created by logger task 
 * into file opened by logger thread
 *
 * @param null
 *
 * @return null
 *********************************************************************************************/

 void *logger_thread( void*);





#endif /* THREAD_H_ */

#ifndef SRC_SERVER_H_
#define	SRC_SERVER_H_
/********************************************************************************************
*					FILENAME: server.h
**********************************************************************************************/
/* Title: server.h
 * Brief: Responsible for providing various helper functions for setting up the server side
 * Author: Tanmay Chaturvedi, Vikrant Waje
 * Date Created: March 10, 2019
 * Course: Advanced Embedded Software Development
 * 
 * This program demonsrates IPC using Sockets for Project 1.
 * This is the Server Side.
 * Reference[1]: http://www.it.uom.gr/teaching/distrubutedSite/dsIdaLiu/labs/lab2_1/sockets.html
 * Reference[2]: https://www.youtube.com/watch?v=pFLQmnmDOo
 */

/****************************************************************************************
*					HEADER FILE SECTION
*****************************************************************************************/
#include <stdio.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <signal.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <mqueue.h>
#include <time.h>
#include <unistd.h>
#include <netinet/in.h>
#include <sys/time.h>
#include <netdb.h>
#include<stdbool.h>
#include"temp_sensor.h"
#include"ipc.h"
#include"led.h"
/***************************************************************************************
*					MACROS AND ENUMS
****************************************************************************************/
#define	PORT_NUM	(7000)
#define	LOG_FILE_NAME	"socketlog.txt"
#define NO_OF_CLIENT	(5)

typedef enum{
	SOCKET_FAIL,REUSE_FAIL,BIND_FAIL,LISTEN_FAIL,ACCEPT_FAIL,SOCKET_CONNECT_SUCCESS,SOCKET_SETUP_SUCCESS
}server_response_t;




/****************************************************************************************
* 					GLOBAL VARIABLES
*****************************************************************************************/
char *RxBuf[10] ;
int socket_fd;
int check_stat;
int sig_flag ;
int sock_stat;
struct sockaddr_in server_addr;

typedef struct{
 bool client_get_temp_flag;
 bool client_get_lux_flag;
 bool client_get_system_stat_flag;
}client_request_t;

/****************************************************************************************
* 					FUNCTION PROTOTYPES
*****************************************************************************************/
/*******************************************************************************************
 * @brief Socket Listening Routines
 *
 * Call the listen() and accept() and returns 1 on successful connection
 * with an external client
 
 * @param null
 *
 * @return 0 if error, 1 if success
 ********************************************************************************************/
server_response_t socket_connect(void);


/*******************************************************************************************
 * @brief Socket Setup Routines
 *
 * Call the socket(), bind() and returns 1 on successful setup
 
 * @param null
 *
 * @return 0 if error, 1 if success
 ********************************************************************************************/
server_response_t socket_setup(void);


/*******************************************************************************************
 * @brief Communicate with external client
 *
 * After connecting with external client, receives command from client and call respective
 * function.

 * @param null
 *
 * @return 0 if error, 1 if success
 ********************************************************************************************/
int server_establish(void);

#endif //SRC_SERVER_H_
/********************************************************************************************
*					FILENAME: bist.h
**********************************************************************************************/
/* Title: bist.h
 * Brief: Responsible for providing helper function for built in self test
 * Author: Tanmay Chaturvedi, Vikrant Waje
 * Date Created: March 16, 2019
 * Course: Advanced Embedded Software Development
 * Project: 1

 * Reference[1]: http://www.
 * 
 * 
 * */
/****************************************************************************************
*					HEADER FILE SECTION
*****************************************************************************************/
#ifndef BIST_H_
#define BIST_H_

#include "temp_sensor.h"
#include "light_sensor.h"
#include "logger.h"
#include "ipc.h"
#include"i2c_status.h"
#include"thread.h"
#include<pthread.h>
/**************************************************************************************
*					     MACROS
****************************************************************************************/
#define TLOW_VAL 	(50.0)
#define THIGH_VAL	(100.0)
#define THRESHOLD_HIGH	(100)
#define THRESHOLD_LOW	(60)					

/**************************************************************************************
*					FUNCTION PROTOTYPE
***************************************************************************************/
void built_in_self_test();

#endif 
	/********************************************************************************************
*					FILENAME: led.h
**********************************************************************************************/
/* Title: led.h
 * Brief: Responsible for providing various helper function needed for initializing and blinking the led
 * Author: Tanmay Chaturvedi, Vikrant Waje
 * Date Created: March 16, 2019
 * Course: Advanced Embedded Software Development
 * Project: 1

 * Reference[1]: http://www.teachmemicro.com/beaglebone-black-blink-led-using-c/#
 * 
 * 
 * */
/****************************************************************************************
*					HEADER FILE SECTION
*****************************************************************************************/
#ifndef LED_H_
#define LED_H_

#include <stdio.h>
#include<string.h>
#include<stdint.h>
/**************************************************************************************
*					     MACROS
****************************************************************************************/
#define RED_LED  ("49")
#define BLUE_LED ("117")
#define GREEN_LED ("115")
#define YELLOW_LED ("44")
/**************************************************************************************
*					GLOBAL VARIABLES
****************************************************************************************/

/**************************************************************************************
*					FUNCTION PROTOTYPE
***************************************************************************************/


/*******************************************************************************************
 * @brief Initialise LED gpio pins
 *
 * Initialise GPIO pins as output
 *
 * @param gpio_pin: GPIO pin whose direction is to be set
 *
 * @return null
 ********************************************************************************************/

void led_init(uint8_t gpio_pin[]);


/*******************************************************************************************
 * @brief Turn ON the led
 *
 * Turn the given LED ON, i.e output logic 1
 *
 * @param gpio_pin: GPIO pin which is to be turned ON
 *
 * @return null
 ********************************************************************************************/

void led_on(uint8_t gpio_pin[]);


/*******************************************************************************************
 * @brief Turn OFF the led
 *
 * Turn the given LED OFF, i.e output logic 0
 *
 * @param gpio_pin: GPIO pin which is to be turned OFF
 *
 * @return null
 ********************************************************************************************/
void led_off(uint8_t gpio_pin[]);

#endif /*LED_H*/	
/********************************************************************************************
*					FILENAME: logger.h
**********************************************************************************************/
/* Title: logger.h
 * Brief: Responsible for providing various helper function to support logger functionality
 * Author: Tanmay Chaturvedi, Vikrant Waje
 * Date Created: March 16, 2019
 * Course: Advanced Embedded Software Development
 * Project: 1

 * Reference[1]: http://www.
 * 
 * */
/****************************************************************************************
*					HEADER FILE SECTION
*****************************************************************************************/
#ifndef LOGGER_H_
#define LOGGER_H_

#include<stdio.h>
#include<stdint.h>
#include<stdbool.h>
/**************************************************************************************
*					     MACROS
****************************************************************************************/



#define LOG(fptr,time,log_level,source_id,sensor_value) fprintf(fptr,"\n %c%lf%c [%s]: loglevel:%d sensor value: %lf ",'[',time,']',source_id,log_level,sensor_value);	//Log into the file


typedef struct{
	double timestamp;
	int log_level;
	uint8_t  source_ID[20];
	double sensor_data;
}log_t;

typedef struct{
	bool log_temp_sensor_flag;
	bool log_light_sensor_flag;
}logger_flag_t;

/**************************************************************************************
*					GLOBAL VARIABLES
****************************************************************************************/

/**************************************************************************************
*					FUNCTION PROTOTYPE
***************************************************************************************/



#endif /* LOGGER_H_ */

/********************************************************************************************
*					FILENAME: main.h
**********************************************************************************************/
/* Title: main.h
 * Brief: Responsible for creating threads, joining them and initiating built in self test
 * Author: Tanmay Chaturvedi, Vikrant Waje
 * Date Created: March 16, 2019
 * Course: Advanced Embedded Software Development
 * Project: 1
 * 
 * 
 * */
/****************************************************************************************
*					HEADER FILE SECTION
*****************************************************************************************/
#ifndef SRC_MAIN_H_
#define SRC_MAIN_H_

#include "thread.h"
#include"timer.h"
#include"temp_sensor.h"
#include"light_sensor.h"
#include"logger.h"
#include"synchronization.h"
#include"server.h"
#include"ipc.h"
#include"led.h"
#include"bist.h"
/**************************************************************************************
*					     MACROS
****************************************************************************************/

/**************************************************************************************
*					GLOBAL VARIABLES
****************************************************************************************/


/**************************************************************************************
*					ENUM FOR ERRORS
***************************************************************************************/
typedef enum{

	PTHREAD_SUCCESS, PTHREAD_FAIL	
}return_type_t;

/**************************************************************************************
*					FUNCTION PROTOTYPE
***************************************************************************************/
return_type_t main_func();



#endif /* SRC_MAIN_H_ */
#ifndef SRC_LIGHT_H_
#define SRC_LIGHT_H_

/********************************************************************************************
*					FILENAME: light_sensor.h
**********************************************************************************************/
/* Title Light sensor.h
 * Brief: Contains function that are used for communication with light sensor
 * Author: Tanmay Chaturvedi, Vikrant Waje
 * Date Created: March 16, 2019
 * Course: Advanced Embedded Software Development
 * Project: 1

 * Reference[1]: http://www.sparkfun.com/products/14350
 * 
 * 
 * */
/****************************************************************************************
*					HEADER FILE SECTION
*****************************************************************************************/

#include<stdio.h>
#include<unistd.h>
#include<fcntl.h>
#include<sys/ioctl.h>
#include<linux/i2c-dev.h>
#include<stdint.h>
#include<stdlib.h>
#include<math.h>
#include"i2c_status.h"
#include"logger.h"
#include"server.h"
#include"ipc.h"
/***************************************************************************************
*					MACROS AND ENUMS
****************************************************************************************/


typedef enum{
	INTEGRATION_TIME, GAIN, NONE
}read_cmd_t;

typedef enum{
	DARK,LIGHT
}last_state_t;
// typedef enum{
// 	INTERRUPT_ON, INTERRUPT_OFF
// }interrupt_cmd_t;

#define LIGHT_SENSOR_I2C_ADDRESS (0x39)
#define CONTROL_REG	 	(0x00)
#define TIMING_REG		(0x01)
#define THRESHLOWLOW_REG	(0x02)
#define THRESHLOWHIGH_REG	(0x03)
#define THRESHHIGHLOW_REG	(0x04)
#define THRESHHIGHHIGH_REG	(0x05)
#define INTERRUPT_REG		(0x06)
#define CRC			(0x08)
#define ID_REG			(0x0A)
#define DATA0LOW_REG		(0x0C)
#define DATA0HIGH_REG		(0x0D)
#define DATA1LOW_REG		(0x0E)
#define DATA1HIGH_REG		(0x0F)

#define IDENTIFICATION_MASK	(0x05)
#define INTEGRATION_MASK	(0x03)
#define GAIN_MASK		(0x01)

#define	INTEGRATION_13_7	((0x00))
#define INTEGRATION_101		((0x01))
#define INTEGRATION_402		((0x02))

#define LOW_GAIN			((0x00))
#define HIGH_GAIN			((0x01))

#define	INTERRUPT_OFF		((0x00))
#define	INTERRUPT_ON		((0x01))

#define COMMAND_BIT		(0x80)
#define WORD_OPERATION_BIT	(0x20)

/***************************************************************************************
*				GLOBAL VARIABLE SECTION
****************************************************************************************/
/*************************************************************************************
*				FUNCTION PROTOTYPE
*****************************************************************************************/
/*********************************************************************************************** 
 * @brief write register in light sensor 
 *
 *Responsible for writing into  register of light sensor
 *
 * @param address: address of  register  of light sensor
 * @param data: data to be written into register of light sensor
 *
 * @return status of I2C operation
 *********************************************************************************************/
sensor_status_t light_write_reg(uint8_t address, uint8_t data);

/*********************************************************************************************** 
 * @brief Read register in light sensor 
 *
 *Responsible for reading from register of light sensor
 *
 * @param address: address of  register  of light sensor
 * @param data: data to be read from register of light sensor
 * @param command: Bits to be read from particular register from light sensor
 * @return status of I2C operation
 *********************************************************************************************/
sensor_status_t light_read_reg(uint8_t address, uint8_t *data,read_cmd_t command);

/*********************************************************************************************** 
 * @brief Read two register in light sensor 
 *
 *Responsible for reading from two  register of light sensor
 *
 * @param address: address of  register  of light sensor
 * @param data: data to be read from register of light sensor
 * @param command: Bits to be read from particular register from light sensor
 * @return status of I2C operation
 *********************************************************************************************/

sensor_status_t read_two_reg(uint8_t address, uint8_t *data);
/*********************************************************************************************** 
 * @brief Read lux values 
 *
 *Responsible for reading lux value from light sensor
 *
 * @param null
 * @return double: Returns the lux values from light sensor
 *********************************************************************************************/
double read_lux();

/***********************************************************************************************  
 * @brief Power on light sensor 
 *
 *Responsible for turning On light sensor before reading any data
 *
 * @param  null
 *
 * @return null
 *********************************************************************************************/

sensor_status_t light_sensor_power_on();



/***********************************************************************************************  
 * @brief Set Integration Time 
 *
 *Responsible for setting up integration time based on INTEGRATION values
 *
 * @param INTEGRATION
 *
 * @return status of I2C operation
 *********************************************************************************************/
sensor_status_t set_integration_time(uint8_t INTEGRATION);



/***********************************************************************************************  
 * @brief Get Integration Time 
 *
 *Responsible for retrieivng set integration 
 *
 * @param uint8_t *data
 *
 * @return status of I2C operation
 *********************************************************************************************/
sensor_status_t get_integration_time(uint8_t *data);

/***********************************************************************************************  
 * @brief Read identification register 
 *
 *Responsible for reading identification register 
 *
 * @param uint8_t data
 *
 * @return status of I2C operation
 *********************************************************************************************/
sensor_status_t read_identification_reg(uint8_t *data);

	
/***********************************************************************************************  
 * @brief Set gain 
 *
 * Responsible for setting gain values. Switches gain between low gain and high gain modes. 
 * Writing a 0 selects low gain (1x); writing a 1 selects high gain (16x). 
 *
 * @param gainlevel
 *
 * @return status of I2C operation
 *********************************************************************************************/
sensor_status_t set_gain( int gainlevel );

/***********************************************************************************************  
 * @brief Get gain 
 *
 *Responsible for retrieivng gain 
 *
 * @param uint8_t *data
 *
 * @return status of I2C operation
 *********************************************************************************************/
sensor_status_t get_gain(uint8_t *data);

/***********************************************************************************************  
 * @brief Configure Interrupt Controller Register
 *
 * Enables/Disables Interrupt through Interrupt Controller Register
 *
 * @param uint8_t command
 *
 * @return status of I2C operation
 *********************************************************************************************/
sensor_status_t config_interrupt_ctrl_reg( uint8_t command );

/***********************************************************************************************  
 * @brief Get value of Interrupt control Register 
 *
 *Responsible for retrieving value of Interrupt Control Register
 *
 * @param null
 *
 * @return status of I2C operation
 *********************************************************************************************/

// i think this function is not required
sensor_status_t get_interrupt_ctrl_reg(uint8_t *data);

/***********************************************************************************************  
 * @brief Get value of Interrupt control Register 
 *
 *Responsible for retrieving value of Interrupt Control Register
 *
 * @param null
 *
 * @return status of I2C operation
 *********************************************************************************************/

// i think this function is not required
sensor_status_t get_interrupt_ctrl_reg(uint8_t *data);


/***********************************************************************************************  
 * @brief Write low threshold
 *
 *Write to Registers THRESLOWLOW and THRESHLOWHHIGH provide the low byte and
 * high byte, respectively, of the lower interrupt threshold 
 *
* @param uint16_t *data
 *
 * @return status of I2C operation
 *********************************************************************************************/

sensor_status_t set_low_threshold(uint16_t data);



/***********************************************************************************************  
 * @brief Read low threshold
 *
 * Registers THRESHLOWLOW and THRESHLOWHIGH provide the low byte and
 * high byte, respectively, of the lower interrupt threshold
 *
 * @param uint16_t *data
 *
 * @return status of I2C operation
 *********************************************************************************************/
sensor_status_t get_low_threshold(uint16_t *data);

/***********************************************************************************************  
 * @brief Write high threshold
 *
 *Write to Registers THRESHIGHLOW and THRESHHIGHHIGH provide the low byte and
 * high byte, respectively, of the lower interrupt threshold 
 *
* @param uint16_t *data
 *
 * @return status of I2C operation
 *********************************************************************************************/

sensor_status_t set_high_threshold(uint16_t data);

/***********************************************************************************************  
 * @brief Read high threshold
 *
 * Registers THRESHIGHLOW and THRESHHIGHHIGH provide the low byte and
 * high byte, respectively, of the lower interrupt threshold
 *
 * @param uint16_t *data
 *
 * @return status of I2C operation
 *********************************************************************************************/
sensor_status_t get_high_threshold(uint16_t *data);



#endif	//SRC_LIGHT_H_
#ifndef SYNCHRONIZATION_H_
#define SYNCHRONIZATION_H_

/********************************************************************************************
*					FILENAME: synchronization.h
**********************************************************************************************/
/* Title: synchronization.h
* Brief: Responsible for providing various synchronization constructs
* Author: Tanmay Chaturvedi, Vikrant Waje
* Date Created: March 16, 2019
* Course: Advanced Embedded Software Development
* Project: 1
* 
* 
* */
/****************************************************************************************
*					HEADER FILE SECTION
*****************************************************************************************/
#include<pthread.h>
/***************************************************************************************
*					MACROS AND ENUMS
****************************************************************************************/


/**************************************************************************************
*				GLOBAL VARIABLES
****************************************************************************************/
extern pthread_mutex_t i2c_mutex;
extern pthread_mutex_t logger_queue_mutex;
extern pthread_mutex_t heartbeat_queue_mutex;
#endif //SYNCHRONIZATION_H
#ifndef SRC_GPIO_H_
#define SRC_GPIO_H_
/********************************************************************************************
 *					FILENAME: gpiointerrupt.h
 **********************************************************************************************/
/* Title: temp_sensor.h
 * Brief: Responsible for providing various helper function needed to communicate with temperature sensor
 * Author: Tanmay Chaturvedi, Vikrant Waje
 * Date Created: March 26, 2019
 * Course: Advanced Embedded Software Development
 * Project: 1

 * Reference[1]: 
 * 
 * 
 * */
/****************************************************************************************
 *					HEADER FILE SECTION
 *****************************************************************************************/
#include <poll.h>
#include <fcntl.h>
#include<stdio.h>
#include<sys/types.h>
#include<sys/stat.h>
#include<unistd.h>
/****************************************************************************************
 *					GLOBAL VARIABLES
 *****************************************************************************************/
extern int file_gpio;
extern char val[4];
struct pollfd filedes[1];
/****************************************************************************************
 *					MACRO
 *****************************************************************************************/
#define	NUM_FD	(1)
#define	TIMEOUT_MSECS	(3)



/****************************************************************************************
 *					FUNCTION PROTOTYPE 
 *****************************************************************************************/
/***********************************************************************************************
 * @brief IRQ handler
 *
 * Handler that returns state of GPIO pin 
 * @param null
 *
 * @return char
 *********************************************************************************************/
char IRQ_handler(void);


/***********************************************************************************************
 * @brief GPIO initilisation function
 *
 * Initialises GPIO pin
 * @param null
 *
 * @return int: error status
 *********************************************************************************************/
int GPIO_init(void);
#endif
#ifndef SRC_TEMP_H_
#define SRC_TEMP_H_
/********************************************************************************************
 *					FILENAME:temp_sensor.h
 **********************************************************************************************/
/* Title: temp_sensor.h
 * Brief: Responsible for providing various helper function needed to communicate with temperature sensor
 * Author: Tanmay Chaturvedi, Vikrant Waje
 * Date Created: March 16, 2019
 * Course: Advanced Embedded Software Development
 * Project: 1

 * Reference[1]: http://www.sparkfun.com/products/13314
 * 
 * 
 * */
/****************************************************************************************
 *					HEADER FILE SECTION
 *****************************************************************************************/
#include<stdio.h>
#include<unistd.h>
#include<fcntl.h>
#include<sys/ioctl.h>
#include<linux/i2c-dev.h>
#include<stdint.h>
#include<stdlib.h>
#include"i2c_status.h"
#include"logger.h"
#include"server.h"
#include"ipc.h"
/****************************************************************************************
 *					MACROS AND ENUMS
 *****************************************************************************************/
#define TEMP_SENSOR_I2C_ADDRESS (0x48)
#define TEMPERATURE_REG		(0x00)
#define CONFIGURATION_REG	 (0x01)
#define TLOW_REG		(0x02)
#define THIGH_REG		(0x03)

#define CONVERSION_RATE_0_25	((0x00))
#define CONVERSION_RATE_1	((0x01))
#define CONVERSION_RATE_4	((0x02))
#define CONVERSION_RATE_8	((0x03))
#define CONVERSION_RATE_MASK	(0x03)


#define SHUTDOWN_ON		((0x01))
#define SHUTDOWN_OFF		((0x00))

#define EM_ON			((0x01))
#define EM_OFF			((0x00))
#define EM_MASK			(0x01)


#define FAULT_1			((0x00)) 
#define FAULT_2			((0x01))
#define FAULT_3			((0x02))
#define FAULT_4			((0x03))
#define FAULT_MASK		(0x03)

#define RESOLUTION_MASK			(0x03)
#define SENSOR_RESOLUTION_12_BIT	(0x03)


#define READ_TEMPERATURE_ERROR	(double)(-56.000000)

typedef enum{
	REQUEST_CELSIUS, REQUEST_KELVIN, REQUEST_FAHRENHEIT
}request_cmd_t;


typedef enum{
	FAULT,EM,CONVERSION_RATE,SD_MODE,RESOLUTION,ALL
}reg_read_cmd_t;



/****************************************************************************************
 *				GLOBAL VARIABLE SECTION
 *****************************************************************************************/


/*************************************************************************************
 *				FUNCTION PROTOTYPE SECTION
 *****************************************************************************************/
/***********************************************************************************************
 * @brief write pointer register
 *
 *Responsible for writing into pointer registerof temperature sensor TMP102
 *
 * @param address: address of pointer register TMP102
 *
 * @return status of I2C operation
 *********************************************************************************************/


sensor_status_t write_ptr_reg(uint8_t address);

/***********************************************************************************************  * @brief write register in temperature register
 *
 *Responsible for writing into  register of temperature sensor TMP102
 *
 * @param address: address of  register  of TMP102
 * @param data: data to be written into register of TMP102
 *
 * @return status of I2C operation
 *********************************************************************************************/

sensor_status_t temperature_write_reg(uint8_t address, uint16_t data);

/***********************************************************************************************  * @brief Read register in temperature register
 *
 *Responsible for reading from  register of temperature sensor TMP102
 *
 * @param address: address of  register  of TMP102
 * @param data: data to be read from  register of TMP102
 * @param command: register bits which are to be read
 * @return status of I2C operation
 *********************************************************************************************/


sensor_status_t temperature_read_reg(uint8_t address, uint8_t *data,reg_read_cmd_t command);
/***********************************************************************************************  * @brief Get temperature
 *
 * Read the value from temperature register
 *
 * @param request: Temperature value in kelvin, celsius and farhenheit to be returned
 * @return double: Value of converted temperature
 *********************************************************************************************/


double get_temperature(request_cmd_t request);


/*********************************************************************************************** 
 * @brief Write tlow
 *
 * Write the value of tlow 
 *
 * @param :null
 * @return sensor_stat_t: Status of I2C operation
 *********************************************************************************************/
sensor_status_t write_tlow(float temperature);

/***********************************************************************************************  
 * @brief Get Tlow register
 *
 * Read the value from tlow register
 *
 * @param request: Temperature value in kelvin, celsius and farhenheit to be returned
 * @return double: Value of converted temperature
 *********************************************************************************************/


double get_Tlow(request_cmd_t request);

/*********************************************************************************************** 
 * @brief Write thigh
 *
 * Write the value of thigh 
 *
 * @param :null
 * @return sensor_stat_t: Status of I2C operation
 *********************************************************************************************/
sensor_status_t write_thigh(float temperature);


/***********************************************************************************************  
 * @brief Get Thigh register
 *
 * Read the value from thigh register
 *
 * @param request: Temperature value in kelvin, celsius and farhenheit to be returned
 * @return double: Value of converted temperature
 *********************************************************************************************/


double get_Thigh(request_cmd_t request);


/*********************************************************************************************** 
 * @brief set sensor in shutdown mode
 *
 * set the configuration register in shutdown mode
 *
 * @param :null
 * @return :status of I2C operation
 *********************************************************************************************/

sensor_status_t configure_temp_shutdown(void);


/*********************************************************************************************** 
 * @brief Write fault bits
 *
 * Write the fault bits in configuration register 
 *
 * @param :null
 * @return sensor_stat_t: Status of I2C operation
 *********************************************************************************************/
sensor_status_t configure_temp_fault(uint8_t mode);

/*********************************************************************************************** 
 * @brief Read fault bits from configuration register
 *
 *  Read fault bits
 *
 * @param :uint8_t* data
 * @return :status of I2C operation
 *********************************************************************************************/


sensor_status_t read_temp_fault(uint8_t *data);


/*********************************************************************************************** 
 * @brief set sensor in EM mode
 *
 * set the configuration register in EM mode
 *
 * @param :mode
 * @return :status of I2C operation
 *********************************************************************************************/

sensor_status_t configure_temp_EMmode(uint8_t mode);


/*********************************************************************************************** 
 * @brief Read EM mode from configuration register
 *
 *  Read Em mode bits
 *
 * @param :uint8_t *data
 * @return :status of I2C operation
 *********************************************************************************************/


sensor_status_t read_temp_EM(uint8_t *data);


/*********************************************************************************************** 
 * @brief set sensor conversion rate
 *
 * set the conversion rate of temperature sensor
 *
 * @param :data: To Set the conversion rate
 * @return :status of I2C operation
 *********************************************************************************************/


sensor_status_t configure_temp_conversion_rate(uint8_t rate);


/*********************************************************************************************** 
 * @brief Read conversion rate from configuration register
 *
 *  Read Conversion rate
 *
 * @param :uint8_t *data
 * @return :status of I2C operations
 *********************************************************************************************/

sensor_status_t read_temp_conversion_rate(uint8_t *data);

/*********************************************************************************************** 
 * @brief Read sensor resolution from configuration register
 *
 *  Read sensor resolution
 *
 * @param :uint8_t *data
 * @return :status of I2C operations
 *********************************************************************************************/

sensor_status_t read_temp_sensor_resolution(uint8_t *data);



#endif	//SRC_TEMP_H_
#ifndef I2C_STATUS_H_
#define I2C_STATUS_H_

/********************************************************************************************
*					FILENAME: i2c_status.h
**********************************************************************************************/
/*
 * Author: Tanmay Chaturvedi, Vikrant Waje
 * Date Created: March 16, 2019
 * Course: Advanced Embedded Software Development
 * Project: 1

 * Reference[1]: http://www.it.uom.gr/teaching/distrubutedSite/dsIdaLiu/labs/lab2_1/sockets.html
 * Reference[2]: Based on code from https://riptutorial.com/posix/example/16306/posix-timer-with-sigev-thread-notification
 * 
 * 
 * */
/****************************************************************************************
*					HEADER FILE SECTION
*****************************************************************************************/

#include<stdint.h>

/***************************************************************************************
*					MACROS AND ENUMS
****************************************************************************************/
typedef enum{
	WRITE_REG_SUCCESS = 1, READ_REG_SUCCESS =2, WRITE_REG_FAIL=-1, READ_REG_FAIL=-2

}sensor_status_t;


/**************************************************************************************
*				GLOBAL VARIABLES
****************************************************************************************/

#endif //I2C_STATUS_H
#ifndef SIGNAL_HANDLER_H_
#define SIGNAL_HANDLER_H_
/********************************************************************************************
*					FILENAME: signal_handler.h
**********************************************************************************************/
/* Title: signal_handler.h
 * Brief: Responsible for providing various synchronization constructs
 * Author: Tanmay Chaturvedi, Vikrant Waje
 * Date Created: March 16, 2019
 * Course: Advanced Embedded Software Development
 * Project: 1
 * 
 * 
 * */
/****************************************************************************************
*					HEADER FILE SECTION
*****************************************************************************************/

#include<stdio.h>
#include<signal.h>
#include<stdbool.h> 
#include<stdint.h>

/**************************************************************************************
*					    GLOBAL VARIABLES
****************************************************************************************/
struct sigaction user_defined;
extern bool system_shutdown_flag;
extern bool system_shutdown_main_flag;
/**************************************************************************************
*					FUNCTION DEFINITION
***************************************************************************************/
/***********************************************************************************************
 * @brief system shutdown handler
 *
 * Handler invoked when user presses CTRL + C
 * @param num: Checks type of signal
 *
 * @return null
 *********************************************************************************************/
void system_shutdown_handler(int num);
/***********************************************************************************************
* @brief Initialise system shutdown handler
*
* Initialising parameter for system shutdown handler
* @param null
*
* @return null
*********************************************************************************************/

void signal_handler_init();

#endif
#ifndef TIMER_H_
#define TIMER_H_
/********************************************************************************************
*					FILENAME: timer.h
**********************************************************************************************/
/* Title: timer.c
 * Brief: Responsible for providing various helper function needed for logger and heartbeat
 * Author: Tanmay Chaturvedi, Vikrant Waje
 * Date Created: March 16, 2019
 * Course: Advanced Embedded Software Development
 * Project: 1

 * Reference[1]: Professor's slides and notes 
 * 
 * */
/****************************************************************************************
*					HEADER FILE SECTION
*****************************************************************************************/

#include <signal.h>
#include <time.h>
#include <stdio.h>
#include<stdbool.h>
#include"logger.h"
#include"heartbeat.h"
#include"signal_handler.h"
/****************************************************************************************
*				     MACROS AND ENUMS
*****************************************************************************************/
#define SEC_TO_MILLISEC		(1000.0)
#define NANOSEC_TO_MILLISEC	(1000000.0)

/****************************************************************************************
*				GLOBAL VARIABLE SECTION
*****************************************************************************************/
//Flag variables
extern int log_timer_flag;
extern int heartbeat_timer_flag;
// Logger timer id
timer_t log_timer_id;
//Heartbeat timer id
timer_t heartbeat_timer_id;
timer_t heartbeat_recovery_timer_id;
//timespec struct for giving interval values
struct itimerspec timer_setting;
struct sigevent signal_specification;

extern bool logger_heartbeat_indicator;
extern bool light_heartbeat_indicator ;
extern bool temp_heartbeat_indicator ;
/***************************************************************************************
*				FUNCTION PROTOTYPE
*****************************************************************************************/
/***********************************************************************************************
 * @brief logger  timer handler
 *
 * Handler that executes periodically to generate logging interval
 * @param null
 *
 * @return null
 *********************************************************************************************/
void log_timer_handler(int num);
/***********************************************************************************************
 * @brief heartbeat timer handler
 *
 * Handler that executes periodically to generate heartbeat interval
 * @param null
 *
 * @return null
 *********************************************************************************************/
void heartbeat_timer_handler(int num);
/***********************************************************************************************
 * @brief Create log timer
 *
 * Responsible for creating log timer which expires periodically to collect sensor information an
 * nd socket status that is logged into log file
 * @param null
 *
 * @return bool: Indicates whether intiialisation was successfull or not
 *********************************************************************************************/
bool create_log_timer();

/***********************************************************************************************
 * @brief Create heartbeat timer
 *
 * Responsible for generating heartbeat for each of the four thread
 * @param null
 *
 * @return bool: Indicates whether intiialisation was successfull or not
 *********************************************************************************************/
bool create_heartbeat_timer();
/***********************************************************************************************
 * @brief Record the timestamp value
 *
 * Record the timestamp value using clock_get_time function
 * @param null
 *
 * @return double: timestamp value
 *********************************************************************************************/
double record_time();
/***********************************************************************************************
 * @brief heartbeat recovery timer handler
 *
 * Handler that executes to check for heartbeat recovery
 * @param num
 *
 * @return null
 *********************************************************************************************/
void heartbeat_recovery_timer_handler(int num);
	

//	printf("\n\rHi heartbeat");

/***********************************************************************************************
 * @brief Create heartbeat recovery timer
 *
 * Responsible for recovery of system
 * @param null
 *
 * @return bool: Indicates whether intiialisation was successfull or not
 *********************************************************************************************/
bool create_heartbeat_recovery_timer();

#endif //TIMER_H_
#ifndef SRC_IPC_H_
#define	SRC_IPC_H_
/********************************************************************************************
*					FILENAME: ipc.h
**********************************************************************************************/
/* Title: ipc.h
 * Brief: Responsible for implementing various helper function that helps in setting up interthread communication 
 * Author: Tanmay Chaturvedi, Vikrant Waje
 * Date Created: March 16, 2019
 * Course: Advanced Embedded Software Development
 * Project: 1
 *
 * 
 * 
 * */
/****************************************************************************************
*					HEADER FILE SECTION
***************************************************************************/

#include<stdint.h>
#include<sys/types.h>
#include<unistd.h>
#include<stdlib.h>
#include<mqueue.h>
#include<signal.h>
#include<string.h>
#include<stdio.h>
#include"logger.h"
#include"heartbeat.h"
#include"synchronization.h"
/***************************************************************************************
*					MACROS AND ENUMS
***************************************************************************/

typedef struct{
	char sensor_string[40];
	double sensor_data;

}client_data_t;

/*******************************************************************************************
*					GLOBAL VARIABLES
*******************************************************************************************/
extern mqd_t mqdes_server;
extern mqd_t mqdes_logger;
extern mqd_t mqdes_heartbeat;
/*******************************************************************************************
*					FUNCTION DEFINITION
*******************************************************************************************/

void open_message_queue_server(mqd_t *mqdes, struct mq_attr * attribute);
void close_message_queue_server(mqd_t *mqdes);
void open_message_queue_logger(mqd_t *mqdes, struct mq_attr * attribute);
void close_message_queue_logger(mqd_t *mqdes);
void open_message_queue_heartbeat(mqd_t *mqdes, struct mq_attr * attribute);
void close_message_queue_heartbeat(mqd_t *mqdes);

#endif //SRC_IPC_H
/********************************************************************************************
*					FILENAME: heartbeat.h
**********************************************************************************************/
/* Title: heartbeat.h
 * Brief: Responsible for providing various helper function to support heartbeat functionality
 * Author: Tanmay Chaturvedi, Vikrant Waje
 * Date Created: March 16, 2019
 * Course: Advanced Embedded Software Development
 * Project: 1

 * Reference[1]: http://www.
 * 
 * */
/****************************************************************************************
*					HEADER FILE SECTION
*****************************************************************************************/
#ifndef HEARTBEAT_H_
#define HEARTBEAT_H_

#include<stdio.h>
#include<stdint.h>
#include<stdbool.h>
#include"ipc.h"
/**************************************************************************************
*					     MACROS
****************************************************************************************/


typedef struct{
	double timestamp;
	int log_level;
	uint8_t  source_ID[20];
	double sensor_data;
	bool error_flag;
}heartbeat_data_t;

typedef struct{
	bool heartbeat_temp_sensor_flag;
	bool heartbeat_light_sensor_flag;
	bool heartbeat_logger_flag;
	bool heartbeat_server_flag;
}heartbeat_flag_t;

/**************************************************************************************
*					GLOBAL VARIABLES
****************************************************************************************/
extern mqd_t mqdes_heartbeat;
/**************************************************************************************
*					FUNCTION PROTOTYPE
***************************************************************************************/

#endif /* HEARTBEAT_H_ */

/********************************************************************************************
*					FILENAME: thread.h
**********************************************************************************************/
/* Title:thread.h
 * Brief: Responsible for providing callback function for the four threads created in main function
 * Author: Tanmay Chaturvedi, Vikrant Waje
 * Date Created: March 16, 2019
 * Course: Advanced Embedded Software Development
 * Project: 1
 * 
 * 
 * */
/****************************************************************************************
*					HEADER FILE SECTION
*****************************************************************************************/
#ifndef THREAD_H_
#define THREAD_H_

#include <pthread.h>

/**************************************************************************************
*					     MACROS
****************************************************************************************/

/**************************************************************************************
*					GLOBAL VARIABLES
****************************************************************************************/
extern pthread_t thread1, thread2, thread3, thread4;
/**************************************************************************************
*					FUNCTION PROTOTYPE
***************************************************************************************/

/*******************************************************************************************
 * @brief Socket thread
 *
 * Waits for a connection initiated by an external client.
 * Once connected, accepts commands from client and acts accordingly.
 * If clients commands the connection to "close", server thread disconnects,
 * closes the socket connection and waits for a new connection.
 *
 * @param null
 *
 * @return null
 ********************************************************************************************/
void *socket_thread( void*);


/***********************************************************************************************
 * @brief Temperature thread
 *
 * Get the temperature value periodically from temperature sensor and logs 
 * into file opened by logger thread
 *
 * @param null
 *
 * @return null
 *********************************************************************************************/

void *temperature_thread( void*);



/***********************************************************************************************
 * @brief light sensor thread
 *
 * Get the LUX values from light sensor attached using I2C interface and report it periodically t * o logger thread
 *
 * @param null
 *
 * @return null
 *********************************************************************************************/

void *light_sensor_thread( void*);



/***********************************************************************************************
 * @brief logger thread
 *
 * Log the values of temperature, light sensor and socket status in log file created by logger task 
 * into file opened by logger thread
 *
 * @param null
 *
 * @return null
 *********************************************************************************************/

 void *logger_thread( void*);





#endif /* THREAD_H_ */

#ifndef SRC_SERVER_H_
#define	SRC_SERVER_H_
/********************************************************************************************
*					FILENAME: server.h
**********************************************************************************************/
/* Title: server.h
 * Brief: Responsible for providing various helper functions for setting up the server side
 * Author: Tanmay Chaturvedi, Vikrant Waje
 * Date Created: March 10, 2019
 * Course: Advanced Embedded Software Development
 * 
 * This program demonsrates IPC using Sockets for Project 1.
 * This is the Server Side.
 * Reference[1]: http://www.it.uom.gr/teaching/distrubutedSite/dsIdaLiu/labs/lab2_1/sockets.html
 * Reference[2]: https://www.youtube.com/watch?v=pFLQmnmDOo
 */

/****************************************************************************************
*					HEADER FILE SECTION
*****************************************************************************************/
#include <stdio.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <signal.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <mqueue.h>
#include <time.h>
#include <unistd.h>
#include <netinet/in.h>
#include <sys/time.h>
#include <netdb.h>
#include<stdbool.h>
#include"temp_sensor.h"
#include"ipc.h"
#include"led.h"
#include"heartbeat.h"
#include"logger.h"
#include"timer.h"
#include<pthread.h>
/***************************************************************************************
*					MACROS AND ENUMS
****************************************************************************************/
#define	PORT_NUM	(7000)
#define	LOG_FILE_NAME	"socketlog.txt"
#define NO_OF_CLIENT	(5)

typedef enum{
	SOCKET_FAIL,REUSE_FAIL,BIND_FAIL,LISTEN_FAIL,ACCEPT_FAIL,SOCKET_CONNECT_SUCCESS,SOCKET_SETUP_SUCCESS
}server_response_t;




/****************************************************************************************
* 					GLOBAL VARIABLES
*****************************************************************************************/
char *RxBuf[10] ;
extern int socket_fd;
int check_stat;
int sig_flag ;
extern int sock_stat;
struct sockaddr_in server_addr;

typedef struct{
 bool client_get_temp_flag;
 bool client_get_lux_flag;
 bool client_get_system_stat_flag;
}client_request_t;

/****************************************************************************************
* 					FUNCTION PROTOTYPES
*****************************************************************************************/
/*******************************************************************************************
 * @brief Socket Listening Routines
 *
 * Call the listen() and accept() and returns 1 on successful connection
 * with an external client
 
 * @param null
 *
 * @return 0 if error, 1 if success
 ********************************************************************************************/
server_response_t socket_connect(void);


/*******************************************************************************************
 * @brief Socket Setup Routines
 *
 * Call the socket(), bind() and returns 1 on successful setup
 
 * @param null
 *
 * @return 0 if error, 1 if success
 ********************************************************************************************/
server_response_t socket_setup(void);


/*******************************************************************************************
 * @brief Communicate with external client
 *
 * After connecting with external client, receives command from client and call respective
 * function.

 * @param null
 *
 * @return 0 if error, 1 if success
 ********************************************************************************************/
int server_establish(void);

#endif //SRC_SERVER_H_
/********************************************************************************************
*					FILENAME: bist.h
**********************************************************************************************/
/* Title: bist.h
 * Brief: Responsible for providing helper function for built in self test
 * Author: Tanmay Chaturvedi, Vikrant Waje
 * Date Created: March 16, 2019
 * Course: Advanced Embedded Software Development
 * Project: 1

 * Reference[1]: http://www.
 * 
 * 
 * */
/****************************************************************************************
*					HEADER FILE SECTION
*****************************************************************************************/
#ifndef BIST_H_
#define BIST_H_

#include "temp_sensor.h"
#include "light_sensor.h"
#include "logger.h"
#include "ipc.h"
#include"i2c_status.h"
#include"timer.h"
#include"thread.h"
#include"synchronization.h"
#include<pthread.h>
/**************************************************************************************
*					     MACROS
****************************************************************************************/
#define TLOW_VAL 	(26.0)		// For temperature Alert
#define THIGH_VAL	(27.0)	
#define THRESHOLD_HIGH	(100)	// For light Interrupt Threshold Register
#define THRESHOLD_LOW	(60)					

/**************************************************************************************
*					FUNCTION PROTOTYPE
***************************************************************************************/
void built_in_self_test(char *argv);

#endif 
/********************************************************************************************
*					FILENAME: led.h
**********************************************************************************************/
/* Title: led.h
 * Brief: Responsible for providing various helper function needed for initializing and blinking the led
 * Author: Tanmay Chaturvedi, Vikrant Waje
 * Date Created: March 16, 2019
 * Course: Advanced Embedded Software Development
 * Project: 1

 * Reference[1]: http://www.teachmemicro.com/beaglebone-black-blink-led-using-c/#
 * 
 * 
 * */
/****************************************************************************************
*					HEADER FILE SECTION
*****************************************************************************************/
#ifndef LED_H_
#define LED_H_

#include <stdio.h>
#include<string.h>
#include<stdint.h>
/**************************************************************************************
*					     MACROS
****************************************************************************************/
#define RED_LED  ("49")
#define BLUE_LED ("117")
#define GREEN_LED ("115")
#define YELLOW_LED ("44")
/**************************************************************************************
*					GLOBAL VARIABLES
****************************************************************************************/

/**************************************************************************************
*					FUNCTION PROTOTYPE
***************************************************************************************/


/*******************************************************************************************
 * @brief Initialise LED gpio pins
 *
 * Initialise GPIO pins as output
 *
 * @param gpio_pin: GPIO pin whose direction is to be set
 *
 * @return null
 ********************************************************************************************/

void led_init(uint8_t gpio_pin[]);


/*******************************************************************************************
 * @brief Turn ON the led
 *
 * Turn the given LED ON, i.e output logic 1
 *
 * @param gpio_pin: GPIO pin which is to be turned ON
 *
 * @return null
 ********************************************************************************************/

void led_on(uint8_t gpio_pin[]);


/*******************************************************************************************
 * @brief Turn OFF the led
 *
 * Turn the given LED OFF, i.e output logic 0
 *
 * @param gpio_pin: GPIO pin which is to be turned OFF
 *
 * @return null
 ********************************************************************************************/
void led_off(uint8_t gpio_pin[]);

#endif /*LED_H*/	
/********************************************************************************************
*					FILENAME: logger.h
**********************************************************************************************/
/* Title: logger.h
 * Brief: Responsible for providing various helper function to support logger functionality
 * Author: Tanmay Chaturvedi, Vikrant Waje
 * Date Created: March 16, 2019
 * Course: Advanced Embedded Software Development
 * Project: 1

 * Reference[1]: http://www.
 * 
 * */
/****************************************************************************************
*					HEADER FILE SECTION
*****************************************************************************************/
#ifndef LOGGER_H_
#define LOGGER_H_

#include<stdio.h>
#include<stdint.h>
#include<stdbool.h>
/**************************************************************************************
*					     MACROS
****************************************************************************************/



#define LOG(fptr,time,log_level,source_id,sensor_value) fprintf(fptr,"\n %c%lf%c [%s]:		LOGLEVEL:%d SENSOR VALUE: %lf ",'[',time,']',source_id,log_level,sensor_value);	//Log into the file
#define LOG_GENERAL(fptr,time,log_level,source_id) fprintf(fptr,"\n %c%lf%c [%s]:		LOGLEVEL:%d  ",'[',time,']',source_id,log_level);	//Log into the file

typedef struct{
	double timestamp;
	int log_level;
	uint8_t  source_ID[20];
	double sensor_data;
}log_t;

typedef struct{
	bool log_temp_sensor_flag;
	bool log_light_sensor_flag;
}logger_flag_t;

/**************************************************************************************
*					GLOBAL VARIABLES
****************************************************************************************/

/**************************************************************************************
*					FUNCTION PROTOTYPE
***************************************************************************************/



#endif /* LOGGER_H_ */

/********************************************************************************************
*					FILENAME: main.h
**********************************************************************************************/
/* Title: main.h
 * Brief: Responsible for creating threads, joining them and initiating built in self test
 * Author: Tanmay Chaturvedi, Vikrant Waje
 * Date Created: March 16, 2019
 * Course: Advanced Embedded Software Development
 * Project: 1
 * 
 * 
 * */
/****************************************************************************************
*					HEADER FILE SECTION
*****************************************************************************************/
#ifndef SRC_MAIN_H_
#define SRC_MAIN_H_

#include "thread.h"
#include"timer.h"
#include"temp_sensor.h"
#include"light_sensor.h"
#include"logger.h"
#include"synchronization.h"
#include"server.h"
#include"ipc.h"
#include"led.h"
#include"bist.h"
#include"signal_handler.h"
#include"gpiointerrupt.h"
/**************************************************************************************
*					     MACROS
****************************************************************************************/

/**************************************************************************************
*					GLOBAL VARIABLES
****************************************************************************************/

/**************************************************************************************
*					FUNCTION PROTOTYPE
***************************************************************************************/



#endif /* SRC_MAIN_H_ */
#ifndef SRC_LIGHT_H_
#define SRC_LIGHT_H_

/********************************************************************************************
*					FILENAME: light_sensor.h
**********************************************************************************************/
/* Title Light sensor.h
 * Brief: Contains function that are used for communication with light sensor
 * Author: Tanmay Chaturvedi, Vikrant Waje
 * Date Created: March 16, 2019
 * Course: Advanced Embedded Software Development
 * Project: 1

 * Reference[1]: http://www.sparkfun.com/products/14350
 * 
 * 
 * */
/****************************************************************************************
*					HEADER FILE SECTION
*****************************************************************************************/

#include<stdio.h>
#include<unistd.h>
#include<fcntl.h>
#include<sys/ioctl.h>
#include<linux/i2c-dev.h>
#include<stdint.h>
#include<stdlib.h>
#include<math.h>
#include"i2c_status.h"
#include"logger.h"
#include"server.h"
#include"ipc.h"
/***************************************************************************************
*					MACROS AND ENUMS
****************************************************************************************/


typedef enum{
	INTEGRATION_TIME, GAIN, NONE
}read_cmd_t;

typedef enum{
	INITIAL,DARK,LIGHT
}last_state_t;
// typedef enum{
// 	INTERRUPT_ON, INTERRUPT_OFF
// }interrupt_cmd_t;

#define LIGHT_SENSOR_I2C_ADDRESS (0x39)
#define CONTROL_REG	 	(0x00)
#define TIMING_REG		(0x01)
#define THRESHLOWLOW_REG	(0x02)
#define THRESHLOWHIGH_REG	(0x03)
#define THRESHHIGHLOW_REG	(0x04)
#define THRESHHIGHHIGH_REG	(0x05)
#define INTERRUPT_REG		(0x06)
#define CRC			(0x08)
#define ID_REG			(0x0A)
#define DATA0LOW_REG		(0x0C)
#define DATA0HIGH_REG		(0x0D)
#define DATA1LOW_REG		(0x0E)
#define DATA1HIGH_REG		(0x0F)

#define IDENTIFICATION_MASK	(0x05)
#define INTEGRATION_MASK	(0x03)
#define GAIN_MASK		(0x01)

#define	INTEGRATION_13_7	((0x00))
#define INTEGRATION_101		((0x01))
#define INTEGRATION_402		((0x02))

#define LOW_GAIN			((0x00))
#define HIGH_GAIN			((0x01))

#define	INTERRUPT_OFF		((0x00))
#define	INTERRUPT_ON		((0x01))

#define COMMAND_BIT		(0x80)
#define WORD_OPERATION_BIT	(0x20)
#define READ_LIGHT_ERROR	(double)(-55.000000)
/***************************************************************************************
*				GLOBAL VARIABLE SECTION
****************************************************************************************/
/*************************************************************************************
*				FUNCTION PROTOTYPE
*****************************************************************************************/
/*********************************************************************************************** 
 * @brief write register in light sensor 
 *
 *Responsible for writing into  register of light sensor
 *
 * @param address: address of  register  of light sensor
 * @param data: data to be written into register of light sensor
 *
 * @return status of I2C operation
 *********************************************************************************************/
sensor_status_t light_write_reg(uint8_t address, uint8_t data);

/*********************************************************************************************** 
 * @brief Read register in light sensor 
 *
 *Responsible for reading from register of light sensor
 *
 * @param address: address of  register  of light sensor
 * @param data: data to be read from register of light sensor
 * @param command: Bits to be read from particular register from light sensor
 * @return status of I2C operation
 *********************************************************************************************/
sensor_status_t light_read_reg(uint8_t address, uint8_t *data,read_cmd_t command);

/*********************************************************************************************** 
 * @brief Read two register in light sensor 
 *
 *Responsible for reading from two  register of light sensor
 *
 * @param address: address of  register  of light sensor
 * @param data: data to be read from register of light sensor
 * @param command: Bits to be read from particular register from light sensor
 * @return status of I2C operation
 *********************************************************************************************/

sensor_status_t read_two_reg(uint8_t address, uint8_t *data);
/*********************************************************************************************** 
 * @brief Read lux values 
 *
 *Responsible for reading lux value from light sensor
 *
 * @param null
 * @return double: Returns the lux values from light sensor
 *********************************************************************************************/
double read_lux();

/***********************************************************************************************  
 * @brief Power on light sensor 
 *
 *Responsible for turning On light sensor before reading any data
 *
 * @param  null
 *
 * @return null
 *********************************************************************************************/

sensor_status_t light_sensor_power_on();



/***********************************************************************************************  
 * @brief Set Integration Time 
 *
 *Responsible for setting up integration time based on INTEGRATION values
 *
 * @param INTEGRATION
 *
 * @return status of I2C operation
 *********************************************************************************************/
sensor_status_t set_integration_time(uint8_t INTEGRATION);



/***********************************************************************************************  
 * @brief Get Integration Time 
 *
 *Responsible for retrieivng set integration 
 *
 * @param uint8_t *data
 *
 * @return status of I2C operation
 *********************************************************************************************/
sensor_status_t get_integration_time(uint8_t *data);

/***********************************************************************************************  
 * @brief Read identification register 
 *
 *Responsible for reading identification register 
 *
 * @param uint8_t data
 *
 * @return status of I2C operation
 *********************************************************************************************/
sensor_status_t read_identification_reg(uint8_t *data);

	
/***********************************************************************************************  
 * @brief Set gain 
 *
 * Responsible for setting gain values. Switches gain between low gain and high gain modes. 
 * Writing a 0 selects low gain (1x); writing a 1 selects high gain (16x). 
 *
 * @param gainlevel
 *
 * @return status of I2C operation
 *********************************************************************************************/
sensor_status_t set_gain( int gainlevel );

/***********************************************************************************************  
 * @brief Get gain 
 *
 *Responsible for retrieivng gain 
 *
 * @param uint8_t *data
 *
 * @return status of I2C operation
 *********************************************************************************************/
sensor_status_t get_gain(uint8_t *data);

/***********************************************************************************************  
 * @brief Configure Interrupt Controller Register
 *
 * Enables/Disables Interrupt through Interrupt Controller Register
 *
 * @param uint8_t command
 *
 * @return status of I2C operation
 *********************************************************************************************/
sensor_status_t config_interrupt_ctrl_reg( uint8_t command );

/***********************************************************************************************  
 * @brief Get value of Interrupt control Register 
 *
 *Responsible for retrieving value of Interrupt Control Register
 *
 * @param null
 *
 * @return status of I2C operation
 *********************************************************************************************/

// i think this function is not required
sensor_status_t get_interrupt_ctrl_reg(uint8_t *data);

/***********************************************************************************************  
 * @brief Get value of Interrupt control Register 
 *
 *Responsible for retrieving value of Interrupt Control Register
 *
 * @param null
 *
 * @return status of I2C operation
 *********************************************************************************************/

// i think this function is not required
sensor_status_t get_interrupt_ctrl_reg(uint8_t *data);


/***********************************************************************************************  
 * @brief Write low threshold
 *
 *Write to Registers THRESLOWLOW and THRESHLOWHHIGH provide the low byte and
 * high byte, respectively, of the lower interrupt threshold 
 *
* @param uint16_t *data
 *
 * @return status of I2C operation
 *********************************************************************************************/

sensor_status_t set_low_threshold(uint16_t data);



/***********************************************************************************************  
 * @brief Read low threshold
 *
 * Registers THRESHLOWLOW and THRESHLOWHIGH provide the low byte and
 * high byte, respectively, of the lower interrupt threshold
 *
 * @param uint16_t *data
 *
 * @return status of I2C operation
 *********************************************************************************************/
sensor_status_t get_low_threshold(uint16_t *data);

/***********************************************************************************************  
 * @brief Write high threshold
 *
 *Write to Registers THRESHIGHLOW and THRESHHIGHHIGH provide the low byte and
 * high byte, respectively, of the lower interrupt threshold 
 *
* @param uint16_t *data
 *
 * @return status of I2C operation
 *********************************************************************************************/

sensor_status_t set_high_threshold(uint16_t data);

/***********************************************************************************************  
 * @brief Read high threshold
 *
 * Registers THRESHIGHLOW and THRESHHIGHHIGH provide the low byte and
 * high byte, respectively, of the lower interrupt threshold
 *
 * @param uint16_t *data
 *
 * @return status of I2C operation
 *********************************************************************************************/
sensor_status_t get_high_threshold(uint16_t *data);



#endif	//SRC_LIGHT_H_
#ifndef SYNCHRONIZATION_H_
#define SYNCHRONIZATION_H_

/********************************************************************************************
*					FILENAME: synchronization.h
**********************************************************************************************/
/* Title: synchronization.h
* Brief: Responsible for providing various synchronization constructs
* Author: Tanmay Chaturvedi, Vikrant Waje
* Date Created: March 16, 2019
* Course: Advanced Embedded Software Development
* Project: 1
* 
* 
* */
/****************************************************************************************
*					HEADER FILE SECTION
*****************************************************************************************/
#include<pthread.h>
/***************************************************************************************
*					MACROS AND ENUMS
****************************************************************************************/


/**************************************************************************************
*				GLOBAL VARIABLES
****************************************************************************************/
extern pthread_mutex_t i2c_mutex;
extern pthread_mutex_t logger_queue_mutex;
extern pthread_mutex_t heartbeat_queue_mutex;
#endif //SYNCHRONIZATION_H
#ifndef SRC_CLIENT_H_
#define	SRC_CLIENT_H_
/********************************************************************************************
*					FILENAME: Client.h
**********************************************************************************************/
/*
 * Author: Tanmay Chaturvedi, Vikrant Waje
 * Date Created: March 16, 2019
 * Course: Advanced Embedded Software Development
 * Project: 1

 * Reference[1]: http://www.it.uom.gr/teaching/distrubutedSite/dsIdaLiu/labs/lab2_1/sockets.html
 * Reference[2]: Based on code from https://riptutorial.com/posix/example/16306/posix-timer-with-sigev-thread-notification
 * 
 * 
 * */
/****************************************************************************************
*					HEADER FILE SECTION
*****************************************************************************************/
#include <stdio.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <signal.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <mqueue.h>
#include <time.h>
#include <unistd.h>
#include <netinet/in.h>
#include <sys/time.h>
#include <netdb.h>
#include <arpa/inet.h>

/***************************************************************************************
*					MACROS AND ENUMS
****************************************************************************************/
#define	LOG_FILE_NAME	"socketlog.txt"


typedef struct{
	char sensor_string[40];
	double sensor_data; 
}client_data_t;

/****************************************************************************************
* 					GLOBAL VARIABLES
*****************************************************************************************/

int sig_flag = 0;
int socket_fd;


/****************************************************************************************
* 					FUNCTION PROTOTYPES
*****************************************************************************************/



#endif

/********************************************************************************************
*					FILENAME: unittest.h
**********************************************************************************************/
/* Title:thread.h
 * Brief: Responsible for performing unit testing using CUnit unit testing framework
 * Author: Tanmay Chaturvedi, Vikrant Waje
 * Date Created: March 26, 2019
 * Course: Advanced Embedded Software Development
 * Project: 1
 * 
 * 
 * */
/****************************************************************************************
*					HEADER FILE SECTION
*****************************************************************************************/
#ifndef SRC_UNITTEST_H_
#define SRC_UNITTEST_H_

#include <stdio.h>
#include <stdlib.h>
#include <CUnit/Basic.h>
#include <CUnit/Automated.h>
#include <CUnit/CUnit.h>
#include "main.h"
#include "ipc.h"
#include <mqueue.h>
#include "temp_sensor.h"

/**************************************************************************************
*					FUNCTION PROTOTYPE
***************************************************************************************/
int cunit_add_testsuite();
int cunit_pthread_test(void);
int cunit_ipc_test(void);
int cunit_temp_test(void);

void pthread_create_test(void);
void message_queue_open_test(void);
void message_queue_close_test(void);
void temp_conversion_test(void);


#endif#ifndef SRC_TEMP_H_
#define SRC_TEMP_H_
/********************************************************************************************
 *					FILENAME:temp_sensor.h
 **********************************************************************************************/
/* Title: temp_sensor.h
 * Brief: Responsible for providing various helper function needed to communicate with temperature sensor
 * Author: Tanmay Chaturvedi, Vikrant Waje
 * Date Created: March 16, 2019
 * Course: Advanced Embedded Software Development
 * Project: 1

 * Reference[1]: http://www.sparkfun.com/products/13314
 * 
 * 
 * */
/****************************************************************************************
 *					HEADER FILE SECTION
 *****************************************************************************************/
#include<stdio.h>
#include<unistd.h>
#include<fcntl.h>
#include<sys/ioctl.h>
#include<linux/i2c-dev.h>
#include<stdint.h>
#include<stdlib.h>
#include"i2c_status.h"
#include"logger.h"
#include"server.h"
#include"ipc.h"
/****************************************************************************************
 *					MACROS AND ENUMS
 *****************************************************************************************/
#define TEMP_SENSOR_I2C_ADDRESS (0x48)
#define TEMPERATURE_REG		(0x00)
#define CONFIGURATION_REG	 (0x01)
#define TLOW_REG		(0x02)
#define THIGH_REG		(0x03)

#define CONVERSION_RATE_0_25	((0x00))
#define CONVERSION_RATE_1	((0x01))
#define CONVERSION_RATE_4	((0x02))
#define CONVERSION_RATE_8	((0x03))
#define CONVERSION_RATE_MASK	(0x03)


#define SHUTDOWN_ON		((0x01))
#define SHUTDOWN_OFF		((0x00))

#define EM_ON			((0x01))
#define EM_OFF			((0x00))
#define EM_MASK			(0x01)


#define FAULT_1			((0x00)) 
#define FAULT_2			((0x01))
#define FAULT_3			((0x02))
#define FAULT_4			((0x03))
#define FAULT_MASK		(0x03)

#define RESOLUTION_MASK			(0x03)
#define SENSOR_RESOLUTION_12_BIT	(0x03)

typedef enum{
	REQUEST_CELSIUS, REQUEST_KELVIN, REQUEST_FAHRENHEIT
}request_cmd_t;


typedef enum{
	FAULT,EM,CONVERSION_RATE,SD_MODE,RESOLUTION,ALL
}reg_read_cmd_t;



/****************************************************************************************
 *				GLOBAL VARIABLE SECTION
 *****************************************************************************************/


/*************************************************************************************
 *				FUNCTION PROTOTYPE SECTION
 *****************************************************************************************/

/***********************************************************************************************  * @brief Get temperature
 *
 * Read the value from temperature register
 *
 * @param request: Temperature value in kelvin, celsius and farhenheit to be returned
 * @return double: Value of converted temperature
 *********************************************************************************************/
double get_temperature(request_cmd_t request, uint16_t raw_data);



#endif	//SRC_TEMP_H_
#ifndef I2C_STATUS_H_
#define I2C_STATUS_H_

/********************************************************************************************
*					FILENAME: i2c_status.h
**********************************************************************************************/
/*
 * Author: Tanmay Chaturvedi, Vikrant Waje
 * Date Created: March 16, 2019
 * Course: Advanced Embedded Software Development
 * Project: 1

 * Reference[1]: http://www.it.uom.gr/teaching/distrubutedSite/dsIdaLiu/labs/lab2_1/sockets.html
 * Reference[2]: Based on code from https://riptutorial.com/posix/example/16306/posix-timer-with-sigev-thread-notification
 * 
 * 
 * */
/****************************************************************************************
*					HEADER FILE SECTION
*****************************************************************************************/

#include<stdint.h>

/***************************************************************************************
*					MACROS AND ENUMS
****************************************************************************************/
typedef enum{
	WRITE_REG_SUCCESS = 1, READ_REG_SUCCESS =2, WRITE_REG_FAIL=-1, READ_REG_FAIL=-2

}sensor_status_t;


/**************************************************************************************
*				GLOBAL VARIABLES
****************************************************************************************/

#endif //I2C_STATUS_H
#ifndef TIMER_H_
#define TIMER_H_
/********************************************************************************************
*					FILENAME: timer.h
**********************************************************************************************/
/* Title: timer.c
 * Brief: Responsible for providing various helper function needed for logger and heartbeat
 * Author: Tanmay Chaturvedi, Vikrant Waje
 * Date Created: March 16, 2019
 * Course: Advanced Embedded Software Development
 * Project: 1

 * Reference[1]: Professor's slides and notes 
 * 
 * */
/****************************************************************************************
*					HEADER FILE SECTION
*****************************************************************************************/

#include <signal.h>
#include <time.h>
#include <stdio.h>
#include<stdbool.h>
#include"logger.h"
#include"heartbeat.h"
/****************************************************************************************
*				     MACROS AND ENUMS
*****************************************************************************************/
#define SEC_TO_MILLISEC		(1000.0)
#define NANOSEC_TO_MILLISEC	(1000000.0)

/****************************************************************************************
*				GLOBAL VARIABLE SECTION
*****************************************************************************************/
//Flag variables
extern int log_timer_flag;
extern int heartbeat_timer_flag;
// Logger timer id
timer_t log_timer_id;
//Heartbeat timer id
timer_t heartbeat_timer_id;
//timespec struct for giving interval values
struct itimerspec timer_setting;
struct sigevent signal_specification;
/***************************************************************************************
*				FUNCTION PROTOTYPE
*****************************************************************************************/
/***********************************************************************************************
 * @brief logger  timer handler
 *
 * Handler that executes periodically to generate logging interval
 * @param null
 *
 * @return null
 *********************************************************************************************/
void log_timer_handler(int num);
/***********************************************************************************************
 * @brief heartbeat timer handler
 *
 * Handler that executes periodically to generate heartbeat interval
 * @param null
 *
 * @return null
 *********************************************************************************************/
void heartbeat_timer_handler(int num);
/***********************************************************************************************
 * @brief Create log timer
 *
 * Responsible for creating log timer which expires periodically to collect sensor information an
 * nd socket status that is logged into log file
 * @param null
 *
 * @return bool: Indicates whether intiialisation was successfull or not
 *********************************************************************************************/
bool create_log_timer();

/***********************************************************************************************
 * @brief Create heartbeat timer
 *
 * Responsible for generating heartbeat for each of the four thread
 * @param null
 *
 * @return bool: Indicates whether intiialisation was successfull or not
 *********************************************************************************************/
bool create_heartbeat_timer();
/***********************************************************************************************
 * @brief Record the timestamp value
 *
 * Record the timestamp value using clock_get_time function
 * @param null
 *
 * @return double: timestamp value
 *********************************************************************************************/
double record_time();

#endif //TIMER_H_
#ifndef SRC_IPC_H_
#define	SRC_IPC_H_
/********************************************************************************************
*					FILENAME: ipc.h
**********************************************************************************************/
/* Title: ipc.h
 * Brief: Responsible for implementing various helper function that helps in setting up interthread communication 
 * Author: Tanmay Chaturvedi, Vikrant Waje
 * Date Created: March 16, 2019
 * Course: Advanced Embedded Software Development
 * Project: 1
 *
 * 
 * 
 * */
/****************************************************************************************
*					HEADER FILE SECTION
***************************************************************************/

#include<stdint.h>
#include<sys/types.h>
#include<unistd.h>
#include<stdlib.h>
#include<mqueue.h>
#include<signal.h>
#include<string.h>
#include<stdio.h>
#include"logger.h"
#include"heartbeat.h"

/***************************************************************************************
*					MACROS AND ENUMS
***************************************************************************/

typedef struct{
	char sensor_string[40];
	double sensor_data;

}client_data_t;


typedef enum{

	MQ_SUCCESS, MQ_FAIL	
}ipc_return_t;

/*******************************************************************************************
*					GLOBAL VARIABLES
*******************************************************************************************/
extern mqd_t mqdes_server;

/*******************************************************************************************
*					FUNCTION DEFINITION
*******************************************************************************************/

ipc_return_t open_message_queue_server(mqd_t *mqdes, struct mq_attr * attribute);
ipc_return_t close_message_queue_server(mqd_t *mqdes);

#endif //SRC_IPC_H
/********************************************************************************************
*					FILENAME: heartbeat.h
**********************************************************************************************/
/* Title: heartbeat.h
 * Brief: Responsible for providing various helper function to support heartbeat functionality
 * Author: Tanmay Chaturvedi, Vikrant Waje
 * Date Created: March 16, 2019
 * Course: Advanced Embedded Software Development
 * Project: 1

 * Reference[1]: http://www.
 * 
 * */
/****************************************************************************************
*					HEADER FILE SECTION
*****************************************************************************************/
#ifndef HEARTBEAT_H_
#define HEARTBEAT_H_

#include<stdio.h>
#include<stdint.h>
#include<stdbool.h>
/**************************************************************************************
*					     MACROS
****************************************************************************************/


typedef struct{
	double timestamp;
	int log_level;
	uint8_t  source_ID[20];
	double sensor_data;
	bool error_flag;
}heartbeat_data_t;

typedef struct{
	bool heartbeat_temp_sensor_flag;
	bool heartbeat_light_sensor_flag;
}heartbeat_flag_t;

/**************************************************************************************
*					GLOBAL VARIABLES
****************************************************************************************/

/**************************************************************************************
*					FUNCTION PROTOTYPE
***************************************************************************************/

#endif /* HEARTBEAT_H_ */

/********************************************************************************************
*					FILENAME: thread.h
**********************************************************************************************/
/* Title:thread.h
 * Brief: Responsible for providing callback function for the four threads created in main function
 * Author: Tanmay Chaturvedi, Vikrant Waje
 * Date Created: March 16, 2019
 * Course: Advanced Embedded Software Development
 * Project: 1
 * 
 * 
 * */
/****************************************************************************************
*					HEADER FILE SECTION
*****************************************************************************************/
#ifndef THREAD_H_
#define THREAD_H_

#include <pthread.h>

/**************************************************************************************
*					     MACROS
****************************************************************************************/

/**************************************************************************************
*					GLOBAL VARIABLES
****************************************************************************************/
extern pthread_t thread1, thread2, thread3, thread4;
/**************************************************************************************
*					FUNCTION PROTOTYPE
***************************************************************************************/

/*******************************************************************************************
 * @brief Socket thread
 *
 * Waits for a connection initiated by an external client.
 * Once connected, accepts commands from client and acts accordingly.
 * If clients commands the connection to "close", server thread disconnects,
 * closes the socket connection and waits for a new connection.
 *
 * @param null
 *
 * @return null
 ********************************************************************************************/
void *socket_thread( void*);


/***********************************************************************************************
 * @brief Temperature thread
 *
 * Get the temperature value periodically from temperature sensor and logs 
 * into file opened by logger thread
 *
 * @param null
 *
 * @return null
 *********************************************************************************************/

void *temperature_thread( void*);



/***********************************************************************************************
 * @brief light sensor thread
 *
 * Get the LUX values from light sensor attached using I2C interface and report it periodically t * o logger thread
 *
 * @param null
 *
 * @return null
 *********************************************************************************************/

void *light_sensor_thread( void*);



/***********************************************************************************************
 * @brief logger thread
 *
 * Log the values of temperature, light sensor and socket status in log file created by logger task 
 * into file opened by logger thread
 *
 * @param null
 *
 * @return null
 *********************************************************************************************/

 void *logger_thread( void*);





#endif /* THREAD_H_ */

#ifndef SRC_SERVER_H_
#define	SRC_SERVER_H_
/********************************************************************************************
*					FILENAME: server.h
**********************************************************************************************/
/* Title: server.h
 * Brief: Responsible for providing various helper functions for setting up the server side
 * Author: Tanmay Chaturvedi, Vikrant Waje
 * Date Created: March 10, 2019
 * Course: Advanced Embedded Software Development
 * 
 * This program demonsrates IPC using Sockets for Project 1.
 * This is the Server Side.
 * Reference[1]: http://www.it.uom.gr/teaching/distrubutedSite/dsIdaLiu/labs/lab2_1/sockets.html
 * Reference[2]: https://www.youtube.com/watch?v=pFLQmnmDOo
 */

/****************************************************************************************
*					HEADER FILE SECTION
*****************************************************************************************/
#include <stdio.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <signal.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <mqueue.h>
#include <time.h>
#include <unistd.h>
#include <netinet/in.h>
#include <sys/time.h>
#include <netdb.h>
#include<stdbool.h>
#include"temp_sensor.h"
#include"ipc.h"
#include"led.h"
/***************************************************************************************
*					MACROS AND ENUMS
****************************************************************************************/
#define	PORT_NUM	(7000)
#define	LOG_FILE_NAME	"socketlog.txt"
#define NO_OF_CLIENT	(5)

typedef enum{
	SOCKET_FAIL,REUSE_FAIL,BIND_FAIL,LISTEN_FAIL,ACCEPT_FAIL,SOCKET_CONNECT_SUCCESS,SOCKET_SETUP_SUCCESS
}server_response_t;




/****************************************************************************************
* 					GLOBAL VARIABLES
*****************************************************************************************/
char *RxBuf[10] ;
int socket_fd;
int check_stat;
int sig_flag ;
int sock_stat;
struct sockaddr_in server_addr;

typedef struct{
 bool client_get_temp_flag;
 bool client_get_lux_flag;
 bool client_get_system_stat_flag;
}client_request_t;

/****************************************************************************************
* 					FUNCTION PROTOTYPES
*****************************************************************************************/
/*******************************************************************************************
 * @brief Socket Listening Routines
 *
 * Call the listen() and accept() and returns 1 on successful connection
 * with an external client
 
 * @param null
 *
 * @return 0 if error, 1 if success
 ********************************************************************************************/
server_response_t socket_connect(void);


/*******************************************************************************************
 * @brief Socket Setup Routines
 *
 * Call the socket(), bind() and returns 1 on successful setup
 
 * @param null
 *
 * @return 0 if error, 1 if success
 ********************************************************************************************/
server_response_t socket_setup(void);


/*******************************************************************************************
 * @brief Communicate with external client
 *
 * After connecting with external client, receives command from client and call respective
 * function.

 * @param null
 *
 * @return 0 if error, 1 if success
 ********************************************************************************************/
int server_establish(void);

#endif //SRC_SERVER_H_
/********************************************************************************************
*					FILENAME: bist.h
**********************************************************************************************/
/* Title: bist.h
 * Brief: Responsible for providing helper function for built in self test
 * Author: Tanmay Chaturvedi, Vikrant Waje
 * Date Created: March 16, 2019
 * Course: Advanced Embedded Software Development
 * Project: 1

 * Reference[1]: http://www.
 * 
 * 
 * */
/****************************************************************************************
*					HEADER FILE SECTION
*****************************************************************************************/
#ifndef BIST_H_
#define BIST_H_

#include "temp_sensor.h"
#include "light_sensor.h"
#include "logger.h"
#include "ipc.h"
#include"i2c_status.h"
#include"thread.h"
#include<pthread.h>
/**************************************************************************************
*					     MACROS
****************************************************************************************/
#define TLOW_VAL 	(50.0)
#define THIGH_VAL	(100.0)
#define THRESHOLD_HIGH	(100)
#define THRESHOLD_LOW	(60)					

/**************************************************************************************
*					FUNCTION PROTOTYPE
***************************************************************************************/
void built_in_self_test();

#endif 
	/********************************************************************************************
*					FILENAME: led.h
**********************************************************************************************/
/* Title: led.h
 * Brief: Responsible for providing various helper function needed for initializing and blinking the led
 * Author: Tanmay Chaturvedi, Vikrant Waje
 * Date Created: March 16, 2019
 * Course: Advanced Embedded Software Development
 * Project: 1

 * Reference[1]: http://www.teachmemicro.com/beaglebone-black-blink-led-using-c/#
 * 
 * 
 * */
/****************************************************************************************
*					HEADER FILE SECTION
*****************************************************************************************/
#ifndef LED_H_
#define LED_H_

#include <stdio.h>
#include<string.h>
#include<stdint.h>
/**************************************************************************************
*					     MACROS
****************************************************************************************/
#define RED_LED  ("49")
#define BLUE_LED ("117")
#define GREEN_LED ("115")
#define YELLOW_LED ("44")
/**************************************************************************************
*					GLOBAL VARIABLES
****************************************************************************************/

/**************************************************************************************
*					FUNCTION PROTOTYPE
***************************************************************************************/


/*******************************************************************************************
 * @brief Initialise LED gpio pins
 *
 * Initialise GPIO pins as output
 *
 * @param gpio_pin: GPIO pin whose direction is to be set
 *
 * @return null
 ********************************************************************************************/

void led_init(uint8_t gpio_pin[]);


/*******************************************************************************************
 * @brief Turn ON the led
 *
 * Turn the given LED ON, i.e output logic 1
 *
 * @param gpio_pin: GPIO pin which is to be turned ON
 *
 * @return null
 ********************************************************************************************/

void led_on(uint8_t gpio_pin[]);


/*******************************************************************************************
 * @brief Turn OFF the led
 *
 * Turn the given LED OFF, i.e output logic 0
 *
 * @param gpio_pin: GPIO pin which is to be turned OFF
 *
 * @return null
 ********************************************************************************************/
void led_off(uint8_t gpio_pin[]);

#endif /*LED_H*/	
/********************************************************************************************
*					FILENAME: logger.h
**********************************************************************************************/
/* Title: logger.h
 * Brief: Responsible for providing various helper function to support logger functionality
 * Author: Tanmay Chaturvedi, Vikrant Waje
 * Date Created: March 16, 2019
 * Course: Advanced Embedded Software Development
 * Project: 1

 * Reference[1]: http://www.
 * 
 * */
/****************************************************************************************
*					HEADER FILE SECTION
*****************************************************************************************/
#ifndef LOGGER_H_
#define LOGGER_H_

#include<stdio.h>
#include<stdint.h>
#include<stdbool.h>
/**************************************************************************************
*					     MACROS
****************************************************************************************/



#define LOG(fptr,time,log_level,source_id,sensor_value) fprintf(fptr,"\n %c%lf%c [%s]: loglevel:%d sensor value: %lf ",'[',time,']',source_id,log_level,sensor_value);	//Log into the file


typedef struct{
	double timestamp;
	int log_level;
	uint8_t  source_ID[20];
	double sensor_data;
}log_t;

typedef struct{
	bool log_temp_sensor_flag;
	bool log_light_sensor_flag;
}logger_flag_t;

/**************************************************************************************
*					GLOBAL VARIABLES
****************************************************************************************/

/**************************************************************************************
*					FUNCTION PROTOTYPE
***************************************************************************************/



#endif /* LOGGER_H_ */

/********************************************************************************************
*					FILENAME: main.h
**********************************************************************************************/
/* Title: main.h
 * Brief: Responsible for creating threads, joining them and initiating built in self test
 * Author: Tanmay Chaturvedi, Vikrant Waje
 * Date Created: March 16, 2019
 * Course: Advanced Embedded Software Development
 * Project: 1
 * 
 * 
 * */
/****************************************************************************************
*					HEADER FILE SECTION
*****************************************************************************************/
#ifndef SRC_MAIN_H_
#define SRC_MAIN_H_

#include "thread.h"
#include"timer.h"
#include"temp_sensor.h"
#include"light_sensor.h"
#include"logger.h"
#include"synchronization.h"
#include"server.h"
#include"ipc.h"
#include"led.h"
#include"bist.h"
/**************************************************************************************
*					     MACROS
****************************************************************************************/

/**************************************************************************************
*					GLOBAL VARIABLES
****************************************************************************************/


/**************************************************************************************
*					ENUM FOR ERRORS
***************************************************************************************/
typedef enum{

	PTHREAD_SUCCESS, PTHREAD_FAIL	
}return_type_t;

/**************************************************************************************
*					FUNCTION PROTOTYPE
***************************************************************************************/
return_type_t main_func();



#endif /* SRC_MAIN_H_ */
#ifndef SRC_LIGHT_H_
#define SRC_LIGHT_H_

/********************************************************************************************
*					FILENAME: light_sensor.h
**********************************************************************************************/
/* Title Light sensor.h
 * Brief: Contains function that are used for communication with light sensor
 * Author: Tanmay Chaturvedi, Vikrant Waje
 * Date Created: March 16, 2019
 * Course: Advanced Embedded Software Development
 * Project: 1

 * Reference[1]: http://www.sparkfun.com/products/14350
 * 
 * 
 * */
/****************************************************************************************
*					HEADER FILE SECTION
*****************************************************************************************/

#include<stdio.h>
#include<unistd.h>
#include<fcntl.h>
#include<sys/ioctl.h>
#include<linux/i2c-dev.h>
#include<stdint.h>
#include<stdlib.h>
#include<math.h>
#include"i2c_status.h"
#include"logger.h"
#include"server.h"
#include"ipc.h"
/***************************************************************************************
*					MACROS AND ENUMS
****************************************************************************************/


typedef enum{
	INTEGRATION_TIME, GAIN, NONE
}read_cmd_t;

typedef enum{
	DARK,LIGHT
}last_state_t;
// typedef enum{
// 	INTERRUPT_ON, INTERRUPT_OFF
// }interrupt_cmd_t;

#define LIGHT_SENSOR_I2C_ADDRESS (0x39)
#define CONTROL_REG	 	(0x00)
#define TIMING_REG		(0x01)
#define THRESHLOWLOW_REG	(0x02)
#define THRESHLOWHIGH_REG	(0x03)
#define THRESHHIGHLOW_REG	(0x04)
#define THRESHHIGHHIGH_REG	(0x05)
#define INTERRUPT_REG		(0x06)
#define CRC			(0x08)
#define ID_REG			(0x0A)
#define DATA0LOW_REG		(0x0C)
#define DATA0HIGH_REG		(0x0D)
#define DATA1LOW_REG		(0x0E)
#define DATA1HIGH_REG		(0x0F)

#define IDENTIFICATION_MASK	(0x05)
#define INTEGRATION_MASK	(0x03)
#define GAIN_MASK		(0x01)

#define	INTEGRATION_13_7	((0x00))
#define INTEGRATION_101		((0x01))
#define INTEGRATION_402		((0x02))

#define LOW_GAIN			((0x00))
#define HIGH_GAIN			((0x01))

#define	INTERRUPT_OFF		((0x00))
#define	INTERRUPT_ON		((0x01))

#define COMMAND_BIT		(0x80)
#define WORD_OPERATION_BIT	(0x20)

/***************************************************************************************
*				GLOBAL VARIABLE SECTION
****************************************************************************************/
/*************************************************************************************
*				FUNCTION PROTOTYPE
*****************************************************************************************/
/*********************************************************************************************** 
 * @brief write register in light sensor 
 *
 *Responsible for writing into  register of light sensor
 *
 * @param address: address of  register  of light sensor
 * @param data: data to be written into register of light sensor
 *
 * @return status of I2C operation
 *********************************************************************************************/
sensor_status_t light_write_reg(uint8_t address, uint8_t data);

/*********************************************************************************************** 
 * @brief Read register in light sensor 
 *
 *Responsible for reading from register of light sensor
 *
 * @param address: address of  register  of light sensor
 * @param data: data to be read from register of light sensor
 * @param command: Bits to be read from particular register from light sensor
 * @return status of I2C operation
 *********************************************************************************************/
sensor_status_t light_read_reg(uint8_t address, uint8_t *data,read_cmd_t command);

/*********************************************************************************************** 
 * @brief Read two register in light sensor 
 *
 *Responsible for reading from two  register of light sensor
 *
 * @param address: address of  register  of light sensor
 * @param data: data to be read from register of light sensor
 * @param command: Bits to be read from particular register from light sensor
 * @return status of I2C operation
 *********************************************************************************************/

sensor_status_t read_two_reg(uint8_t address, uint8_t *data);
/*********************************************************************************************** 
 * @brief Read lux values 
 *
 *Responsible for reading lux value from light sensor
 *
 * @param null
 * @return double: Returns the lux values from light sensor
 *********************************************************************************************/
double read_lux();

/***********************************************************************************************  
 * @brief Power on light sensor 
 *
 *Responsible for turning On light sensor before reading any data
 *
 * @param  null
 *
 * @return null
 *********************************************************************************************/

sensor_status_t light_sensor_power_on();



/***********************************************************************************************  
 * @brief Set Integration Time 
 *
 *Responsible for setting up integration time based on INTEGRATION values
 *
 * @param INTEGRATION
 *
 * @return status of I2C operation
 *********************************************************************************************/
sensor_status_t set_integration_time(uint8_t INTEGRATION);



/***********************************************************************************************  
 * @brief Get Integration Time 
 *
 *Responsible for retrieivng set integration 
 *
 * @param uint8_t *data
 *
 * @return status of I2C operation
 *********************************************************************************************/
sensor_status_t get_integration_time(uint8_t *data);

/***********************************************************************************************  
 * @brief Read identification register 
 *
 *Responsible for reading identification register 
 *
 * @param uint8_t data
 *
 * @return status of I2C operation
 *********************************************************************************************/
sensor_status_t read_identification_reg(uint8_t *data);

	
/***********************************************************************************************  
 * @brief Set gain 
 *
 * Responsible for setting gain values. Switches gain between low gain and high gain modes. 
 * Writing a 0 selects low gain (1x); writing a 1 selects high gain (16x). 
 *
 * @param gainlevel
 *
 * @return status of I2C operation
 *********************************************************************************************/
sensor_status_t set_gain( int gainlevel );

/***********************************************************************************************  
 * @brief Get gain 
 *
 *Responsible for retrieivng gain 
 *
 * @param uint8_t *data
 *
 * @return status of I2C operation
 *********************************************************************************************/
sensor_status_t get_gain(uint8_t *data);

/***********************************************************************************************  
 * @brief Configure Interrupt Controller Register
 *
 * Enables/Disables Interrupt through Interrupt Controller Register
 *
 * @param uint8_t command
 *
 * @return status of I2C operation
 *********************************************************************************************/
sensor_status_t config_interrupt_ctrl_reg( uint8_t command );

/***********************************************************************************************  
 * @brief Get value of Interrupt control Register 
 *
 *Responsible for retrieving value of Interrupt Control Register
 *
 * @param null
 *
 * @return status of I2C operation
 *********************************************************************************************/

// i think this function is not required
sensor_status_t get_interrupt_ctrl_reg(uint8_t *data);

/***********************************************************************************************  
 * @brief Get value of Interrupt control Register 
 *
 *Responsible for retrieving value of Interrupt Control Register
 *
 * @param null
 *
 * @return status of I2C operation
 *********************************************************************************************/

// i think this function is not required
sensor_status_t get_interrupt_ctrl_reg(uint8_t *data);


/***********************************************************************************************  
 * @brief Write low threshold
 *
 *Write to Registers THRESLOWLOW and THRESHLOWHHIGH provide the low byte and
 * high byte, respectively, of the lower interrupt threshold 
 *
* @param uint16_t *data
 *
 * @return status of I2C operation
 *********************************************************************************************/

sensor_status_t set_low_threshold(uint16_t data);



/***********************************************************************************************  
 * @brief Read low threshold
 *
 * Registers THRESHLOWLOW and THRESHLOWHIGH provide the low byte and
 * high byte, respectively, of the lower interrupt threshold
 *
 * @param uint16_t *data
 *
 * @return status of I2C operation
 *********************************************************************************************/
sensor_status_t get_low_threshold(uint16_t *data);

/***********************************************************************************************  
 * @brief Write high threshold
 *
 *Write to Registers THRESHIGHLOW and THRESHHIGHHIGH provide the low byte and
 * high byte, respectively, of the lower interrupt threshold 
 *
* @param uint16_t *data
 *
 * @return status of I2C operation
 *********************************************************************************************/

sensor_status_t set_high_threshold(uint16_t data);

/***********************************************************************************************  
 * @brief Read high threshold
 *
 * Registers THRESHIGHLOW and THRESHHIGHHIGH provide the low byte and
 * high byte, respectively, of the lower interrupt threshold
 *
 * @param uint16_t *data
 *
 * @return status of I2C operation
 *********************************************************************************************/
sensor_status_t get_high_threshold(uint16_t *data);



#endif	//SRC_LIGHT_H_
#ifndef SYNCHRONIZATION_H_
#define SYNCHRONIZATION_H_

/********************************************************************************************
*					FILENAME: synchronization.h
**********************************************************************************************/
/* Title: synchronization.h
* Brief: Responsible for providing various synchronization constructs
* Author: Tanmay Chaturvedi, Vikrant Waje
* Date Created: March 16, 2019
* Course: Advanced Embedded Software Development
* Project: 1
* 
* 
* */
/****************************************************************************************
*					HEADER FILE SECTION
*****************************************************************************************/
#include<pthread.h>
/***************************************************************************************
*					MACROS AND ENUMS
****************************************************************************************/


/**************************************************************************************
*				GLOBAL VARIABLES
****************************************************************************************/
extern pthread_mutex_t i2c_mutex;
extern pthread_mutex_t logger_queue_mutex;
extern pthread_mutex_t heartbeat_queue_mutex;
#endif //SYNCHRONIZATION_H
#ifndef SRC_GPIO_H_
#define SRC_GPIO_H_
/********************************************************************************************
 *					FILENAME: gpiointerrupt.h
 **********************************************************************************************/
/* Title: temp_sensor.h
 * Brief: Responsible for providing various helper function needed to communicate with temperature sensor
 * Author: Tanmay Chaturvedi, Vikrant Waje
 * Date Created: March 26, 2019
 * Course: Advanced Embedded Software Development
 * Project: 1

 * Reference[1]: 
 * 
 * 
 * */
/****************************************************************************************
 *					HEADER FILE SECTION
 *****************************************************************************************/
#include <poll.h>
#include <fcntl.h>
#include<stdio.h>
#include<sys/types.h>
#include<sys/stat.h>
#include<unistd.h>
/****************************************************************************************
 *					GLOBAL VARIABLES
 *****************************************************************************************/
extern int file_gpio;
extern char val[4];
struct pollfd filedes[1];
/****************************************************************************************
 *					MACRO
 *****************************************************************************************/
#define	NUM_FD	(1)
#define	TIMEOUT_MSECS	(3)



/****************************************************************************************
 *					FUNCTION PROTOTYPE 
 *****************************************************************************************/
/***********************************************************************************************
 * @brief IRQ handler
 *
 * Handler that returns state of GPIO pin 
 * @param null
 *
 * @return char
 *********************************************************************************************/
char IRQ_handler(void);


/***********************************************************************************************
 * @brief GPIO initilisation function
 *
 * Initialises GPIO pin
 * @param null
 *
 * @return int: error status
 *********************************************************************************************/
int GPIO_init(void);
#endif
#ifndef SRC_TEMP_H_
#define SRC_TEMP_H_
/********************************************************************************************
 *					FILENAME:temp_sensor.h
 **********************************************************************************************/
/* Title: temp_sensor.h
 * Brief: Responsible for providing various helper function needed to communicate with temperature sensor
 * Author: Tanmay Chaturvedi, Vikrant Waje
 * Date Created: March 16, 2019
 * Course: Advanced Embedded Software Development
 * Project: 1

 * Reference[1]: http://www.sparkfun.com/products/13314
 * 
 * 
 * */
/****************************************************************************************
 *					HEADER FILE SECTION
 *****************************************************************************************/
#include<stdio.h>
#include<unistd.h>
#include<fcntl.h>
#include<sys/ioctl.h>
#include<linux/i2c-dev.h>
#include<stdint.h>
#include<stdlib.h>
#include"i2c_status.h"
#include"logger.h"
#include"server.h"
#include"ipc.h"
/****************************************************************************************
 *					MACROS AND ENUMS
 *****************************************************************************************/
#define TEMP_SENSOR_I2C_ADDRESS (0x48)
#define TEMPERATURE_REG		(0x00)
#define CONFIGURATION_REG	 (0x01)
#define TLOW_REG		(0x02)
#define THIGH_REG		(0x03)

#define CONVERSION_RATE_0_25	((0x00))
#define CONVERSION_RATE_1	((0x01))
#define CONVERSION_RATE_4	((0x02))
#define CONVERSION_RATE_8	((0x03))
#define CONVERSION_RATE_MASK	(0x03)


#define SHUTDOWN_ON		((0x01))
#define SHUTDOWN_OFF		((0x00))

#define EM_ON			((0x01))
#define EM_OFF			((0x00))
#define EM_MASK			(0x01)


#define FAULT_1			((0x00)) 
#define FAULT_2			((0x01))
#define FAULT_3			((0x02))
#define FAULT_4			((0x03))
#define FAULT_MASK		(0x03)

#define RESOLUTION_MASK			(0x03)
#define SENSOR_RESOLUTION_12_BIT	(0x03)


#define READ_TEMPERATURE_ERROR	(double)(-56.000000)

typedef enum{
	REQUEST_CELSIUS, REQUEST_KELVIN, REQUEST_FAHRENHEIT
}request_cmd_t;


typedef enum{
	FAULT,EM,CONVERSION_RATE,SD_MODE,RESOLUTION,ALL
}reg_read_cmd_t;



/****************************************************************************************
 *				GLOBAL VARIABLE SECTION
 *****************************************************************************************/


/*************************************************************************************
 *				FUNCTION PROTOTYPE SECTION
 *****************************************************************************************/
/***********************************************************************************************
 * @brief write pointer register
 *
 *Responsible for writing into pointer registerof temperature sensor TMP102
 *
 * @param address: address of pointer register TMP102
 *
 * @return status of I2C operation
 *********************************************************************************************/


sensor_status_t write_ptr_reg(uint8_t address);

/***********************************************************************************************  * @brief write register in temperature register
 *
 *Responsible for writing into  register of temperature sensor TMP102
 *
 * @param address: address of  register  of TMP102
 * @param data: data to be written into register of TMP102
 *
 * @return status of I2C operation
 *********************************************************************************************/

sensor_status_t temperature_write_reg(uint8_t address, uint16_t data);

/***********************************************************************************************  * @brief Read register in temperature register
 *
 *Responsible for reading from  register of temperature sensor TMP102
 *
 * @param address: address of  register  of TMP102
 * @param data: data to be read from  register of TMP102
 * @param command: register bits which are to be read
 * @return status of I2C operation
 *********************************************************************************************/


sensor_status_t temperature_read_reg(uint8_t address, uint8_t *data,reg_read_cmd_t command);
/***********************************************************************************************  * @brief Get temperature
 *
 * Read the value from temperature register
 *
 * @param request: Temperature value in kelvin, celsius and farhenheit to be returned
 * @return double: Value of converted temperature
 *********************************************************************************************/


double get_temperature(request_cmd_t request);


/*********************************************************************************************** 
 * @brief Write tlow
 *
 * Write the value of tlow 
 *
 * @param :null
 * @return sensor_stat_t: Status of I2C operation
 *********************************************************************************************/
sensor_status_t write_tlow(float temperature);

/***********************************************************************************************  
 * @brief Get Tlow register
 *
 * Read the value from tlow register
 *
 * @param request: Temperature value in kelvin, celsius and farhenheit to be returned
 * @return double: Value of converted temperature
 *********************************************************************************************/


double get_Tlow(request_cmd_t request);

/*********************************************************************************************** 
 * @brief Write thigh
 *
 * Write the value of thigh 
 *
 * @param :null
 * @return sensor_stat_t: Status of I2C operation
 *********************************************************************************************/
sensor_status_t write_thigh(float temperature);


/***********************************************************************************************  
 * @brief Get Thigh register
 *
 * Read the value from thigh register
 *
 * @param request: Temperature value in kelvin, celsius and farhenheit to be returned
 * @return double: Value of converted temperature
 *********************************************************************************************/


double get_Thigh(request_cmd_t request);


/*********************************************************************************************** 
 * @brief set sensor in shutdown mode
 *
 * set the configuration register in shutdown mode
 *
 * @param :null
 * @return :status of I2C operation
 *********************************************************************************************/

sensor_status_t configure_temp_shutdown(void);


/*********************************************************************************************** 
 * @brief Write fault bits
 *
 * Write the fault bits in configuration register 
 *
 * @param :null
 * @return sensor_stat_t: Status of I2C operation
 *********************************************************************************************/
sensor_status_t configure_temp_fault(uint8_t mode);

/*********************************************************************************************** 
 * @brief Read fault bits from configuration register
 *
 *  Read fault bits
 *
 * @param :uint8_t* data
 * @return :status of I2C operation
 *********************************************************************************************/


sensor_status_t read_temp_fault(uint8_t *data);


/*********************************************************************************************** 
 * @brief set sensor in EM mode
 *
 * set the configuration register in EM mode
 *
 * @param :mode
 * @return :status of I2C operation
 *********************************************************************************************/

sensor_status_t configure_temp_EMmode(uint8_t mode);


/*********************************************************************************************** 
 * @brief Read EM mode from configuration register
 *
 *  Read Em mode bits
 *
 * @param :uint8_t *data
 * @return :status of I2C operation
 *********************************************************************************************/


sensor_status_t read_temp_EM(uint8_t *data);


/*********************************************************************************************** 
 * @brief set sensor conversion rate
 *
 * set the conversion rate of temperature sensor
 *
 * @param :data: To Set the conversion rate
 * @return :status of I2C operation
 *********************************************************************************************/


sensor_status_t configure_temp_conversion_rate(uint8_t rate);


/*********************************************************************************************** 
 * @brief Read conversion rate from configuration register
 *
 *  Read Conversion rate
 *
 * @param :uint8_t *data
 * @return :status of I2C operations
 *********************************************************************************************/

sensor_status_t read_temp_conversion_rate(uint8_t *data);

/*********************************************************************************************** 
 * @brief Read sensor resolution from configuration register
 *
 *  Read sensor resolution
 *
 * @param :uint8_t *data
 * @return :status of I2C operations
 *********************************************************************************************/

sensor_status_t read_temp_sensor_resolution(uint8_t *data);



#endif	//SRC_TEMP_H_
#ifndef I2C_STATUS_H_
#define I2C_STATUS_H_

/********************************************************************************************
*					FILENAME: i2c_status.h
**********************************************************************************************/
/*
 * Author: Tanmay Chaturvedi, Vikrant Waje
 * Date Created: March 16, 2019
 * Course: Advanced Embedded Software Development
 * Project: 1

 * Reference[1]: http://www.it.uom.gr/teaching/distrubutedSite/dsIdaLiu/labs/lab2_1/sockets.html
 * Reference[2]: Based on code from https://riptutorial.com/posix/example/16306/posix-timer-with-sigev-thread-notification
 * 
 * 
 * */
/****************************************************************************************
*					HEADER FILE SECTION
*****************************************************************************************/

#include<stdint.h>

/***************************************************************************************
*					MACROS AND ENUMS
****************************************************************************************/
typedef enum{
	WRITE_REG_SUCCESS = 1, READ_REG_SUCCESS =2, WRITE_REG_FAIL=-1, READ_REG_FAIL=-2

}sensor_status_t;


/**************************************************************************************
*				GLOBAL VARIABLES
****************************************************************************************/

#endif //I2C_STATUS_H
#ifndef SIGNAL_HANDLER_H_
#define SIGNAL_HANDLER_H_
/********************************************************************************************
*					FILENAME: signal_handler.h
**********************************************************************************************/
/* Title: signal_handler.h
 * Brief: Responsible for providing various synchronization constructs
 * Author: Tanmay Chaturvedi, Vikrant Waje
 * Date Created: March 16, 2019
 * Course: Advanced Embedded Software Development
 * Project: 1
 * 
 * 
 * */
/****************************************************************************************
*					HEADER FILE SECTION
*****************************************************************************************/

#include<stdio.h>
#include<signal.h>
#include<stdbool.h> 
#include<stdint.h>

/**************************************************************************************
*					    GLOBAL VARIABLES
****************************************************************************************/
struct sigaction user_defined;
extern bool system_shutdown_flag;
extern bool system_shutdown_main_flag;
/**************************************************************************************
*					FUNCTION DEFINITION
***************************************************************************************/
/***********************************************************************************************
 * @brief system shutdown handler
 *
 * Handler invoked when user presses CTRL + C
 * @param num: Checks type of signal
 *
 * @return null
 *********************************************************************************************/
void system_shutdown_handler(int num);
/***********************************************************************************************
* @brief Initialise system shutdown handler
*
* Initialising parameter for system shutdown handler
* @param null
*
* @return null
*********************************************************************************************/

void signal_handler_init();

#endif
#ifndef TIMER_H_
#define TIMER_H_
/********************************************************************************************
*					FILENAME: timer.h
**********************************************************************************************/
/* Title: timer.c
 * Brief: Responsible for providing various helper function needed for logger and heartbeat
 * Author: Tanmay Chaturvedi, Vikrant Waje
 * Date Created: March 16, 2019
 * Course: Advanced Embedded Software Development
 * Project: 1

 * Reference[1]: Professor's slides and notes 
 * 
 * */
/****************************************************************************************
*					HEADER FILE SECTION
*****************************************************************************************/

#include <signal.h>
#include <time.h>
#include <stdio.h>
#include<stdbool.h>
#include"logger.h"
#include"heartbeat.h"
#include"signal_handler.h"
/****************************************************************************************
*				     MACROS AND ENUMS
*****************************************************************************************/
#define SEC_TO_MILLISEC		(1000.0)
#define NANOSEC_TO_MILLISEC	(1000000.0)

/****************************************************************************************
*				GLOBAL VARIABLE SECTION
*****************************************************************************************/
//Flag variables
extern int log_timer_flag;
extern int heartbeat_timer_flag;
// Logger timer id
timer_t log_timer_id;
//Heartbeat timer id
timer_t heartbeat_timer_id;
timer_t heartbeat_recovery_timer_id;
//timespec struct for giving interval values
struct itimerspec timer_setting;
struct sigevent signal_specification;

extern bool logger_heartbeat_indicator;
extern bool light_heartbeat_indicator ;
extern bool temp_heartbeat_indicator ;
/***************************************************************************************
*				FUNCTION PROTOTYPE
*****************************************************************************************/
/***********************************************************************************************
 * @brief logger  timer handler
 *
 * Handler that executes periodically to generate logging interval
 * @param null
 *
 * @return null
 *********************************************************************************************/
void log_timer_handler(int num);
/***********************************************************************************************
 * @brief heartbeat timer handler
 *
 * Handler that executes periodically to generate heartbeat interval
 * @param null
 *
 * @return null
 *********************************************************************************************/
void heartbeat_timer_handler(int num);
/***********************************************************************************************
 * @brief Create log timer
 *
 * Responsible for creating log timer which expires periodically to collect sensor information an
 * nd socket status that is logged into log file
 * @param null
 *
 * @return bool: Indicates whether intiialisation was successfull or not
 *********************************************************************************************/
bool create_log_timer();

/***********************************************************************************************
 * @brief Create heartbeat timer
 *
 * Responsible for generating heartbeat for each of the four thread
 * @param null
 *
 * @return bool: Indicates whether intiialisation was successfull or not
 *********************************************************************************************/
bool create_heartbeat_timer();
/***********************************************************************************************
 * @brief Record the timestamp value
 *
 * Record the timestamp value using clock_get_time function
 * @param null
 *
 * @return double: timestamp value
 *********************************************************************************************/
double record_time();
/***********************************************************************************************
 * @brief heartbeat recovery timer handler
 *
 * Handler that executes to check for heartbeat recovery
 * @param num
 *
 * @return null
 *********************************************************************************************/
void heartbeat_recovery_timer_handler(int num);
	

//	printf("\n\rHi heartbeat");

/***********************************************************************************************
 * @brief Create heartbeat recovery timer
 *
 * Responsible for recovery of system
 * @param null
 *
 * @return bool: Indicates whether intiialisation was successfull or not
 *********************************************************************************************/
bool create_heartbeat_recovery_timer();

#endif //TIMER_H_
#ifndef SRC_IPC_H_
#define	SRC_IPC_H_
/********************************************************************************************
*					FILENAME: ipc.h
**********************************************************************************************/
/* Title: ipc.h
 * Brief: Responsible for implementing various helper function that helps in setting up interthread communication 
 * Author: Tanmay Chaturvedi, Vikrant Waje
 * Date Created: March 16, 2019
 * Course: Advanced Embedded Software Development
 * Project: 1
 *
 * 
 * 
 * */
/****************************************************************************************
*					HEADER FILE SECTION
***************************************************************************/

#include<stdint.h>
#include<sys/types.h>
#include<unistd.h>
#include<stdlib.h>
#include<mqueue.h>
#include<signal.h>
#include<string.h>
#include<stdio.h>
#include"logger.h"
#include"heartbeat.h"
#include"synchronization.h"
/***************************************************************************************
*					MACROS AND ENUMS
***************************************************************************/

typedef struct{
	char sensor_string[40];
	double sensor_data;

}client_data_t;

/*******************************************************************************************
*					GLOBAL VARIABLES
*******************************************************************************************/
extern mqd_t mqdes_server;
extern mqd_t mqdes_logger;
extern mqd_t mqdes_heartbeat;
/*******************************************************************************************
*					FUNCTION DEFINITION
*******************************************************************************************/

void open_message_queue_server(mqd_t *mqdes, struct mq_attr * attribute);
void close_message_queue_server(mqd_t *mqdes);
void open_message_queue_logger(mqd_t *mqdes, struct mq_attr * attribute);
void close_message_queue_logger(mqd_t *mqdes);
void open_message_queue_heartbeat(mqd_t *mqdes, struct mq_attr * attribute);
void close_message_queue_heartbeat(mqd_t *mqdes);

#endif //SRC_IPC_H
/********************************************************************************************
*					FILENAME: heartbeat.h
**********************************************************************************************/
/* Title: heartbeat.h
 * Brief: Responsible for providing various helper function to support heartbeat functionality
 * Author: Tanmay Chaturvedi, Vikrant Waje
 * Date Created: March 16, 2019
 * Course: Advanced Embedded Software Development
 * Project: 1

 * Reference[1]: http://www.
 * 
 * */
/****************************************************************************************
*					HEADER FILE SECTION
*****************************************************************************************/
#ifndef HEARTBEAT_H_
#define HEARTBEAT_H_

#include<stdio.h>
#include<stdint.h>
#include<stdbool.h>
#include"ipc.h"
/**************************************************************************************
*					     MACROS
****************************************************************************************/


typedef struct{
	double timestamp;
	int log_level;
	uint8_t  source_ID[20];
	double sensor_data;
	bool error_flag;
}heartbeat_data_t;

typedef struct{
	bool heartbeat_temp_sensor_flag;
	bool heartbeat_light_sensor_flag;
	bool heartbeat_logger_flag;
	bool heartbeat_server_flag;
}heartbeat_flag_t;

/**************************************************************************************
*					GLOBAL VARIABLES
****************************************************************************************/
extern mqd_t mqdes_heartbeat;
/**************************************************************************************
*					FUNCTION PROTOTYPE
***************************************************************************************/

#endif /* HEARTBEAT_H_ */

/********************************************************************************************
*					FILENAME: thread.h
**********************************************************************************************/
/* Title:thread.h
 * Brief: Responsible for providing callback function for the four threads created in main function
 * Author: Tanmay Chaturvedi, Vikrant Waje
 * Date Created: March 16, 2019
 * Course: Advanced Embedded Software Development
 * Project: 1
 * 
 * 
 * */
/****************************************************************************************
*					HEADER FILE SECTION
*****************************************************************************************/
#ifndef THREAD_H_
#define THREAD_H_

#include <pthread.h>

/**************************************************************************************
*					     MACROS
****************************************************************************************/

/**************************************************************************************
*					GLOBAL VARIABLES
****************************************************************************************/
extern pthread_t thread1, thread2, thread3, thread4;
/**************************************************************************************
*					FUNCTION PROTOTYPE
***************************************************************************************/

/*******************************************************************************************
 * @brief Socket thread
 *
 * Waits for a connection initiated by an external client.
 * Once connected, accepts commands from client and acts accordingly.
 * If clients commands the connection to "close", server thread disconnects,
 * closes the socket connection and waits for a new connection.
 *
 * @param null
 *
 * @return null
 ********************************************************************************************/
void *socket_thread( void*);


/***********************************************************************************************
 * @brief Temperature thread
 *
 * Get the temperature value periodically from temperature sensor and logs 
 * into file opened by logger thread
 *
 * @param null
 *
 * @return null
 *********************************************************************************************/

void *temperature_thread( void*);



/***********************************************************************************************
 * @brief light sensor thread
 *
 * Get the LUX values from light sensor attached using I2C interface and report it periodically t * o logger thread
 *
 * @param null
 *
 * @return null
 *********************************************************************************************/

void *light_sensor_thread( void*);



/***********************************************************************************************
 * @brief logger thread
 *
 * Log the values of temperature, light sensor and socket status in log file created by logger task 
 * into file opened by logger thread
 *
 * @param null
 *
 * @return null
 *********************************************************************************************/

 void *logger_thread( void*);





#endif /* THREAD_H_ */

#ifndef SRC_SERVER_H_
#define	SRC_SERVER_H_
/********************************************************************************************
*					FILENAME: server.h
**********************************************************************************************/
/* Title: server.h
 * Brief: Responsible for providing various helper functions for setting up the server side
 * Author: Tanmay Chaturvedi, Vikrant Waje
 * Date Created: March 10, 2019
 * Course: Advanced Embedded Software Development
 * 
 * This program demonsrates IPC using Sockets for Project 1.
 * This is the Server Side.
 * Reference[1]: http://www.it.uom.gr/teaching/distrubutedSite/dsIdaLiu/labs/lab2_1/sockets.html
 * Reference[2]: https://www.youtube.com/watch?v=pFLQmnmDOo
 */

/****************************************************************************************
*					HEADER FILE SECTION
*****************************************************************************************/
#include <stdio.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <signal.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <mqueue.h>
#include <time.h>
#include <unistd.h>
#include <netinet/in.h>
#include <sys/time.h>
#include <netdb.h>
#include<stdbool.h>
#include"temp_sensor.h"
#include"ipc.h"
#include"led.h"
#include"heartbeat.h"
#include"logger.h"
#include"timer.h"
#include<pthread.h>
/***************************************************************************************
*					MACROS AND ENUMS
****************************************************************************************/
#define	PORT_NUM	(7000)
#define	LOG_FILE_NAME	"socketlog.txt"
#define NO_OF_CLIENT	(5)

typedef enum{
	SOCKET_FAIL,REUSE_FAIL,BIND_FAIL,LISTEN_FAIL,ACCEPT_FAIL,SOCKET_CONNECT_SUCCESS,SOCKET_SETUP_SUCCESS
}server_response_t;




/****************************************************************************************
* 					GLOBAL VARIABLES
*****************************************************************************************/
char *RxBuf[10] ;
extern int socket_fd;
int check_stat;
int sig_flag ;
extern int sock_stat;
struct sockaddr_in server_addr;

typedef struct{
 bool client_get_temp_flag;
 bool client_get_lux_flag;
 bool client_get_system_stat_flag;
}client_request_t;

/****************************************************************************************
* 					FUNCTION PROTOTYPES
*****************************************************************************************/
/*******************************************************************************************
 * @brief Socket Listening Routines
 *
 * Call the listen() and accept() and returns 1 on successful connection
 * with an external client
 
 * @param null
 *
 * @return 0 if error, 1 if success
 ********************************************************************************************/
server_response_t socket_connect(void);


/*******************************************************************************************
 * @brief Socket Setup Routines
 *
 * Call the socket(), bind() and returns 1 on successful setup
 
 * @param null
 *
 * @return 0 if error, 1 if success
 ********************************************************************************************/
server_response_t socket_setup(void);


/*******************************************************************************************
 * @brief Communicate with external client
 *
 * After connecting with external client, receives command from client and call respective
 * function.

 * @param null
 *
 * @return 0 if error, 1 if success
 ********************************************************************************************/
int server_establish(void);

#endif //SRC_SERVER_H_
/********************************************************************************************
*					FILENAME: bist.h
**********************************************************************************************/
/* Title: bist.h
 * Brief: Responsible for providing helper function for built in self test
 * Author: Tanmay Chaturvedi, Vikrant Waje
 * Date Created: March 16, 2019
 * Course: Advanced Embedded Software Development
 * Project: 1

 * Reference[1]: http://www.
 * 
 * 
 * */
/****************************************************************************************
*					HEADER FILE SECTION
*****************************************************************************************/
#ifndef BIST_H_
#define BIST_H_

#include "temp_sensor.h"
#include "light_sensor.h"
#include "logger.h"
#include "ipc.h"
#include"i2c_status.h"
#include"timer.h"
#include"thread.h"
#include"synchronization.h"
#include<pthread.h>
/**************************************************************************************
*					     MACROS
****************************************************************************************/
#define TLOW_VAL 	(26.0)		// For temperature Alert
#define THIGH_VAL	(27.0)	
#define THRESHOLD_HIGH	(100)	// For light Interrupt Threshold Register
#define THRESHOLD_LOW	(60)					

/**************************************************************************************
*					FUNCTION PROTOTYPE
***************************************************************************************/
void built_in_self_test(char *argv);

#endif 
/********************************************************************************************
*					FILENAME: led.h
**********************************************************************************************/
/* Title: led.h
 * Brief: Responsible for providing various helper function needed for initializing and blinking the led
 * Author: Tanmay Chaturvedi, Vikrant Waje
 * Date Created: March 16, 2019
 * Course: Advanced Embedded Software Development
 * Project: 1

 * Reference[1]: http://www.teachmemicro.com/beaglebone-black-blink-led-using-c/#
 * 
 * 
 * */
/****************************************************************************************
*					HEADER FILE SECTION
*****************************************************************************************/
#ifndef LED_H_
#define LED_H_

#include <stdio.h>
#include<string.h>
#include<stdint.h>
/**************************************************************************************
*					     MACROS
****************************************************************************************/
#define RED_LED  ("49")
#define BLUE_LED ("117")
#define GREEN_LED ("115")
#define YELLOW_LED ("44")
/**************************************************************************************
*					GLOBAL VARIABLES
****************************************************************************************/

/**************************************************************************************
*					FUNCTION PROTOTYPE
***************************************************************************************/


/*******************************************************************************************
 * @brief Initialise LED gpio pins
 *
 * Initialise GPIO pins as output
 *
 * @param gpio_pin: GPIO pin whose direction is to be set
 *
 * @return null
 ********************************************************************************************/

void led_init(uint8_t gpio_pin[]);


/*******************************************************************************************
 * @brief Turn ON the led
 *
 * Turn the given LED ON, i.e output logic 1
 *
 * @param gpio_pin: GPIO pin which is to be turned ON
 *
 * @return null
 ********************************************************************************************/

void led_on(uint8_t gpio_pin[]);


/*******************************************************************************************
 * @brief Turn OFF the led
 *
 * Turn the given LED OFF, i.e output logic 0
 *
 * @param gpio_pin: GPIO pin which is to be turned OFF
 *
 * @return null
 ********************************************************************************************/
void led_off(uint8_t gpio_pin[]);

#endif /*LED_H*/	
/********************************************************************************************
*					FILENAME: logger.h
**********************************************************************************************/
/* Title: logger.h
 * Brief: Responsible for providing various helper function to support logger functionality
 * Author: Tanmay Chaturvedi, Vikrant Waje
 * Date Created: March 16, 2019
 * Course: Advanced Embedded Software Development
 * Project: 1

 * Reference[1]: http://www.
 * 
 * */
/****************************************************************************************
*					HEADER FILE SECTION
*****************************************************************************************/
#ifndef LOGGER_H_
#define LOGGER_H_

#include<stdio.h>
#include<stdint.h>
#include<stdbool.h>
/**************************************************************************************
*					     MACROS
****************************************************************************************/



#define LOG(fptr,time,log_level,source_id,sensor_value) fprintf(fptr,"\n %c%lf%c [%s]:		LOGLEVEL:%d SENSOR VALUE: %lf ",'[',time,']',source_id,log_level,sensor_value);	//Log into the file
#define LOG_GENERAL(fptr,time,log_level,source_id) fprintf(fptr,"\n %c%lf%c [%s]:		LOGLEVEL:%d  ",'[',time,']',source_id,log_level);	//Log into the file

typedef struct{
	double timestamp;
	int log_level;
	uint8_t  source_ID[20];
	double sensor_data;
}log_t;

typedef struct{
	bool log_temp_sensor_flag;
	bool log_light_sensor_flag;
}logger_flag_t;

/**************************************************************************************
*					GLOBAL VARIABLES
****************************************************************************************/

/**************************************************************************************
*					FUNCTION PROTOTYPE
***************************************************************************************/



#endif /* LOGGER_H_ */

/********************************************************************************************
*					FILENAME: main.h
**********************************************************************************************/
/* Title: main.h
 * Brief: Responsible for creating threads, joining them and initiating built in self test
 * Author: Tanmay Chaturvedi, Vikrant Waje
 * Date Created: March 16, 2019
 * Course: Advanced Embedded Software Development
 * Project: 1
 * 
 * 
 * */
/****************************************************************************************
*					HEADER FILE SECTION
*****************************************************************************************/
#ifndef SRC_MAIN_H_
#define SRC_MAIN_H_

#include "thread.h"
#include"timer.h"
#include"temp_sensor.h"
#include"light_sensor.h"
#include"logger.h"
#include"synchronization.h"
#include"server.h"
#include"ipc.h"
#include"led.h"
#include"bist.h"
#include"signal_handler.h"
#include"gpiointerrupt.h"
/**************************************************************************************
*					     MACROS
****************************************************************************************/

/**************************************************************************************
*					GLOBAL VARIABLES
****************************************************************************************/

/**************************************************************************************
*					FUNCTION PROTOTYPE
***************************************************************************************/



#endif /* SRC_MAIN_H_ */
#ifndef SRC_LIGHT_H_
#define SRC_LIGHT_H_

/********************************************************************************************
*					FILENAME: light_sensor.h
**********************************************************************************************/
/* Title Light sensor.h
 * Brief: Contains function that are used for communication with light sensor
 * Author: Tanmay Chaturvedi, Vikrant Waje
 * Date Created: March 16, 2019
 * Course: Advanced Embedded Software Development
 * Project: 1

 * Reference[1]: http://www.sparkfun.com/products/14350
 * 
 * 
 * */
/****************************************************************************************
*					HEADER FILE SECTION
*****************************************************************************************/

#include<stdio.h>
#include<unistd.h>
#include<fcntl.h>
#include<sys/ioctl.h>
#include<linux/i2c-dev.h>
#include<stdint.h>
#include<stdlib.h>
#include<math.h>
#include"i2c_status.h"
#include"logger.h"
#include"server.h"
#include"ipc.h"
/***************************************************************************************
*					MACROS AND ENUMS
****************************************************************************************/


typedef enum{
	INTEGRATION_TIME, GAIN, NONE
}read_cmd_t;

typedef enum{
	INITIAL,DARK,LIGHT
}last_state_t;
// typedef enum{
// 	INTERRUPT_ON, INTERRUPT_OFF
// }interrupt_cmd_t;

#define LIGHT_SENSOR_I2C_ADDRESS (0x39)
#define CONTROL_REG	 	(0x00)
#define TIMING_REG		(0x01)
#define THRESHLOWLOW_REG	(0x02)
#define THRESHLOWHIGH_REG	(0x03)
#define THRESHHIGHLOW_REG	(0x04)
#define THRESHHIGHHIGH_REG	(0x05)
#define INTERRUPT_REG		(0x06)
#define CRC			(0x08)
#define ID_REG			(0x0A)
#define DATA0LOW_REG		(0x0C)
#define DATA0HIGH_REG		(0x0D)
#define DATA1LOW_REG		(0x0E)
#define DATA1HIGH_REG		(0x0F)

#define IDENTIFICATION_MASK	(0x05)
#define INTEGRATION_MASK	(0x03)
#define GAIN_MASK		(0x01)

#define	INTEGRATION_13_7	((0x00))
#define INTEGRATION_101		((0x01))
#define INTEGRATION_402		((0x02))

#define LOW_GAIN			((0x00))
#define HIGH_GAIN			((0x01))

#define	INTERRUPT_OFF		((0x00))
#define	INTERRUPT_ON		((0x01))

#define COMMAND_BIT		(0x80)
#define WORD_OPERATION_BIT	(0x20)
#define READ_LIGHT_ERROR	(double)(-55.000000)
/***************************************************************************************
*				GLOBAL VARIABLE SECTION
****************************************************************************************/
/*************************************************************************************
*				FUNCTION PROTOTYPE
*****************************************************************************************/
/*********************************************************************************************** 
 * @brief write register in light sensor 
 *
 *Responsible for writing into  register of light sensor
 *
 * @param address: address of  register  of light sensor
 * @param data: data to be written into register of light sensor
 *
 * @return status of I2C operation
 *********************************************************************************************/
sensor_status_t light_write_reg(uint8_t address, uint8_t data);

/*********************************************************************************************** 
 * @brief Read register in light sensor 
 *
 *Responsible for reading from register of light sensor
 *
 * @param address: address of  register  of light sensor
 * @param data: data to be read from register of light sensor
 * @param command: Bits to be read from particular register from light sensor
 * @return status of I2C operation
 *********************************************************************************************/
sensor_status_t light_read_reg(uint8_t address, uint8_t *data,read_cmd_t command);

/*********************************************************************************************** 
 * @brief Read two register in light sensor 
 *
 *Responsible for reading from two  register of light sensor
 *
 * @param address: address of  register  of light sensor
 * @param data: data to be read from register of light sensor
 * @param command: Bits to be read from particular register from light sensor
 * @return status of I2C operation
 *********************************************************************************************/

sensor_status_t read_two_reg(uint8_t address, uint8_t *data);
/*********************************************************************************************** 
 * @brief Read lux values 
 *
 *Responsible for reading lux value from light sensor
 *
 * @param null
 * @return double: Returns the lux values from light sensor
 *********************************************************************************************/
double read_lux();

/***********************************************************************************************  
 * @brief Power on light sensor 
 *
 *Responsible for turning On light sensor before reading any data
 *
 * @param  null
 *
 * @return null
 *********************************************************************************************/

sensor_status_t light_sensor_power_on();



/***********************************************************************************************  
 * @brief Set Integration Time 
 *
 *Responsible for setting up integration time based on INTEGRATION values
 *
 * @param INTEGRATION
 *
 * @return status of I2C operation
 *********************************************************************************************/
sensor_status_t set_integration_time(uint8_t INTEGRATION);



/***********************************************************************************************  
 * @brief Get Integration Time 
 *
 *Responsible for retrieivng set integration 
 *
 * @param uint8_t *data
 *
 * @return status of I2C operation
 *********************************************************************************************/
sensor_status_t get_integration_time(uint8_t *data);

/***********************************************************************************************  
 * @brief Read identification register 
 *
 *Responsible for reading identification register 
 *
 * @param uint8_t data
 *
 * @return status of I2C operation
 *********************************************************************************************/
sensor_status_t read_identification_reg(uint8_t *data);

	
/***********************************************************************************************  
 * @brief Set gain 
 *
 * Responsible for setting gain values. Switches gain between low gain and high gain modes. 
 * Writing a 0 selects low gain (1x); writing a 1 selects high gain (16x). 
 *
 * @param gainlevel
 *
 * @return status of I2C operation
 *********************************************************************************************/
sensor_status_t set_gain( int gainlevel );

/***********************************************************************************************  
 * @brief Get gain 
 *
 *Responsible for retrieivng gain 
 *
 * @param uint8_t *data
 *
 * @return status of I2C operation
 *********************************************************************************************/
sensor_status_t get_gain(uint8_t *data);

/***********************************************************************************************  
 * @brief Configure Interrupt Controller Register
 *
 * Enables/Disables Interrupt through Interrupt Controller Register
 *
 * @param uint8_t command
 *
 * @return status of I2C operation
 *********************************************************************************************/
sensor_status_t config_interrupt_ctrl_reg( uint8_t command );

/***********************************************************************************************  
 * @brief Get value of Interrupt control Register 
 *
 *Responsible for retrieving value of Interrupt Control Register
 *
 * @param null
 *
 * @return status of I2C operation
 *********************************************************************************************/

// i think this function is not required
sensor_status_t get_interrupt_ctrl_reg(uint8_t *data);

/***********************************************************************************************  
 * @brief Get value of Interrupt control Register 
 *
 *Responsible for retrieving value of Interrupt Control Register
 *
 * @param null
 *
 * @return status of I2C operation
 *********************************************************************************************/

// i think this function is not required
sensor_status_t get_interrupt_ctrl_reg(uint8_t *data);


/***********************************************************************************************  
 * @brief Write low threshold
 *
 *Write to Registers THRESLOWLOW and THRESHLOWHHIGH provide the low byte and
 * high byte, respectively, of the lower interrupt threshold 
 *
* @param uint16_t *data
 *
 * @return status of I2C operation
 *********************************************************************************************/

sensor_status_t set_low_threshold(uint16_t data);



/***********************************************************************************************  
 * @brief Read low threshold
 *
 * Registers THRESHLOWLOW and THRESHLOWHIGH provide the low byte and
 * high byte, respectively, of the lower interrupt threshold
 *
 * @param uint16_t *data
 *
 * @return status of I2C operation
 *********************************************************************************************/
sensor_status_t get_low_threshold(uint16_t *data);

/***********************************************************************************************  
 * @brief Write high threshold
 *
 *Write to Registers THRESHIGHLOW and THRESHHIGHHIGH provide the low byte and
 * high byte, respectively, of the lower interrupt threshold 
 *
* @param uint16_t *data
 *
 * @return status of I2C operation
 *********************************************************************************************/

sensor_status_t set_high_threshold(uint16_t data);

/***********************************************************************************************  
 * @brief Read high threshold
 *
 * Registers THRESHIGHLOW and THRESHHIGHHIGH provide the low byte and
 * high byte, respectively, of the lower interrupt threshold
 *
 * @param uint16_t *data
 *
 * @return status of I2C operation
 *********************************************************************************************/
sensor_status_t get_high_threshold(uint16_t *data);



#endif	//SRC_LIGHT_H_
#ifndef SYNCHRONIZATION_H_
#define SYNCHRONIZATION_H_

/********************************************************************************************
*					FILENAME: synchronization.h
**********************************************************************************************/
/* Title: synchronization.h
* Brief: Responsible for providing various synchronization constructs
* Author: Tanmay Chaturvedi, Vikrant Waje
* Date Created: March 16, 2019
* Course: Advanced Embedded Software Development
* Project: 1
* 
* 
* */
/****************************************************************************************
*					HEADER FILE SECTION
*****************************************************************************************/
#include<pthread.h>
/***************************************************************************************
*					MACROS AND ENUMS
****************************************************************************************/


/**************************************************************************************
*				GLOBAL VARIABLES
****************************************************************************************/
extern pthread_mutex_t i2c_mutex;
extern pthread_mutex_t logger_queue_mutex;
extern pthread_mutex_t heartbeat_queue_mutex;
#endif //SYNCHRONIZATION_H
/*
 * Author: Tanmay Chaturvedi, Vikrant Waje
 * Date Created: March 10, 2019
 * Course: Advanced Embedded Software Development
 * 
 * This program demonsrates IPC using Sockets for Project 1.
 * This is the Client Side.
 * Reference[1]: http://www.it.uom.gr/teaching/distrubutedSite/dsIdaLiu/labs/lab2_1/sockets.html
 * Reference[2]: https://www.youtube.com/watch?v=pFLQmnmDOo
 */


#include"Client.h"

client_data_t client_data;


int main()
{
	//	set_sig_handler();
	struct sockaddr_in server_addr;
	int send_data_len =0;
	char input_cmd[20];

	printf("Setting up the connection..............\n");

	socket_fd = socket(AF_INET, SOCK_STREAM, 0);

	if(socket_fd < 0)
	{
		perror("socket()");
		exit(1);
	}

	printf("creating socket .........................\n");

	server_addr.sin_family = AF_INET;
	server_addr.sin_port = htons(7000);
	//server_addr.sin_addr.s_addr = inet_addr("128.138.189.197");
	server_addr.sin_addr.s_addr = inet_addr("192.168.0.2");	
	//server_addr.sin_addr.s_addr = inet_addr("127.0.0.1");

	printf("Socket created successfull\n");
	/*If connection establishment failed, close socket*/
	if((connect(socket_fd,(struct sockaddr *)&server_addr, sizeof(server_addr))) < 0)
	{
		perror("Socket connect()");
		close(socket_fd);
		exit(1);
	}



	while(1){
		printf("\n\r********************************************************************************\
				\n\r*				BUFF CLIENT					   \
				\n\r***********************************************************************************\n\r");

		printf("\nEnter any of the following commands: \n");
		printf("\"[1] Request temperature sensor values in Celsius\n");
		printf("\"[2] Request temperature sensor values in Kelvin \n");
		printf("\"[3] Request temperature sensor values in Fahrenheit\n");
		printf("\"[4] Request light sensor values \n");
		printf("\"[5] Turn all LED ON \n");
		printf("\"[6] Turn all LED OFF \n");
		printf("\"[7] Close connection \n\n");

	
		printf("\n\rEnter command here: ");

		scanf("\n%s", input_cmd);  //Blocking statement
		send_data_len = send(socket_fd, &input_cmd, 17, 0);
		printf("Command being sent = %s\n",input_cmd);
		if(strcmp(input_cmd,"7") ==0 ){
			close(socket_fd);
			printf("\n\rClosing socket");
			break;
		}
		if( (strcmp(input_cmd,"1")==0 || strcmp(input_cmd,"2")==0  || strcmp(input_cmd,"3")==0  || strcmp(input_cmd,"4")==0)){
		if(recv(socket_fd,&client_data,sizeof(client_data_t), 0)<0){
			perror("Error in receiving structure for sensor. Try again!!");
		}

		else{
			
			printf("\n\r********************************************************************************\
				\n\r*				SERVER RESPONSE					   \
				\n\r***********************************************************************************\n\r");

			


			printf("%s %lf\n\n\n\n\n\n\n\n\r",client_data.sensor_string,client_data.sensor_data);
		}
}




	}
	return 0;

}






/********************************************************************************************
*					FILENAME: light_sensor.c
**********************************************************************************************/
/* Title Light sensor.c
 * Brief: Contains function that are used for communication with light sensor
 * Author: Tanmay Chaturvedi, Vikrant Waje
 * Date Created: March 16, 2019
 * Course: Advanced Embedded Software Development
 * Project: 1
 * Reference[1]: http://www.sparkfun.com/products/14350
 * 
 * 
 * */
/****************************************************************************************
*					HEADER FILE SECTION
*****************************************************************************************/
#include "light_sensor.h"
#include"synchronization.h"

/***************************************************************************************
*					GLOBAL VARIABLE
****************************************************************************************/
const char *light_i2c_path_name = "/dev/i2c-2";
pthread_mutex_t i2c_mutex;

/***************************************************************************************
*				FUNCTION DEFINITION
***********************************************************************************************/

/***********************************************************************************************  
 * @brief write register in light sensor 
 *
 *Responsible for writing into  register of light sensor
 *
 * @param address: address of  register  of light sensor
 * @param data: data to be written into register of light sensor
 *
 * @return status of I2C operation
 *********************************************************************************************/


sensor_status_t light_write_reg(uint8_t address, uint8_t data){
	int status =0;
	int fptr = 0;
	int n = 0;
	uint8_t *buffer = malloc(sizeof(uint8_t) *5);
	*(buffer + 0) = (address | COMMAND_BIT);
	*(buffer + 1) = ((data));

	fptr = open(light_i2c_path_name,O_RDWR);	
	if(fptr == -1){
		perror("Error in opening the file");
		return WRITE_REG_FAIL;
	}
	status = ioctl(fptr,I2C_SLAVE,LIGHT_SENSOR_I2C_ADDRESS);
	if(status !=0){
		perror("IOCTL function failed");
		return WRITE_REG_FAIL;
	}
	n = write(fptr,buffer,2);
	if(n ==-1){
		perror("Write not successfull");
		return WRITE_REG_FAIL;
	}
	close(fptr);
	free(buffer);
	return WRITE_REG_SUCCESS;
}
/***********************************************************************************************  
 * @brief write two register in light sensor 
 *
 *Responsible for writing into two register of light sensor
 *
 * @param address: address of  register  of light sensor
 * @param data: data to be written into register of light sensor
 *
 * @return status of I2C operation
 *********************************************************************************************/


sensor_status_t light_write_two_reg(uint8_t address, uint16_t data){
	int status =0;
	int fptr = 0;
	int n = 0;
	uint8_t *buffer = malloc(sizeof(uint8_t) *5);
	*(buffer + 0) = (address | COMMAND_BIT | WORD_OPERATION_BIT);
	*(buffer + 1) = ((uint8_t)(data) );
	*(buffer + 2) = ((uint8_t)(data >>8));
	fptr = open(light_i2c_path_name,O_RDWR);	
	if(fptr == -1){
		perror("Error in opening the file");
		return WRITE_REG_FAIL;
	}
	status = ioctl(fptr,I2C_SLAVE,LIGHT_SENSOR_I2C_ADDRESS);
	if(status !=0){
		perror("IOCTL function failed");
		return WRITE_REG_FAIL;
	}
	n = write(fptr,buffer,3);
	if(n ==-1){
		perror("Write not successfull");
		return WRITE_REG_FAIL;
	}
	close(fptr);
	free(buffer);
	return WRITE_REG_SUCCESS;
}

/***********************************************************************************************  
 * @brief Read register in light sensor 
 *
 *Responsible for reading from register of light sensor
 *
 * @param address: address of  register  of light sensor
 * @param data: data to be read from register of light sensor
 * @param command: Bits to be read from particular register from light sensor
 * @return status of I2C operation
 *********************************************************************************************/


sensor_status_t light_read_reg(uint8_t address, uint8_t *data,read_cmd_t command){
	int status =0;
	int fptr = 0;
	int n = 0;
	address = address | COMMAND_BIT;
	fptr = open(light_i2c_path_name,O_RDWR);	
	if(fptr == -1){
		perror("Error in opening the file");
		return WRITE_REG_FAIL;
	}
	status = ioctl(fptr,I2C_SLAVE,LIGHT_SENSOR_I2C_ADDRESS);
	if(status !=0){
		perror("IOCTL function failed");
		return WRITE_REG_FAIL;
	}
	n =write(fptr,&address,1);
	if(n==-1){
		perror("Write not successfull");
		return WRITE_REG_FAIL;
	}

	n = read(fptr,(data ),1);
	if(n ==-1){
		perror("Read not successfull");
		return READ_REG_FAIL;
	}

	if(command == INTEGRATION_TIME){
		*data = *data & 0x03;
	}
	else if(command == GAIN){
		*data = (*data & 0x10) >> 4;
	}
	else{
		*data = *data;
	}

	close(fptr);
	return READ_REG_SUCCESS;

}
/***********************************************************************************************
 * @brief Read two register in light sensor 
 *
 *Responsible for reading from two  register of light sensor
 *
 * @param address: address of  register  of light sensor
 * @param data: data to be read from register of light sensor
 * @param command: Bits to be read from particular register from light sensor
 * @return status of I2C operation
 *********************************************************************************************/


sensor_status_t read_two_reg(uint8_t address, uint8_t *data){
	int status =0;
	int fptr = 0;
	int n =0;
	address = address | COMMAND_BIT | WORD_OPERATION_BIT;
	fptr = open(light_i2c_path_name,O_RDWR);
	if(fptr ==-1){
		perror("Error in opening the file");
		return WRITE_REG_FAIL;
	}
	status = ioctl(fptr,I2C_SLAVE,LIGHT_SENSOR_I2C_ADDRESS);
	if(status !=0){
		perror("IOCTL function failed");
		return WRITE_REG_FAIL;

	}
	n =write(fptr,&address,1);
	if(n==-1){
		perror("Write not successfull");
		return WRITE_REG_FAIL;

	}
	n = read(fptr,data,2);
	if(n == -1){
		perror("read not successfull");
		return READ_REG_FAIL;

	}
	close(fptr);
	return READ_REG_SUCCESS;
}

/***********************************************************************************************
 * @brief Read lux values 
 *
 *Responsible for reading lux value from light sensor
 *
 * @param null
 * @return double: Returns the lux values from light sensor
 *********************************************************************************************/


double read_lux(){
	pthread_mutex_lock(&i2c_mutex);

	uint8_t *data = malloc(sizeof(uint8_t)*2);
	int status = 0;
	status = read_two_reg(DATA1LOW_REG,data);
	if(status != READ_REG_SUCCESS){
		perror("Reading Channel 1 data register failed");
	}
	unsigned int ch1Int = (*(data +1)<<8) | *(data +0);
	status = read_two_reg(DATA0LOW_REG,data);
	if(status !=READ_REG_SUCCESS){
		perror("Reading Channel 0 data register failed");
	}
	unsigned int ch0Int =  (*(data +1)<<8) | *(data +0);

	status = read_two_reg(DATA0LOW_REG,data);
	if(status !=READ_REG_SUCCESS){
		perror("Reading channel 0 data register failed(floating values)");
	}
	float ch0 = (float)( (*(data +1)<<8) | *(data +0));

	status = read_two_reg(DATA1LOW_REG,data);
	if(status != READ_REG_SUCCESS){
		perror("Reading channel 1 data register failed(floating value)");
	}
	float ch1 = (float)( (*(data +1)<<8) | *(data +0));

	status = light_read_reg(TIMING_REG,data,INTEGRATION_TIME);
	if(status!= READ_REG_SUCCESS){
		perror("Reading integration time failed");

	}
	switch (*data)
	{
		case INTEGRATION_13_7:

			if ((ch1Int >= 5047) || (ch0Int >= 5047)) 
			{
				return 1.0/0.0;
			}
			break;
		case INTEGRATION_101:
			if ((ch1Int >= 37177) || (ch0Int >= 37177)) 
			{
				return 1.0/0.0;
			}
			break;
		case INTEGRATION_402:
			if ((ch1Int >= 65535) || (ch0Int >= 65535))
			{ 
				return 1.0/0.0;
			}
			break;
	}
	float ratio = ch1/ch0;
	status = light_read_reg(TIMING_REG,data,INTEGRATION_TIME);
	if(status!=READ_REG_SUCCESS){
		perror("Reading integration time failed");
	}
	switch (*data)
	{
		case INTEGRATION_13_7:
			ch0 *= 1/0.034;
			ch1 *= 1/0.034;
			break;
		case INTEGRATION_101:
			ch0 *= 1/0.252;
			ch1 *= 1/0.252;
			break;
		case INTEGRATION_402:
			ch0 *= 1;
			ch1 *= 1;
			break;

	}
	status = light_read_reg(TIMING_REG,data,GAIN);
	if (*data ==( (LOW_GAIN)>>4U)) 
	{
		ch0 *= 16;
		ch1 *= 16;
	}

	float luxVal = 0.0;
	if (ratio <= 0.5)
	{
		luxVal = (0.0304 * ch0) - ((0.062 * ch0) * (pow((ch1/ch0), 1.4)));
	}  
	else if (ratio <= 0.61)
	{
		luxVal = (0.0224 * ch0) - (0.031 * ch1);
	}
	else if (ratio <= 0.8)
	{
		luxVal = (0.0128 * ch0) - (0.0153 * ch1);
	}
	else if (ratio <= 1.3)
	{
		luxVal = (0.00146 * ch0) - (0.00112*ch1);
	}

	free(data);
	pthread_mutex_unlock(&i2c_mutex);

	return luxVal;
//	return 0;



}

/***********************************************************************************************  
 * @brief Power on light sensor 
 *
 *Responsible for turning On light sensor before reading any data
 *
 * @param  null
 *
 * @return null
 *********************************************************************************************/


sensor_status_t light_sensor_power_on(){
	pthread_mutex_lock(&i2c_mutex);

	sensor_status_t status;
	status = light_write_reg(CONTROL_REG,0x03);
	if(status!=WRITE_REG_SUCCESS){
	perror("Writing power on bit in Control register failed");
	return WRITE_REG_FAIL; 
	}
	
	pthread_mutex_unlock(&i2c_mutex);
	return WRITE_REG_SUCCESS;
}


/***********************************************************************************************  
 * @brief Set Integration Time 
 *
 *Responsible for setting up integration time based on INTEGRATION values
 *
 * @param INTEGRATION
 *
 * @return status of I2C operation
 *********************************************************************************************/
sensor_status_t set_integration_time(uint8_t INTEGRATION)
{
	pthread_mutex_lock(&i2c_mutex);
	uint8_t *data = malloc(sizeof(uint8_t));
	sensor_status_t status = light_read_reg(TIMING_REG,data,NONE); // check data arg
	*data &= ~0x03;	//check if required
	if(status != READ_REG_SUCCESS){
		perror("Reading register for time integration failed");
		free(data);
		pthread_mutex_unlock(&i2c_mutex);
		return READ_REG_FAIL;
		//Should set a flag and return as required: error/success, to avoid deadlock
	}

	if( INTEGRATION == INTEGRATION_13_7 )
	{
		*data |= 0x00;
	}
	else if( INTEGRATION == INTEGRATION_101 )
	{
		*data |= 0x01;
	}
	else if( INTEGRATION == INTEGRATION_402 )
	{
		*data |= 0x02;
	}

	status = light_write_reg(TIMING_REG, *data); //check data arg
	if(status != WRITE_REG_SUCCESS){
		perror("Writing register for integration time failed");
		free(data);
		pthread_mutex_unlock(&i2c_mutex);
		return WRITE_REG_FAIL;
	}

	free(data);
	pthread_mutex_unlock(&i2c_mutex);
	return WRITE_REG_SUCCESS;
}

/***********************************************************************************************  
 * @brief Read identification register 
 *
 *Responsible for reading identification register 
 *
 * @param null
 *
 * @return uint8_t returns the identification value
 *********************************************************************************************/
sensor_status_t read_identification_reg(uint8_t *data){
	sensor_status_t status = 0;
	pthread_mutex_lock(&i2c_mutex);
	
	//uint8_t *data = malloc(sizeof(uint8_t));
	status = light_read_reg(ID_REG,data,ALL);
	if(status != READ_REG_SUCCESS)
	{
		perror("Reading register for identification failed");
		pthread_mutex_unlock(&i2c_mutex);
		return READ_REG_FAIL;
		//Should set a flag and return as required: error/success, to avoid deadlock
	}
	*data = *data >>4;
	pthread_mutex_unlock(&i2c_mutex);
	return READ_REG_SUCCESS;



}

/***********************************************************************************************  
 * @brief Get Integration Time 
 *
 *Responsible for retrieivng set integration 
 *
 * @param null
 *
 * @return status of I2C operation
 *********************************************************************************************/

// i think this function is not required
sensor_status_t get_integration_time(uint8_t *data)
{
	pthread_mutex_lock(&i2c_mutex);
	//uint8_t *data = malloc(sizeof(uint8_t));
	sensor_status_t status = light_read_reg(TIMING_REG,data,INTEGRATION_TIME); // check data arg
	if(status != READ_REG_SUCCESS){
		perror("Reading register for time integration failed");
		pthread_mutex_unlock(&i2c_mutex);
		return READ_REG_FAIL;
	}
	// check if printing is OK!
	/*if( *data == 0x00 )
		printf("\nIntegration time = 13.7ms");
	else if( *data == 0x01 )
		printf("\nIntegration time = 101ms");
	else if( *data == 0x02 )
		printf("\nIntegration time = 402ms");
*/
	pthread_mutex_unlock(&i2c_mutex);
	return READ_REG_SUCCESS;

}


/***********************************************************************************************  
 * @brief Set gain 
 *
 * Responsible for setting gain values. Switches gain between low gain and high gain modes. 
 * Writing a 0 selects low gain (1x); writing a 1 selects high gain (16x). 
 *
 * @param gainlevel
 *
 * @return status of I2C operation
 *********************************************************************************************/
sensor_status_t set_gain( int gainlevel )
{
	pthread_mutex_lock(&i2c_mutex);
	uint8_t *data = malloc(sizeof(uint8_t));
	sensor_status_t status = light_read_reg(TIMING_REG,data,NONE); // check data arg
	if(status != READ_REG_SUCCESS){
		perror("Reading register for Setting gain failed");
		free(data);
		pthread_mutex_unlock(&i2c_mutex);
		return READ_REG_FAIL;
	}
	if( gainlevel == LOW_GAIN )
		*data &= ~0x10;
	else if( gainlevel == HIGH_GAIN )
		*data |= 0x10;

	status = light_write_reg(TIMING_REG, *data); //check data arg
	if(status != WRITE_REG_SUCCESS){
		perror("Writing register for Setting gain failed");
		free(data);
		pthread_mutex_unlock(&i2c_mutex);
		return WRITE_REG_FAIL;
	}
	free(data);
	pthread_mutex_unlock(&i2c_mutex);
	return WRITE_REG_SUCCESS;
}
/***********************************************************************************************  
 * @brief Get gain 
 *
 *Responsible for retrieivng gain
 *
 * @param null
 *
 * @return status of I2C operation
 *********************************************************************************************/

// i think this function is not required
sensor_status_t get_gain(uint8_t *data)
{
	pthread_mutex_lock(&i2c_mutex);
	//uint8_t *data = malloc(sizeof(uint8_t));
	sensor_status_t status = light_read_reg(TIMING_REG,data,GAIN); // check data arg
	if(status != READ_REG_SUCCESS){
		perror("Reading register for gain failed");
		pthread_mutex_unlock(&i2c_mutex);
		return READ_REG_FAIL;
	}
	// check if printing is OK!
	/*if( *data == 0x00 )
		printf("\nIntegration time = 13.7ms");
	else if( *data == 0x01 )
		printf("\nIntegration time = 101ms");
	else if( *data == 0x02 )
		printf("\nIntegration time = 402ms");
*/
	pthread_mutex_unlock(&i2c_mutex);
	return READ_REG_SUCCESS;

}


/***********************************************************************************************  
 * @brief Configure Interrupt Controller Register
 *
 * Enables/Disables Interrupt through Interrupt Controller Register
 *
 * @param interrupt_cmd_t command
 *
 * @return status of I2C operation
 *********************************************************************************************/
sensor_status_t config_interrupt_ctrl_reg( uint8_t command )
{
	pthread_mutex_lock(&i2c_mutex);
	uint8_t *data = malloc(sizeof(uint8_t));
	sensor_status_t status = light_read_reg(INTERRUPT_REG,data,NONE);	
	if(status != READ_REG_SUCCESS){
		perror("Reading register for Configuring Interrupt failed");
		free(data);
		pthread_mutex_unlock(&i2c_mutex);
		return READ_REG_FAIL;
	}

	if (command == INTERRUPT_OFF )
		*data &= ~0x30;
	else if (command == INTERRUPT_ON )
		*data |= 0x10;

	status = light_write_reg(INTERRUPT_REG, *data); //check data arg
	if(status != WRITE_REG_SUCCESS){
		perror("Writing register for Configuring Interrupt failed");
		free(data);
		pthread_mutex_unlock(&i2c_mutex);
		return WRITE_REG_FAIL;
	}
	free(data);
	pthread_mutex_unlock(&i2c_mutex);
	return WRITE_REG_SUCCESS;
}

/***********************************************************************************************  
 * @brief Get value of Interrupt control Register 
 *
 *Responsible for retrieving value of Interrupt Control Register
 *
 * @param null
 *
 * @return status of I2C operation
 *********************************************************************************************/

// i think this function is not required
sensor_status_t get_interrupt_ctrl_reg(uint8_t *data)
{
	pthread_mutex_lock(&i2c_mutex);
	//uint8_t *data = malloc(sizeof(uint8_t));
	sensor_status_t status = light_read_reg(INTERRUPT_REG,data,NONE); // check data arg
	if(status != READ_REG_SUCCESS){
		perror("Reading register for gain failed");
		pthread_mutex_unlock(&i2c_mutex);
		return READ_REG_FAIL;
	}

	// check if printing is OK!
	/*if( *data == 0x00 )
		printf("\nIntegration time = 13.7ms");
	else if( *data == 0x01 )
		printf("\nIntegration time = 101ms");
	else if( *data == 0x02 )
		printf("\nIntegration time = 402ms");
*/
	pthread_mutex_unlock(&i2c_mutex);
	return READ_REG_SUCCESS;

}
/***********************************************************************************************  
 * @brief Write low threshold
 *
 *Write to Registers THRESLOWLOW and THRESHLOWHIGH provide the low byte and
 * high byte, respectively, of the lower interrupt threshold 
 *
* @param uint16_t *data
 *
 * @return status of I2C operation
 *********************************************************************************************/
sensor_status_t set_low_threshold(uint16_t data)
{
	sensor_status_t status =0;
	pthread_mutex_lock(&i2c_mutex);
	status = light_write_two_reg(THRESHLOWLOW_REG,data); //check data arg
	if(status != WRITE_REG_SUCCESS){
		perror("Writing register for Configuring low threshold register failed");
		//free(data);
		pthread_mutex_unlock(&i2c_mutex);
		return WRITE_REG_FAIL;
	}
	//free(data);
	pthread_mutex_unlock(&i2c_mutex);
	return WRITE_REG_SUCCESS;

}

/***********************************************************************************************  
 * @brief Read low threshold
 *
 * Registers THRESHLOWLOW and THRESHLOWHIGH provide the low byte and
 * high byte, respectively, of the lower interrupt threshold
 *
 * @param uint16_t *data
 *
 * @return status of I2C operation
 *********************************************************************************************/
sensor_status_t get_low_threshold(uint16_t *data)
{
	pthread_mutex_lock(&i2c_mutex);
	uint8_t *data_low = malloc(sizeof(uint8_t));
	sensor_status_t status = light_read_reg(THRESHLOWLOW_REG, data_low, NONE);	
	if(status != READ_REG_SUCCESS){
		perror("Reading register for getting low threshold value failed");
		free(data_low);
		pthread_mutex_unlock(&i2c_mutex);
		return READ_REG_FAIL;
	}
	//*data <<= 8;

	uint8_t *data_high = malloc(sizeof(uint8_t));
	status = light_read_reg(THRESHLOWHIGH_REG,data_high, NONE);
	if(status != READ_REG_SUCCESS){
		perror("Reading register for getting low threshold value failed");
		free(data_low);
		free(data_high);
		pthread_mutex_unlock(&i2c_mutex);
		return READ_REG_FAIL;
	}
	*data = *data_high << 8 | *data_low ;
	free(data_low);
	free(data_high);
	pthread_mutex_unlock(&i2c_mutex);
	return WRITE_REG_SUCCESS;
}

/***********************************************************************************************  
 * @brief Write high threshold
 *
 *Write to Registers THRESHIGHLOW and THRESHHIGHHIGH provide the low byte and
 * high byte, respectively, of the lower interrupt threshold 
 *
* @param uint16_t *data
 *
 * @return status of I2C operation
 *********************************************************************************************/
sensor_status_t set_high_threshold(uint16_t data)
{
	sensor_status_t status =0;
	pthread_mutex_lock(&i2c_mutex);
	status = light_write_two_reg(THRESHHIGHLOW_REG,data); //check data arg
	if(status != WRITE_REG_SUCCESS){
		perror("Writing register for Configuring high threshold register failed");
		//free(data);
		pthread_mutex_unlock(&i2c_mutex);
		return WRITE_REG_FAIL;
	}
	//free(data);
	pthread_mutex_unlock(&i2c_mutex);
	return WRITE_REG_SUCCESS;


}
/***********************************************************************************************  
 * @brief Read high threshold
 *
 * Registers THRESHIGHLOW and THRESHHIGHHIGH provide the low byte and
 * high byte, respectively, of the lower interrupt threshold
 *
* @param uint16_t *data
 *
 * @return status of I2C operation
 *********************************************************************************************/
sensor_status_t get_high_threshold(uint16_t *data)
{
	pthread_mutex_lock(&i2c_mutex);
	uint8_t *data_low = malloc(sizeof(uint8_t));
	sensor_status_t status = light_read_reg(THRESHHIGHLOW_REG, data_low, NONE);	
	if(status != READ_REG_SUCCESS){
		perror("Reading register for getting high threshold value failed");
		free(data_low);
		pthread_mutex_unlock(&i2c_mutex);
		return READ_REG_FAIL;
	}
	//*data <<= 8;

	uint8_t *data_high = malloc(sizeof(uint8_t));
	status = light_read_reg(THRESHHIGHHIGH_REG,data_high, NONE);
	if(status != READ_REG_SUCCESS){
		perror("Reading register for getting high threshold value failed");
		free(data_low);
		free(data_high);
		pthread_mutex_unlock(&i2c_mutex);
		return READ_REG_FAIL;
	}
	*data = *data_high << 8 | *data_low ;
	free(data_low);
	free(data_high);
	pthread_mutex_unlock(&i2c_mutex);
	return WRITE_REG_SUCCESS;
}


/********************************************************************************************
*					FILENAME: logger.c
**********************************************************************************************/
/* Title: logger.c
 * Brief: Responsible for providing various helper function to support logger functionality
 * Author: Tanmay Chaturvedi, Vikrant Waje
 * Date Created: March 16, 2019
 * Course: Advanced Embedded Software Development
 * Project: 1

 * Reference[1]: http://www.
 * 
 * */
/****************************************************************************************
*					HEADER FILE SECTION
*****************************************************************************************/

#include"logger.h" 

/**************************************************************************************
*					     MACROS
****************************************************************************************/


/**************************************************************************************
*					FUNCTION DEFINITION
***************************************************************************************/






/*********************************************************************************************
*					FILENAME: server.c
**********************************************************************************************/

/* Title: server.c
 * Brief: Responsible for providing various helper functions for setting up the server side
 * Author: Tanmay Chaturvedi, Vikrant Waje
 * Date Created: March 10, 2019
 * Course: Advanced Embedded Software Development
 * 
 * This program demonsrates IPC using Sockets for Project 1.
 * This is the Server Side.
 * Reference[1]: http://www.it.uom.gr/teaching/distrubutedSite/dsIdaLiu/labs/lab2_1/sockets.html
 * Reference[2]: https://www.youtube.com/watch?v=pFLQmnmDOo
 */

/*********************************************************************************************
*					HEADER SECTION
**********************************************************************************************/
#include"server.h"
#include"temp_sensor.h"

/********************************************************************************************
*					GLOBAL VARIABLE SECTION
*********************************************************************************************/
mqd_t mqdes_server;
client_request_t client_request;
request_cmd_t client_temperature_type_request;
client_data_t client_data;


/******************************************************************************************
*					FUNCTION DEFINITION
********************************************************************************************/
/*******************************************************************************************
 * @brief Communicate with external client
 *
 * After connecting with external client, receives command from client and call respective
 * function.

 * @param null
 *
 * @return 0 if error, 1 if success
 ********************************************************************************************/
int server_establish()
{

	/*Server Thread*/
	int recv_stat;
	char str[30];
	int send_data_len = 0;

	int socket_flag = 0;	/*Not Connected*/
	if(socket_setup() != SOCKET_SETUP_SUCCESS){
		perror("Error in setup of socket");
	}
	if( socket_connect() == SOCKET_CONNECT_SUCCESS )
	{
		socket_flag = 1;
	}

	else{
		perror("Error in socket connect");

	}

	while(socket_flag == 1)
	{
		memset(str,0,sizeof(str));
		if((recv_stat = recv(sock_stat, str,sizeof(str),0) < 0))
		{
			perror("read error");
			socket_flag = 0;
			break;
		}
		else{


			//RxBuf[0] = str;

			if(strcmp(str,"1") == 0)
			{
				printf("\n\rtemp func received ");
				/*call temp_read()*/
				client_temperature_type_request = REQUEST_CELSIUS;
				client_request.client_get_temp_flag = 1;
				//	strcpy(client_data.sensor_string,"temp: ");
				//	client_data.sensor_data = 26.0;
				if(mq_receive(mqdes_server,(char *)&client_data,sizeof(client_data_t),NULL) ==-1){
					perror("Reception of data from temperature thread unsuccessfull");	
				}	
				if((send(sock_stat,&client_data ,sizeof(client_data_t),0))<0){
					perror("Error while sending temperature structure. Please try again!!");
					client_request.client_get_temp_flag = 0;
				} 


			}

			else if(strcmp(str,"2") == 0)
			{
				printf("\n\rtemp func received ");
				/*call temp_read()*/
				client_temperature_type_request = REQUEST_KELVIN;
				client_request.client_get_temp_flag = 1;
				//	strcpy(client_data.sensor_string,"temp: ");
				//	client_data.sensor_data = 26.0;
				if(mq_receive(mqdes_server,(char *)&client_data,sizeof(client_data_t),NULL) ==-1){
					perror("Reception of data from temperature thread unsuccessfull");	
				}	
				if((send(sock_stat,&client_data ,sizeof(client_data_t),0))<0){
					perror("Error while sending temperature structure. Please try again!!");
					client_request.client_get_temp_flag = 0;
				} 


			}
			
			else if(strcmp(str,"3") == 0)
			{
				printf("\n\rtemp func received ");
				/*call temp_read()*/
				client_temperature_type_request = REQUEST_FAHRENHEIT;
				client_request.client_get_temp_flag = 1;
				//	strcpy(client_data.sensor_string,"temp: ");
				//	client_data.sensor_data = 26.0;
				if(mq_receive(mqdes_server,(char *)&client_data,sizeof(client_data_t),NULL) ==-1){
					perror("Reception of data from temperature thread unsuccessfull");	
				}	
				if((send(sock_stat,&client_data ,sizeof(client_data_t),0))<0){
					perror("Error while sending temperature structure. Please try again!!");
					client_request.client_get_temp_flag = 0;
				} 


			}

			else if(strcmp(str,"4") == 0)
			{
				printf("\n\rLight val func received ");
				/*call light_val()*/
				client_request.client_get_lux_flag = 1;
				//strcpy(client_data.sensor_string,"light: ");
				//client_data.sensor_data = 1533.0;
				if(mq_receive(mqdes_server,(char *)&client_data,sizeof(client_data_t),NULL) ==-1){
					perror("Reception of data from light sensor thread unsuccessfull");	
				}	

				if((send(sock_stat,&client_data ,sizeof(client_data_t),0))<0){
					perror("Error while sending light structure. Please try again!!");
					client_request.client_get_lux_flag = 0;
				} 
			}

			else if(strcmp(str,"5") == 0)
			{
				printf("LED func received \n");
				/*System State func()*/
				led_on(RED_LED);
				led_on(YELLOW_LED);
				led_on(BLUE_LED);
				led_on(GREEN_LED);
			}	

			else if(strcmp(str,"6") == 0)
			{
				printf("LED func received \n");
				/*System State func()*/
				led_off(RED_LED);
				led_off(YELLOW_LED);
				led_off(BLUE_LED);
				led_off(GREEN_LED);
			}


			else if(strcmp(str,"7") == 0)
			{
				printf("Closing Socket \n");
				socket_flag = 0;
				//		close(socket_fd);	

				exit;
			}

			else 
			{
				printf("Unrecognized command. Please try again!\n");
			}	
		}
	}



}






/*******************************************************************************************
 * @brief Socket Setup Routines
 *
 * Call the socket(), bind() and returns 1 on successful setup

 * @param null
 *
 * @return 0 if error, 1 if success
 ********************************************************************************************/
server_response_t socket_setup()
{
	int sock_opt_true = 1;
	int listen_status = 0;
	socket_fd = socket(AF_INET, SOCK_STREAM,0);

	if(socket_fd < 0)
	{
		perror("Server: socket()");
		return SOCKET_FAIL;
	}

	server_addr.sin_family = AF_INET;
	server_addr.sin_addr.s_addr = INADDR_ANY;
	server_addr.sin_port = htons(PORT_NUM);

	if(bind(socket_fd, (struct sockaddr *)&server_addr, sizeof(server_addr)))
	{
		perror("Server: bind()");
		return BIND_FAIL;
	}

	listen_status=listen(socket_fd, NO_OF_CLIENT);
	if(listen_status == -1){
		LISTEN_FAIL;}

	return SOCKET_SETUP_SUCCESS;
}


/*******************************************************************************************
 * @brief Socket Listening Routines
 *
 * Call the listen() and accept() and returns 1 on successful connection
 * with an external client

 * @param null
 *
 * @return 0 if error, 1 if success
 ********************************************************************************************/
server_response_t socket_connect(void)
{	

	sock_stat = accept(socket_fd, (struct sockaddr *) 0,0);

	if( sock_stat == -1)
	{
		perror("Server: accept()");
		return ACCEPT_FAIL;				
	}

	return SOCKET_CONNECT_SUCCESS;
}



/********************************************************************************************
*					FILENAME: timer.c
**********************************************************************************************/
/* Title: timer.c
 * Brief: Responsible for providing various helper function needed for logger and heartbeat
 * Author: Tanmay Chaturvedi, Vikrant Waje
 * Date Created: March 16, 2019
 * Course: Advanced Embedded Software Development
 * Project: 1

 * Reference[1]: Professor's slides and notes 
 * 
 * */
/****************************************************************************************
*					HEADER FILE SECTION
*****************************************************************************************/
#include "timer.h"

/****************************************************************************************
*				GLOBAL VARIABLE SECTION
*****************************************************************************************/
int log_timer_flag;
logger_flag_t logger_flag;
heartbeat_flag_t heartbeat_flag;
/***************************************************************************************
*				FUNCTION DEFINITION
*****************************************************************************************/
/***********************************************************************************************
 * @brief logger  timer handler
 *
 * Handler that executes periodically to generate logging interval
 * @param null
 *
 * @return null
 *********************************************************************************************/
void log_timer_handler(int num){

	//log_timer_flag = 1;
	logger_flag.log_temp_sensor_flag =1;
	logger_flag.log_light_sensor_flag =1;
	printf("\n\rlogger");
}
/***********************************************************************************************
 * @brief heartbeat timer handler
 *
 * Handler that executes periodically to generate heartbeat interval
 * @param null
 *
 * @return null
 *********************************************************************************************/
void heartbeat_timer_handler(int num){

	heartbeat_flag.heartbeat_temp_sensor_flag = 1;
	heartbeat_flag.heartbeat_light_sensor_flag = 1;
	printf("\n\rHi heartbeat");
}
/***********************************************************************************************
 * @brief Create log timer
 *
 * Responsible for creating log timer which expires periodically to collect sensor information an
 * nd socket status that is logged into log file
 * @param null
 *
 * @return bool: Indicates whether intiialisation was successfull or novoidt
 *********************************************************************************************/
bool create_log_timer(){
	signal_specification.sigev_notify = SIGEV_THREAD;
	signal_specification.sigev_notify_function = &log_timer_handler;
	signal_specification.sigev_value.sival_ptr = "State collection timer";
	timer_create(CLOCK_REALTIME,&signal_specification,&log_timer_id);
	timer_setting.it_value.tv_sec =1;
	timer_setting.it_value.tv_nsec = 0;
	timer_setting.it_interval.tv_sec = 5;
	timer_setting.it_interval.tv_nsec = 0;
	timer_settime(log_timer_id,0,&timer_setting,NULL);
	return 0;
}

/***********************************************************************************************
 * @brief Create heartbeat timer
 *
 * Responsible for generating heartbeat for each of the four thread
 * @param null
 *
 * @return bool: Indicates whether intiialisation was successfull or not
 *********************************************************************************************/
bool create_heartbeat_timer(){

	signal_specification.sigev_notify = SIGEV_THREAD;
	signal_specification.sigev_notify_function = &heartbeat_timer_handler;
	signal_specification.sigev_value.sival_ptr = "Heartbeat timer";
	timer_create(CLOCK_REALTIME,&signal_specification,&heartbeat_timer_id);
	timer_setting.it_value.tv_sec =1;
	timer_setting.it_value.tv_nsec = 0;
	timer_setting.it_interval.tv_sec = 3;
	timer_setting.it_interval.tv_nsec = 0;
	timer_settime(heartbeat_timer_id,0,&timer_setting,NULL);
	return 0;
}
/***********************************************************************************************
 * @brief Record the timestamp value
 *
 * Responsible for recording the timestamp value
 * @param null
 *
 * @return double: returns the recorded time value
 *********************************************************************************************/
double record_time(){
	struct timespec timestamp;
	 clock_gettime(CLOCK_MONOTONIC,&timestamp);
	return((timestamp.tv_sec * (SEC_TO_MILLISEC))+ (timestamp.tv_nsec/(NANOSEC_TO_MILLISEC)) );	//Convert into milliseconds


}

/********************************************************************************************
*					FILENAME: synchronization.c
**********************************************************************************************/
/* Title: synchronization.c
 * Brief: Responsible for providing various synchronization constructs
 * Author: Tanmay Chaturvedi, Vikrant Waje
 * Date Created: March 16, 2019
 * Course: Advanced Embedded Software Development
 * Project: 1
 * 
 * 
 * */
/****************************************************************************************
*					HEADER FILE SECTION
*****************************************************************************************/

#include"synchronization.h" 

/**************************************************************************************
*					     MACROS
****************************************************************************************/


/**************************************************************************************
*					FUNCTION DEFINITION
***************************************************************************************/






/********************************************************************************************
 *					FILENAME: led.c
 **********************************************************************************************/
/* Title: led.c
 * Brief: Responsible for providing various helper function needed for initializing and blinking the led
 * Author: Tanmay Chaturvedi, Vikrant Waje
 * Date Created: March 16, 2019
 * Course: Advanced Embedded Software Development
 * Project: 1

 * Reference[1]: http://www.teachmemicro.com/beaglebone-black-blink-led-using-c/#
 * 
 * 
 * */
/****************************************************************************************
 *					HEADER FILE SECTION
 *****************************************************************************************/
#include"led.h"

/**************************************************************************************
 *					     MACROS
 ****************************************************************************************/

/**************************************************************************************
 *					     GLOBAL VARIABLES
 ****************************************************************************************/


/**************************************************************************************
 *					FUNCTION DEFINITION
 ***************************************************************************************/
/*******************************************************************************************
 * @brief Initialise LED gpio pins
 *
 * Initialise GPIO pins as output
 *
 * @param gpio_pin: GPIO pin whose direction is to be set
 *
 * @return null
 ********************************************************************************************/

void led_init(uint8_t gpio_pin[]){
	FILE *export_file = NULL;
	FILE *IO_direction = NULL;
	
	export_file = fopen("/sys/class/gpio/export","w");	//go to export directory
	fwrite(gpio_pin,1,sizeof(gpio_pin),export_file);
	fclose(export_file);
	
	if(strcmp(gpio_pin,"49")==0){
	IO_direction = fopen("/sys/class/gpio/gpio49/direction","w");
}

	if(strcmp(gpio_pin,"117")==0){
	IO_direction = fopen("/sys/class/gpio/gpio117/direction","w");
}
	if(strcmp(gpio_pin,"115")==0){
	IO_direction = fopen("/sys/class/gpio/gpio115/direction","w");
}
	if(strcmp(gpio_pin,"44")==0){
	IO_direction = fopen("/sys/class/gpio/gpio44/direction","w");
}
	uint8_t *str = "out";
	fwrite(str,1,sizeof(str),IO_direction);
	fclose(IO_direction);
	
}


/*******************************************************************************************
 * @brief Turn ON the led
 *
 * Turn the given LED ON, i.e output logic 1
 *
 * @param gpio_pin: GPIO pin which is to be turned ON
 *
 * @return null
 ********************************************************************************************/

void led_on(uint8_t gpio_pin[]){
	uint8_t value[] ="1";
	FILE *IO_value = NULL;
	if(strcmp(gpio_pin,"49") == 0){
	IO_value = fopen("/sys/class/gpio/gpio49/value","w");
}
	else if(strcmp(gpio_pin,"117")==0){
	IO_value = fopen("/sys/class/gpio/gpio117/value","w");

}
	else if(strcmp(gpio_pin,"115")==0){
	IO_value = fopen("/sys/class/gpio/gpio115/value","w");

}
	else if(strcmp(gpio_pin,"44")==0){
	IO_value = fopen("/sys/class/gpio/gpio44/value","w");

}	
else{
	perror("The gpio pin does not exist");
}
	fwrite(value,1,sizeof(value),IO_value);
	fclose(IO_value);


}


/*******************************************************************************************
 * @brief Turn OFF the led
 *
 * Turn the given LED OFF, i.e output logic 0
 *
 * @param gpio_pin: GPIO pin which is to be turned OFF
 *
 * @return null
 ********************************************************************************************/
void led_off(uint8_t gpio_pin[]){
	uint8_t *value ="0";
	FILE *IO_value = NULL;
	if(strcmp(gpio_pin,"49") == 0){
	IO_value = fopen("/sys/class/gpio/gpio49/value","w");
}
	else if(strcmp(gpio_pin,"117")==0){
	IO_value = fopen("/sys/class/gpio/gpio117/value","w");

}
	else if(strcmp(gpio_pin,"115")==0){
	IO_value = fopen("/sys/class/gpio/gpio115/value","w");

}
	else if(strcmp(gpio_pin,"44")==0){
	IO_value = fopen("/sys/class/gpio/gpio44/value","w");

}	
else{
	perror("The gpio pin does not exist");
}
	fwrite(value,1,sizeof(value),IO_value);
	fclose(IO_value);


}
/********************************************************************************************
*					FILENAME:temp_sensor.c
**********************************************************************************************/
/* Title: temp_sensor.c
 * Brief: Responsible for providing various helper function needed to communicate with temperature sensor
 * Author: Tanmay Chaturvedi, Vikrant Waje
 * Date Created: March 16, 2019
 * Course: Advanced Embedded Software Development
 * Project: 1

 * Reference[1]: http://www.sparkfun.com/products/13314
 * 
 * 
 * */
/****************************************************************************************
*					HEADER FILE SECTION
*****************************************************************************************/
#include "temp_sensor.h"
#include"synchronization.h"

/**************************************************************************************
*					GLOBAL VARIABLE
*******************************************************************************************/
const char *temp_i2c_path_name = "/dev/i2c-2";
pthread_mutex_t i2c_mutex;



/*********************************************************************************************** 
 * @brief Get temperature
 *
 * Read the value from temperature register
 *
 * @param request: Temperature value in kelvin, celsius and farhenheit to be returned
 * @return double: Value of converted temperature
 *********************************************************************************************/


double get_temperature(request_cmd_t request, uint16_t raw_data){
	//double result = 0;
	double multiplier =0;
	uint8_t *data = malloc(sizeof(uint8_t) * 2);
	if ( data == NULL )
	{
		return READ_REG_FAIL;
	}
   // multiplier = 0.0625;	


    *(data + 0) = (raw_data & 0x00FF);
    *(data + 1) = (raw_data & 0xFF00) >> 8;
	int32_t digitalTemp =0;

	// Bit 0 of second byte will always be 0 in 12-bit readings and 1 in 13-bit
	// Combine bytes to create a signed int 
		digitalTemp = (*(data + 1) << 4) | (*(data + 0) >> 4);
		// Temperature data can be + or -, if it should be negative,
		// convert 12 bit to 16 bit and use the 2s compliment.
		if(digitalTemp > 0x7FF)
		{
			digitalTemp |= 0xF000;
		}
	// Convert digital reading to analog temperature (1-bit is equal to 0.0625 C)

	free(data);

//	printf("Digital = %ld\n", digitalTemp);
	if ( request == REQUEST_KELVIN )
	{
		return(digitalTemp + 273.15);		
	}
	else if ( request == REQUEST_FAHRENHEIT )
	{
		return ((digitalTemp * 9.0/5.0) + 32.0);
	}
	else
	{
	//	printf("return = %lf\n", digitalTemp);
		return(digitalTemp);
	}
}

/********************************************************************************************
 *					FILENAME: bist.c
 **********************************************************************************************/
/* Title bist.c
 * Brief: Contains function that are used for built in self test
 * Author: Tanmay Chaturvedi, Vikrant Waje
 * Date Created: March 16, 2019
 * Course: Advanced Embedded Software Development
 * Project: 1

 * Reference[1]: http://www.
 * 
 * 
 * */
/****************************************************************************************
 *					HEADER FILE SECTION
 *****************************************************************************************/
#include "bist.h"
/***************************************************************************************
 *					MACROS AND ENUMS
 ****************************************************************************************/

/***************************************************************************************
 *					GLOBAL VARIABLE
 ****************************************************************************************/
pthread_t thread1, thread2, thread3, thread4;

/***************************************************************************************
 *				FUNCTION DEFINITION
 ***********************************************************************************************/
void built_in_self_test(){
	double return_data = 0.0;
	sensor_status_t sensor_stat;	
	uint8_t sensor_data = 0;
	uint8_t *data = malloc(sizeof(uint8_t));
	uint16_t *data_16 = malloc(sizeof(uint16_t));

	int ret_status =0;

	if(data == NULL || data_16 == NULL){
		printf("Malloc failed");
	}
	else{
		// Check whether temperature sensor is working properly

		ret_status = write_thigh(THIGH_VAL);
		if(ret_status!= WRITE_REG_SUCCESS){
			printf("\n\rTemperature sensor initialisation failed. Failed to write  Thigh register");
		}


		return_data = get_Thigh(REQUEST_CELSIUS);
		if(return_data !=THIGH_VAL){
			printf("\n\rTemperature sensor initialisation failed.Incorrect Thigh value =%lf",return_data);
		}

		ret_status = write_tlow(TLOW_VAL);
		if(ret_status!= WRITE_REG_SUCCESS){
			printf("\n\rTemperature sensor initialisation failed. Failed to write  Tlow register");
		}

		return_data = get_Tlow(REQUEST_CELSIUS);
		if(return_data != TLOW_VAL){
			printf("\n\rTemperature sensor initialisation failed.Incorrect Tlow value. Tlow temp =%lf",return_data);
		}

		ret_status = configure_temp_fault(FAULT_2);
		if(ret_status!= WRITE_REG_SUCCESS){
			printf("\n\rTemperature sensor initialisation failed. Failed to write fault bits. ");
		}


		ret_status = read_temp_fault(data);
		if(((*(data) & FAULT_MASK) !=FAULT_2) && ret_status!=READ_REG_SUCCESS){
			printf("\n\rTemperature sensor initialisation failed. Incorrect fault bit values data = %x",*data);
		}

		ret_status = configure_temp_EMmode(EM_OFF);
		if(ret_status!= WRITE_REG_SUCCESS){
			printf("\n\rTemperature sensor initialisation failed. Failed to write EM bits");
		}

		ret_status = read_temp_EM(data);
		if((*(data) & EM_MASK)!=EM_OFF && ret_status!=READ_REG_SUCCESS){
			printf("\n\rTemperature sensor initialisation failed. Incorrect EM bit value data =%x",*data);
		}

		ret_status = configure_temp_conversion_rate(CONVERSION_RATE_4);
		if(ret_status!= WRITE_REG_SUCCESS){
			printf("\n\rTemperature sensor initialisation failed. Failed to write conversion rate bits");
		}

		ret_status = read_temp_conversion_rate(data);
		if((*(data) & CONVERSION_RATE_MASK)!=CONVERSION_RATE_4 && ret_status!=READ_REG_SUCCESS){
			printf("\n\rTemperature sensor initialisation failed. Incorrect conversion rate bit value data =%x",*data);
		}		


		ret_status = read_temp_sensor_resolution(data);
		if((*(data) & RESOLUTION_MASK)!=SENSOR_RESOLUTION_12_BIT && ret_status!=READ_REG_SUCCESS){
			printf("\n\rTemperature sensor initialisation failed. Incorrect sensor resolution bit value data =%x",*data);
		}		
		// Check whether light sensor is working properly

		sensor_stat=light_sensor_power_on();
		if(sensor_stat != WRITE_REG_SUCCESS){
			printf("\n\rLight sensor initialisation failed");
		}

		sensor_stat =read_identification_reg(data);	
		if(*data != IDENTIFICATION_MASK && sensor_stat!=READ_REG_SUCCESS){
			printf("\n\rLight sensor initialisation failed. Incorrect identification read data = %d",*data);
		}

		ret_status = set_integration_time(INTEGRATION_402);
		if(ret_status!= WRITE_REG_SUCCESS){
			printf("\n\rLight sensor initialisation failed. Failed to write Integration bits");
		}

		ret_status = get_integration_time(data);
		if((*(data) & INTEGRATION_MASK)!=INTEGRATION_402 && ret_status!=READ_REG_SUCCESS){
			printf("\n\rLight sensor initialisation failed. Incorrect integration rate bit  data =%x",*data);
		}		

		ret_status = set_gain(HIGH_GAIN);
		if(ret_status!= WRITE_REG_SUCCESS){
			printf("\n\rLight sensor initialisation failed. Failed to write gain bits");
		}

		ret_status = get_gain(data);
		if((*(data) & GAIN_MASK)!=HIGH_GAIN && ret_status!=READ_REG_SUCCESS){
			printf("\n\rLight sensor initialisation failed. Incorrect gain bit  data =%x",*data);
		}

		ret_status = config_interrupt_ctrl_reg(INTERRUPT_ON);
		if(ret_status!= WRITE_REG_SUCCESS){
			printf("\n\rLight sensor initialisation failed. Failed to write Interrupt control register bits");
		}
		ret_status = get_interrupt_ctrl_reg(data);
		if(*data!= INTERRUPT_ON && ret_status!= READ_REG_SUCCESS){
			printf("\n\rLight sensor initialisation failed. Failed to read Interrupt control register bits");
		}	

		ret_status = set_high_threshold(THRESHOLD_HIGH);
		if(ret_status!= WRITE_REG_SUCCESS){
			printf("\n\rLight sensor initialisation failed. Failed to write Interrupt high threshold register ");
		}
			
		ret_status = get_high_threshold(data_16);
		if( *data_16 !=THRESHOLD_HIGH && ret_status!= READ_REG_SUCCESS ){
			printf("\n\rLight sensor initialisation failed. Failed to read Interrupt high threshold,val =%ld",*(data_16));
		}

		ret_status = set_low_threshold(THRESHOLD_LOW);
		if(ret_status!= WRITE_REG_SUCCESS){
			printf("\n\rLight sensor initialisation failed. Failed to write Interrupt high threshold register ");
		}
			
		ret_status = get_low_threshold(data_16);
		if( *data_16 !=THRESHOLD_LOW && ret_status!= READ_REG_SUCCESS ){
			printf("\n\rLight sensor initialisation failed. Failed to read Interrupt high threshold,val =%ld",*(data_16));
		}

		printf("\n\rValue = %ld",*(data_16));
		//Check whether threads have been created successfully or not

		/* Socket thread creation*/
		ret_status = pthread_create( &thread1, NULL, socket_thread,0);
		if( ret_status )
		{
			fprintf( stderr, "socket_thread not created, Error Code: %d\n", ret_status);

		}

		/*Temperature thread creation*/
		ret_status = pthread_create( &thread2, NULL, temperature_thread,0);
		if( ret_status )
		{
			fprintf( stderr, "temperature_thread not created, Error Code: %d\n", ret_status);
		}

		/*light sensor thread creation*/
		ret_status = pthread_create( &thread3, NULL, light_sensor_thread,0);
		if( ret_status )
		{
			fprintf( stderr, "light_sensor_thread not created, Error Code: %d\n", ret_status);
		}



		/*logger thread creation*/
		ret_status = pthread_create( &thread4, NULL, logger_thread,0);

		if( ret_status )
		{
			fprintf( stderr, "logger_thread not created, Error Code: %d\n", ret_status);
		}

		// Notify success/no success to logger
	}

}
/********************************************************************************************
 *					FILENAME: main.c
 **********************************************************************************************/
/* Title: main.c
 * Brief: Responsible for creating threads, joining them and initiating built in self test
 * Author: Tanmay Chaturvedi, Vikrant Waje
 * Date Created: March 16, 2019
 * Course: Advanced Embedded Software Development
 * Project: 1
 * 
 * 
 * */
/****************************************************************************************
 *					HEADER FILE SECTION
 *****************************************************************************************/
#include "main.h"
#include "thread.h"


/*******************************************************************************************
 * @brief Main function
 *
 * Responsible for creating four threads for execution namely light sensor thread, temperature th * read, logger thread and socket thread
 *
 * @param null
 *
 * @return null
 ********************************************************************************************/
return_type_t main_func()
{
	int ret_status;
	/*Socket thread join*/
	//pthread_t thread1, thread2, thread3, thread4;

	ret_status = pthread_create( &thread1, NULL, socket_thread,0);
	if( ret_status )
	{
	return PTHREAD_FAIL;
	}

	/*Temperature thread creation*/
	ret_status = pthread_create( &thread2, NULL, temperature_thread,0);
	if( ret_status )
	{
		return PTHREAD_FAIL;
	}

	/*light sensor thread creation*/
	ret_status = pthread_create( &thread3, NULL, light_sensor_thread,0);
	if( ret_status )
	{
		return PTHREAD_FAIL;
	}



	/*logger thread creation*/
	ret_status = pthread_create( &thread4, NULL, logger_thread,0);

	if( ret_status )
	{
	return PTHREAD_FAIL;
	}


	ret_status = pthread_join( thread1, NULL);
	if(ret_status){
		//fprintf( stderr, "socket thread not joined successfully, Error Code: %d\n", ret_status);
	//	printf("Failed here");
		return PTHREAD_FAIL;
	}
	/*Temperature thread join*/
	ret_status =	pthread_join( thread2, NULL);
	if(ret_status){
		//fprintf( stderr, "temperature_thread not joined successfully, Error Code: %d\n", ret_status);
		return PTHREAD_FAIL;	
	}

//	Light sensor thread join
	ret_status =	pthread_join( thread3, NULL);
	if(ret_status){
		//fprintf( stderr, "light_sensor thread not joined successfully, Error Code: %d\n", ret_status);
		return PTHREAD_FAIL;
	}

	/*Logger thread join*/
	ret_status =	pthread_join( thread4, NULL);
	if(ret_status){
		//fprintf( stderr, "logger thread not joined successfully, Error Code: %d\n", ret_status);
		return PTHREAD_FAIL;
	}
	//printf("Main Thread Exited Successfully \n");


	return PTHREAD_SUCCESS;
}


void *socket_thread( void* arg){
	//mock thread
}

void *temperature_thread( void* arg)
{
	//mock thread	
}
void *light_sensor_thread( void* arg)
{
	//mocj thread	
}

void *logger_thread( void* arg)
{
	//mock thread
}
/********************************************************************************************
*					FILENAME: unittest.c
**********************************************************************************************/
/* Title:thread.h
 * Brief: Responsible for performing unit testing using CUnit unit testing framework
 * Author: Tanmay Chaturvedi, Vikrant Waje
 * Date Created: March 26, 2019
 * Course: Advanced Embedded Software Development
 * Project: 1
 * 
 * 
 * */
/**********************************************************************************************
*					HEADER FILE SECTION
***********************************************************************************************/
#include "../include/unittest.h"
#include <pthread.h>
#include <mqueue.h>

pthread_t thread1, thread2, thread3, thread4;
mqd_t mqdes_server;
struct mq_attr attribute_server;



int main()
{
	if( CU_initialize_registry() == CUE_NOMEMORY )
	{
		return CU_get_error();
	}
	
	if( cunit_add_testsuite() == 0 )
	{
		CU_cleanup_registry();
		return CU_get_error();
	}

	CU_basic_set_mode( CU_BRM_VERBOSE );

	CU_basic_run_tests();

	CU_automated_run_tests();

	CU_cleanup_registry();

	return CU_get_error();
}


/**********************************************************************************************
*				FUNCTION DEFINITION
***********************************************************************************************/

int cunit_add_testsuite(void)
{
	CU_pSuite pSuite_pthread, pSuite_ipc, pSuite_temp = NULL;

	pSuite_pthread = CU_add_suite( "BeagleBone Linux Testing - Posix Thread Creation Task", cunit_pthread_test, NULL );

	if( pSuite_pthread == NULL )
	{
		return 0;
	}

	pSuite_ipc = CU_add_suite( "BeagleBone Linux Testing - Inter Thread Communication Task", cunit_ipc_test, NULL );

	if( pSuite_ipc == NULL )
	{
		return 0;
	}

	pSuite_temp = CU_add_suite( "BeagleBone Linux Testing - Temperature conversion task", cunit_temp_test, NULL );

	if( pSuite_temp == NULL )
	{
		return 0;
	}


	if( ( CU_add_test(pSuite_pthread, "Pthread: Create and Join Test", pthread_create_test ) == NULL ) )
	{
		return 0;
	}	

	if( ( CU_add_test(pSuite_ipc, "Message Queue: Open Test", message_queue_open_test ) == NULL ) || \
		( CU_add_test(pSuite_ipc, "Message Queue: Close Test", message_queue_close_test ) == NULL ) )
	{
		return 0;
	}


	if( ( CU_add_test(pSuite_temp, "Temperature Sensor: Conversion Test", temp_conversion_test ) == NULL) )
	{
		return 0;
	}

	return 1;
}



int cunit_pthread_test(void)
{
	return 0;
}

int cunit_ipc_test(void)
{
	return 0;
}

int cunit_temp_test(void)
{
	return 0;
}

void pthread_create_test(void)
{
	CU_ASSERT_EQUAL(main_func(),PTHREAD_SUCCESS);
}

void message_queue_open_test(void)
{
	CU_ASSERT_EQUAL(open_message_queue_server(&mqdes_server, &attribute_server), MQ_SUCCESS);
}

void message_queue_close_test(void)
{
	CU_ASSERT_EQUAL(close_message_queue_server(&mqdes_server), MQ_SUCCESS);
}



void temp_conversion_test(void)
{
	CU_ASSERT_EQUAL(get_temperature(REQUEST_CELSIUS, 0x0320), 50.0);
	CU_ASSERT_EQUAL(get_temperature(REQUEST_CELSIUS, 0x04B0), 75.0);
	CU_ASSERT_EQUAL(get_temperature(REQUEST_CELSIUS, 0x0190), 25.0);
	CU_ASSERT_EQUAL(get_temperature(REQUEST_FAHRENHEIT, 0x0320), 122.0);
	CU_ASSERT_EQUAL(get_temperature(REQUEST_FAHRENHEIT, 0x04B0), 167.0);
	CU_ASSERT_EQUAL(get_temperature(REQUEST_FAHRENHEIT, 0x0190), 77.0);
	CU_ASSERT_EQUAL(get_temperature(REQUEST_KELVIN, 0x0320), 323.15);
	CU_ASSERT_EQUAL(get_temperature(REQUEST_KELVIN, 0x04B0), 348.15);
	CU_ASSERT_EQUAL(get_temperature(REQUEST_KELVIN, 0x0190), 298.15);

	CU_ASSERT_NOT_EQUAL(get_temperature(REQUEST_CELSIUS, 0x0190), 40.0);
}
/********************************************************************************************
 *					FILENAME: ipc.c
 **********************************************************************************************/
/* Title: ipc.c
 * Brief: Responsible for implementing various helper function that helps in setting up interthread communication 
 * Author: Tanmay Chaturvedi, Vikrant Waje
 * Date Created: March 16, 2019
 * Course: Advanced Embedded Software Development
 * Project: 1
 *
 * 
 * 
 * */
/****************************************************************************************
 *					HEADER FILE SECTION
 *****************************************************************************************/


#include"ipc.h"
#include<mqueue.h>

/**************************************************************************************
 *					     MACROS
 ****************************************************************************************/

/**************************************************************************************
 *					     GLOBAL VARIABLES
 ****************************************************************************************/


/**************************************************************************************
 *					     FUNCTION DEFINITION
/ ****************************************************************************************/

 /* @brief Open message queue for server
 *
 * Initialises a message queue that can be used to transfer sensor values to server when client requests it
 *
 * @param mqdes: Message queue descriptor
 * @param attribute: Attribute of message queue 
 *
 * @return null
 ********************************************************************************************/

ipc_return_t open_message_queue_server(mqd_t *mqdes, struct mq_attr * attribute){
	attribute->mq_maxmsg= 10;
	attribute->mq_msgsize = sizeof(client_data_t);
	*mqdes = mq_open("/msgqueue4",O_CREAT|O_RDWR,0666,attribute); 
	if(*mqdes == -1){
		//perror("Failed to open message queue fro server");
		return MQ_FAIL;

	}
	return MQ_SUCCESS;
}


/*******************************************************************************************
 * @brief Close message queue for server
 *
 * Unlinks and Closes  message queue that was used to transfer sensor values to server when client requests it
 *
 * @param mqdes: Message queue descriptor
 * @param attribute: Attribute of message queue 
 *
 * @return null
 ********************************************************************************************/


ipc_return_t close_message_queue_server(mqd_t *mqdes){
	if(mq_close(*mqdes)==-1){
		return MQ_FAIL;
	}

	if(mq_unlink("/msgqueue4")<0){
		return MQ_FAIL;
	}
return MQ_SUCCESS;
}
/********************************************************************************************
 *					FILENAME: thread.c
 **********************************************************************************************/
/* Title:thread.c
 * Brief: Responsible for providing callback function for the four threads created in main function
 * Author: Tanmay Chaturvedi, Vikrant Waje
 * Date Created: March 16, 2019
 * Course: Advanced Embedded Software Development
 * Project: 1
 * 
 * 
 * */
/****************************************************************************************
 *					HEADER FILE SECTION
 *****************************************************************************************/

#include"main.h" 

/**************************************************************************************
 *					     MACROS
 ****************************************************************************************/

/**************************************************************************************
 *					     GLOBAL VARIABLES
 ****************************************************************************************/
/*bool client_get_temp_flag;
  bool client_get_system_stat_flag;
  bool client_get_lux_flag;
 */

pthread_t thread1,thread2,thread3,thread4;
mqd_t mqdes_server;
client_request_t client_request;
request_cmd_t client_temperature_type_request ;
client_data_t client_data;

mqd_t mqdes_logger;
logger_flag_t logger_flag;
log_t log_temp_data_src;
log_t log_light_data_src;
pthread_mutex_t logger_queue_mutex;

mqd_t mqdes_heartbeat;
heartbeat_flag_t heartbeat_flag;
heartbeat_data_t heartbeat_temp_data_src;
heartbeat_data_t heartbeat_light_data_src;
pthread_mutex_t heartbeat_queue_mutex;
/**************************************************************************************
 *					FUNCTION DEFINITION
 ***************************************************************************************/

/*******************************************************************************************
 * @brief Socket thread
 *
 * Waits for a connection initiated by an external client.
 * Once connected, accepts commands from client and acts accordingly.
 * If clients commands the connection to "close", server thread disconnects,
 * closes the socket connection and waits for a new connection.
 *
 * @param null
 *
 * @return null
 ********************************************************************************************/
void *socket_thread( void* arg){
	int ret_status = server_establish();
}


/***********************************************************************************************
 * @brief Temperature thread
 *
 * Get the temperature value periodically from temperature sensor and logs 
 * into file opened by logger thread
 *
 * @param null
 *
 * @return null
 *********************************************************************************************/

void *temperature_thread( void* arg){
	double temperature_data = 0;
	temperature_data = get_temperature(client_temperature_type_request); 
	while(1){

		//printf("\n\rTlow = %lf , Thigh =%lf",get_Tlow(client_temperature_type_request),get_Thigh(client_temperature_type_request));
		//sleep(1);
		if(client_request.client_get_temp_flag == 1){



			//send message through queue to server task
			//printf("\n\rTemperature data called from client: %lf",temperature_data);


			if(client_temperature_type_request == REQUEST_CELSIUS){	

				temperature_data = get_temperature(client_temperature_type_request);

				strcpy(client_data.sensor_string,"Temperature value in celsius:");

				strcpy(log_temp_data_src.source_ID,"EXT REQ(TEMP IN C)");	

				client_data.sensor_data = temperature_data;
				log_temp_data_src.sensor_data = temperature_data;

			}
			else if(client_temperature_type_request == REQUEST_KELVIN){	
				temperature_data = get_temperature(client_temperature_type_request);
				log_temp_data_src.sensor_data = temperature_data;
				client_data.sensor_data = temperature_data;
				strcpy(log_temp_data_src.source_ID,"EXT REQ(TEMP IN K)");	

				strcpy(client_data.sensor_string,"Temperature value in Kelvin:");
			}
			else /*(client_temperature_type_request == REQUEST_FAHRENHEIT)*/{	
				temperature_data = get_temperature(client_temperature_type_request);
				log_temp_data_src.sensor_data = temperature_data;
				client_data.sensor_data = temperature_data;

				strcpy(log_temp_data_src.source_ID,"EXT REQ(TEMP IN F)");

				strcpy(client_data.sensor_string,"Temperature value in Fahrenheit:");
			}


			if(mq_send(mqdes_server,(char *)&client_data,sizeof(client_data_t),0)==-1){
				perror("Sending temperature value to server unsuccessfull");
			}
			client_request.client_get_temp_flag =0;



			pthread_mutex_lock(&logger_queue_mutex);

			log_temp_data_src.timestamp = record_time();
			log_temp_data_src.log_level = 3;

			if(mq_send(mqdes_logger,(char *)&log_temp_data_src,sizeof(log_t),0)==-1){
				perror("Sending temperature value to logger unsuccessfull");
			}
			pthread_mutex_unlock(&logger_queue_mutex);




		}
		if(logger_flag.log_temp_sensor_flag == 1){

			log_temp_data_src.timestamp = record_time(); 
			log_temp_data_src.log_level = 2;
			if(client_temperature_type_request == REQUEST_CELSIUS){
				strcpy(log_temp_data_src.source_ID,"TEMPERATURE(C)");

			}
			else if(client_temperature_type_request == REQUEST_FAHRENHEIT){
				strcpy(log_temp_data_src.source_ID,"TEMPERATURE(F)");
			}
			else if(client_temperature_type_request == REQUEST_KELVIN){
				strcpy(log_temp_data_src.source_ID,"TEMPERATURE(K)");
			}
			log_temp_data_src.sensor_data = temperature_data;	
			pthread_mutex_lock(&logger_queue_mutex);
			if(mq_send(mqdes_logger,(char *)&log_temp_data_src,sizeof(log_t),0)==-1){
				perror("Sending temperature value to logger unsuccessfull");
			}
			pthread_mutex_unlock(&logger_queue_mutex);

			logger_flag.log_temp_sensor_flag =0;


		}

		if(heartbeat_flag.heartbeat_temp_sensor_flag == 1){
			temperature_data = get_temperature(client_temperature_type_request);
			heartbeat_temp_data_src.timestamp = record_time(); 
			heartbeat_temp_data_src.log_level = 1;
			strcpy(heartbeat_temp_data_src.source_ID,"Temp sensor alive:");
			heartbeat_temp_data_src.sensor_data = temperature_data;	
			pthread_mutex_lock(&heartbeat_queue_mutex);
			if(mq_send(mqdes_heartbeat,(char *)&heartbeat_temp_data_src,sizeof(heartbeat_data_t),0)==-1){
				perror("Sending temperature value to main unsuccessfull");
			}
			pthread_mutex_unlock(&heartbeat_queue_mutex);

			heartbeat_flag.heartbeat_temp_sensor_flag =0;


		}

	}
}




/***********************************************************************************************
 * @brief light sensor thread
 *
 * Get the LUX values from light sensor attached using I2C interface and report it periodically t * o logger thread
 *
 * @param null
 *
 * @return null
 *********************************************************************************************/

void *light_sensor_thread( void* arg){
	double lux_data = 0;
	double force_lux_data = 0;
	last_state_t last_state = LIGHT;
		while(1){

	
		lux_data = read_lux();
		if(lux_data >=75 && last_state ==DARK){
			log_light_data_src.sensor_data = lux_data;
			strcpy(log_light_data_src.source_ID,"DARK_TO_LIGHTCHANGE");
			log_light_data_src.timestamp = record_time();
			log_light_data_src.log_level = 3;
		
		pthread_mutex_lock(&logger_queue_mutex);

			if(mq_send(mqdes_logger,(char *)&log_light_data_src,sizeof(log_t),0)==-1){
				perror("Sending light value to logger unsuccessfull");
			}
			last_state = LIGHT;
	pthread_mutex_unlock(&logger_queue_mutex);

		}
		else if(lux_data<75 && last_state == LIGHT){
			//strcpy(log_light_data_src.source_ID,"DARK_TO_LIGHTCHANGE");

			strcpy(log_light_data_src.source_ID,"LIGHT_TO_DARKCHANGE");
			log_light_data_src.sensor_data = lux_data;
			log_light_data_src.timestamp = record_time();
			log_light_data_src.log_level = 3;
		
		pthread_mutex_lock(&logger_queue_mutex);

			if(mq_send(mqdes_logger,(char *)&log_light_data_src,sizeof(log_t),0)==-1){
				perror("Sending light value to logger unsuccessfull");
			}
			last_state =DARK;
		pthread_mutex_unlock(&logger_queue_mutex);

		}
		else{
		//	printf("\n\rNo change");
		}
	

		//client_get_lux_flag = 1;
		if(client_request.client_get_lux_flag == 1){
			//send message through queue to server task
			lux_data = read_lux(); 

			if ( lux_data >= 75 )
			{
				strcpy(client_data.sensor_string,"Lux value in lumens(STATE=LIGHT):"); 	
				strcpy(log_light_data_src.source_ID,"EXT REQ(LIGHT STATE)");

			}
			else if ( lux_data < 75 ) 
			{
				strcpy(client_data.sensor_string,"Lux value in lumens(STATE=DARK):"); 	
				strcpy(log_light_data_src.source_ID,"EXT REQ(DARK STATE)");

			}
			//	printf("\n\rLight data called from client:%lf",lux_data);
			client_data.sensor_data = lux_data;	
			if(mq_send(mqdes_server,(char *)&client_data,sizeof(client_data_t),0)==-1){
				perror("Sending light value to server unsuccessfull");
			}

			pthread_mutex_lock(&logger_queue_mutex);

			log_light_data_src.timestamp = record_time();
			log_light_data_src.log_level = 3;

			if(mq_send(mqdes_logger,(char *)&log_light_data_src,sizeof(log_t),0)==-1){
				perror("Sending light value to logger unsuccessfull");
			}
			pthread_mutex_unlock(&logger_queue_mutex);





			client_request.client_get_lux_flag = 0;

		}
		if(logger_flag.log_light_sensor_flag == 1){
			lux_data = read_lux(); 
			log_light_data_src.timestamp = record_time(); 
			log_light_data_src.log_level = 2;
			if( lux_data <75){
				strcpy(log_light_data_src.source_ID,"LIGHT(DARK STATE)");
			}
			else if(lux_data >=75){
				strcpy(log_light_data_src.source_ID,"LIGHT(LIGHT STATE)");

			}
			log_light_data_src.sensor_data = lux_data;	
			pthread_mutex_lock(&logger_queue_mutex);
			if(mq_send(mqdes_logger,(char *)&log_light_data_src,sizeof(log_t),0)==-1){
				perror("Sending light value to logger unsuccessfull");
			}
			logger_flag.log_light_sensor_flag =0;
			pthread_mutex_unlock(&logger_queue_mutex);


		}

		if(heartbeat_flag.heartbeat_light_sensor_flag == 1){
			lux_data = read_lux(); 
			heartbeat_light_data_src.timestamp = record_time(); 
			heartbeat_light_data_src.log_level = 2;
			strcpy(heartbeat_light_data_src.source_ID,"Light sensor alive:");
			heartbeat_light_data_src.sensor_data = lux_data;	
			pthread_mutex_lock(&heartbeat_queue_mutex);
			if(mq_send(mqdes_heartbeat,(char *)&heartbeat_light_data_src,sizeof(heartbeat_data_t),0)==-1){
				perror("Sending light value to main unsuccessfull");
			}
			pthread_mutex_unlock(&heartbeat_queue_mutex);

			heartbeat_flag.heartbeat_light_sensor_flag =0;


		}


	}

}




/***********************************************************************************************
 * @brief logger thread
 *
 * Log the values of temperature, light sensor and socket status in log file created by logger task 
 * into file opened by logger thread
 *
 * @param null
 *
 * @return null
 *********************************************************************************************/

void *logger_thread( void* arg){
	log_t log_temp_data;
	FILE *log_file = NULL;
	while(1){
		//	pthread_mutex_lock(&logger_queue_mutex);
		if(mq_receive(mqdes_logger,(char *)&log_temp_data,sizeof(log_t),NULL) ==-1){
			perror("Reception of data from temp sensor thread unsuccessfull");	
		}
		log_file = fopen("log.txt","a+");
		//	printf("\n\r[%lf] [%d] [%s] [%lf]",log_temp_data.timestamp,log_temp_data.log_level,log_temp_data.source_ID,log_temp_data.sensor_data);
		//	pthread_mutex_unlock(&logger_queue_mutex);

		LOG(log_file,log_temp_data.timestamp,log_temp_data.log_level,log_temp_data.source_ID,log_temp_data.sensor_data);
		fclose(log_file);

	}
}









/********************************************************************************************
*					FILENAME: light_sensor.c
**********************************************************************************************/
/* Title Light sensor.c
 * Brief: Contains function that are used for communication with light sensor
 * Author: Tanmay Chaturvedi, Vikrant Waje
 * Date Created: March 16, 2019
 * Course: Advanced Embedded Software Development
 * Project: 1
 * Reference[1]: http://www.sparkfun.com/products/14350
 * 
 * 
 * */
/****************************************************************************************
*					HEADER FILE SECTION
*****************************************************************************************/
#include "light_sensor.h"
#include"synchronization.h"

/***************************************************************************************
*					GLOBAL VARIABLE
****************************************************************************************/
const char *light_i2c_path_name = "/dev/i2c-2";
pthread_mutex_t i2c_mutex;

/***************************************************************************************
*				FUNCTION DEFINITION
***********************************************************************************************/

/***********************************************************************************************  
 * @brief write register in light sensor 
 *
 *Responsible for writing into  register of light sensor
 *
 * @param address: address of  register  of light sensor
 * @param data: data to be written into register of light sensor
 *
 * @return status of I2C operation
 *********************************************************************************************/


sensor_status_t light_write_reg(uint8_t address, uint8_t data){
	int status =0;
	int fptr = 0;
	int n = 0;
	uint8_t *buffer = malloc(sizeof(uint8_t) *5);
	*(buffer + 0) = (address | COMMAND_BIT);
	*(buffer + 1) = ((data));

	fptr = open(light_i2c_path_name,O_RDWR);	
	if(fptr == -1){
		perror("Error in opening the file");
		return WRITE_REG_FAIL;
	}
	status = ioctl(fptr,I2C_SLAVE,LIGHT_SENSOR_I2C_ADDRESS);
	if(status !=0){
		perror("IOCTL function failed");
		return WRITE_REG_FAIL;
	}
	n = write(fptr,buffer,2);
	if(n ==-1){
		perror("Write not successfull");
		return WRITE_REG_FAIL;
	}
	close(fptr);
	free(buffer);
	return WRITE_REG_SUCCESS;
}
/***********************************************************************************************  
 * @brief write two register in light sensor 
 *
 *Responsible for writing into two register of light sensor
 *
 * @param address: address of  register  of light sensor
 * @param data: data to be written into register of light sensor
 *
 * @return status of I2C operation
 *********************************************************************************************/


sensor_status_t light_write_two_reg(uint8_t address, uint16_t data){
	int status =0;
	int fptr = 0;
	int n = 0;
	uint8_t *buffer = malloc(sizeof(uint8_t) *5);
	*(buffer + 0) = (address | COMMAND_BIT | WORD_OPERATION_BIT);
	*(buffer + 1) = ((uint8_t)(data) );
	*(buffer + 2) = ((uint8_t)(data >>8));
	fptr = open(light_i2c_path_name,O_RDWR);	
	if(fptr == -1){
		perror("Error in opening the file");
		return WRITE_REG_FAIL;
	}
	status = ioctl(fptr,I2C_SLAVE,LIGHT_SENSOR_I2C_ADDRESS);
	if(status !=0){
		perror("IOCTL function failed");
		return WRITE_REG_FAIL;
	}
	n = write(fptr,buffer,3);
	if(n ==-1){
		perror("Write not successfull");
		return WRITE_REG_FAIL;
	}
	close(fptr);
	free(buffer);
	return WRITE_REG_SUCCESS;
}

/***********************************************************************************************  
 * @brief Read register in light sensor 
 *
 *Responsible for reading from register of light sensor
 *
 * @param address: address of  register  of light sensor
 * @param data: data to be read from register of light sensor
 * @param command: Bits to be read from particular register from light sensor
 * @return status of I2C operation
 *********************************************************************************************/


sensor_status_t light_read_reg(uint8_t address, uint8_t *data,read_cmd_t command){
	int status =0;
	int fptr = 0;
	int n = 0;
	address = address | COMMAND_BIT;
	fptr = open(light_i2c_path_name,O_RDWR);	
	if(fptr == -1){
		perror("Error in opening the file");
		return WRITE_REG_FAIL;
	}
	status = ioctl(fptr,I2C_SLAVE,LIGHT_SENSOR_I2C_ADDRESS);
	if(status !=0){
		perror("IOCTL function failed");
		return WRITE_REG_FAIL;
	}
	n =write(fptr,&address,1);
	if(n==-1){
		perror("Write not successfull");
		return WRITE_REG_FAIL;
	}

	n = read(fptr,(data ),1);
	if(n ==-1){
		perror("Read not successfull");
		return READ_REG_FAIL;
	}

	if(command == INTEGRATION_TIME){
		*data = *data & 0x03;
	}
	else if(command == GAIN){
		*data = (*data & 0x10) >> 4;
	}
	else{
		*data = *data;
	}

	close(fptr);
	return READ_REG_SUCCESS;

}
/***********************************************************************************************
 * @brief Read two register in light sensor 
 *
 *Responsible for reading from two  register of light sensor
 *
 * @param address: address of  register  of light sensor
 * @param data: data to be read from register of light sensor
 * @param command: Bits to be read from particular register from light sensor
 * @return status of I2C operation
 *********************************************************************************************/


sensor_status_t read_two_reg(uint8_t address, uint8_t *data){
	int status =0;
	int fptr = 0;
	int n =0;
	address = address | COMMAND_BIT | WORD_OPERATION_BIT;
	fptr = open(light_i2c_path_name,O_RDWR);
	if(fptr ==-1){
		perror("Error in opening the file");
		return WRITE_REG_FAIL;
	}
	status = ioctl(fptr,I2C_SLAVE,LIGHT_SENSOR_I2C_ADDRESS);
	if(status !=0){
		perror("IOCTL function failed");
		return WRITE_REG_FAIL;

	}
	n =write(fptr,&address,1);
	if(n==-1){
		perror("Write not successfull");
		return WRITE_REG_FAIL;

	}
	n = read(fptr,data,2);
	if(n == -1){
		perror("read not successfull");
		return READ_REG_FAIL;

	}
	close(fptr);
	return READ_REG_SUCCESS;
}

/***********************************************************************************************
 * @brief Read lux values 
 *
 *Responsible for reading lux value from light sensor
 *
 * @param null
 * @return double: Returns the lux values from light sensor
 *********************************************************************************************/


double read_lux(){
	pthread_mutex_lock(&i2c_mutex);

	uint8_t *data = malloc(sizeof(uint8_t)*2);
	int status = 0;
	status = read_two_reg(DATA1LOW_REG,data);
	if(status != READ_REG_SUCCESS){
		perror("Reading Channel 1 data register failed");
		free(data);
		pthread_mutex_unlock(&i2c_mutex);
		return READ_LIGHT_ERROR;
	}
	unsigned int ch1Int = (*(data +1)<<8) | *(data +0);
	status = read_two_reg(DATA0LOW_REG,data);
	if(status !=READ_REG_SUCCESS){
		perror("Reading Channel 0 data register failed");
		free(data);
		pthread_mutex_unlock(&i2c_mutex);
		return READ_LIGHT_ERROR;
	}
	unsigned int ch0Int =  (*(data +1)<<8) | *(data +0);

	status = read_two_reg(DATA0LOW_REG,data);
	if(status !=READ_REG_SUCCESS){
		perror("Reading channel 0 data register failed(floating values)");
		free(data);
		pthread_mutex_unlock(&i2c_mutex);
		return READ_LIGHT_ERROR;
	}
	float ch0 = (float)( (*(data +1)<<8) | *(data +0));

	status = read_two_reg(DATA1LOW_REG,data);
	if(status != READ_REG_SUCCESS){
		perror("Reading channel 1 data register failed(floating value)");
		free(data);
		pthread_mutex_unlock(&i2c_mutex);
		return READ_LIGHT_ERROR;
	}
	float ch1 = (float)( (*(data +1)<<8) | *(data +0));

	status = light_read_reg(TIMING_REG,data,INTEGRATION_TIME);
	if(status!= READ_REG_SUCCESS){
		perror("Reading integration time failed");
		free(data);
		pthread_mutex_unlock(&i2c_mutex);
		return READ_LIGHT_ERROR;
	}
	switch (*data)
	{
		case INTEGRATION_13_7:

			if ((ch1Int >= 5047) || (ch0Int >= 5047)) 
			{
				return 1.0/0.0;
			}
			break;
		case INTEGRATION_101:
			if ((ch1Int >= 37177) || (ch0Int >= 37177)) 
			{
				return 1.0/0.0;
			}
			break;
		case INTEGRATION_402:
			if ((ch1Int >= 65535) || (ch0Int >= 65535))
			{ 
				return 1.0/0.0;
			}
			break;
	}
	float ratio = ch1/ch0;
	status = light_read_reg(TIMING_REG,data,INTEGRATION_TIME);
	if(status!=READ_REG_SUCCESS){
		perror("Reading integration time failed");
		free(data);
		pthread_mutex_unlock(&i2c_mutex);
		return READ_LIGHT_ERROR;
	}
	switch (*data)
	{
		case INTEGRATION_13_7:
			ch0 *= 1/0.034;
			ch1 *= 1/0.034;
			break;
		case INTEGRATION_101:
			ch0 *= 1/0.252;
			ch1 *= 1/0.252;
			break;
		case INTEGRATION_402:
			ch0 *= 1;
			ch1 *= 1;
			break;

	}
	status = light_read_reg(TIMING_REG,data,GAIN);
	if(status!=READ_REG_SUCCESS){
		perror("Reading integration time failed");
		free(data);
		pthread_mutex_unlock(&i2c_mutex);
		return READ_LIGHT_ERROR;
	}

	if (*data ==( (LOW_GAIN)>>4U)) 
	{
		ch0 *= 16;
		ch1 *= 16;
	}

	float luxVal = 0.0;
	if (ratio <= 0.5)
	{
		luxVal = (0.0304 * ch0) - ((0.062 * ch0) * (pow((ch1/ch0), 1.4)));
	}  
	else if (ratio <= 0.61)
	{
		luxVal = (0.0224 * ch0) - (0.031 * ch1);
	}
	else if (ratio <= 0.8)
	{
		luxVal = (0.0128 * ch0) - (0.0153 * ch1);
	}
	else if (ratio <= 1.3)
	{
		luxVal = (0.00146 * ch0) - (0.00112*ch1);
	}

	free(data);
	pthread_mutex_unlock(&i2c_mutex);

	return luxVal;
//	return 0;



}

/***********************************************************************************************  
 * @brief Power on light sensor 
 *
 *Responsible for turning On light sensor before reading any data
 *
 * @param  null
 *
 * @return null
 *********************************************************************************************/


sensor_status_t light_sensor_power_on(){
	pthread_mutex_lock(&i2c_mutex);

	sensor_status_t status;
	status = light_write_reg(CONTROL_REG,0x03);
	if(status!=WRITE_REG_SUCCESS){
	perror("Writing power on bit in Control register failed");
	return WRITE_REG_FAIL; 
	}
	
	pthread_mutex_unlock(&i2c_mutex);
	return WRITE_REG_SUCCESS;
}


/***********************************************************************************************  
 * @brief Set Integration Time 
 *
 *Responsible for setting up integration time based on INTEGRATION values
 *
 * @param INTEGRATION
 *
 * @return status of I2C operation
 *********************************************************************************************/
sensor_status_t set_integration_time(uint8_t INTEGRATION)
{
	pthread_mutex_lock(&i2c_mutex);
	uint8_t *data = malloc(sizeof(uint8_t));
	sensor_status_t status = light_read_reg(TIMING_REG,data,NONE); // check data arg
	*data &= ~0x03;	//check if required
	if(status != READ_REG_SUCCESS){
		perror("Reading register for time integration failed");
		free(data);
		pthread_mutex_unlock(&i2c_mutex);
		return READ_REG_FAIL;
		//Should set a flag and return as required: error/success, to avoid deadlock
	}

	if( INTEGRATION == INTEGRATION_13_7 )
	{
		*data |= 0x00;
	}
	else if( INTEGRATION == INTEGRATION_101 )
	{
		*data |= 0x01;
	}
	else if( INTEGRATION == INTEGRATION_402 )
	{
		*data |= 0x02;
	}

	status = light_write_reg(TIMING_REG, *data); //check data arg
	if(status != WRITE_REG_SUCCESS){
		perror("Writing register for integration time failed");
		free(data);
		pthread_mutex_unlock(&i2c_mutex);
		return WRITE_REG_FAIL;
	}

	free(data);
	pthread_mutex_unlock(&i2c_mutex);
	return WRITE_REG_SUCCESS;
}

/***********************************************************************************************  
 * @brief Read identification register 
 *
 *Responsible for reading identification register 
 *
 * @param null
 *
 * @return uint8_t returns the identification value
 *********************************************************************************************/
sensor_status_t read_identification_reg(uint8_t *data){
	sensor_status_t status = 0;
	pthread_mutex_lock(&i2c_mutex);
	
	//uint8_t *data = malloc(sizeof(uint8_t));
	status = light_read_reg(ID_REG,data,ALL);
	if(status != READ_REG_SUCCESS)
	{
		perror("Reading register for identification failed");
		pthread_mutex_unlock(&i2c_mutex);
		return READ_REG_FAIL;
		//Should set a flag and return as required: error/success, to avoid deadlock
	}
	*data = *data >>4;
	pthread_mutex_unlock(&i2c_mutex);
	return READ_REG_SUCCESS;



}

/***********************************************************************************************  
 * @brief Get Integration Time 
 *
 *Responsible for retrieivng set integration 
 *
 * @param null
 *
 * @return status of I2C operation
 *********************************************************************************************/

// i think this function is not required
sensor_status_t get_integration_time(uint8_t *data)
{
	pthread_mutex_lock(&i2c_mutex);
	//uint8_t *data = malloc(sizeof(uint8_t));
	sensor_status_t status = light_read_reg(TIMING_REG,data,INTEGRATION_TIME); // check data arg
	if(status != READ_REG_SUCCESS){
		perror("Reading register for time integration failed");
		pthread_mutex_unlock(&i2c_mutex);
		return READ_REG_FAIL;
	}
	// check if printing is OK!
	/*if( *data == 0x00 )
		printf("\nIntegration time = 13.7ms");
	else if( *data == 0x01 )
		printf("\nIntegration time = 101ms");
	else if( *data == 0x02 )
		printf("\nIntegration time = 402ms");
*/
	pthread_mutex_unlock(&i2c_mutex);
	return READ_REG_SUCCESS;

}


/***********************************************************************************************  
 * @brief Set gain 
 *
 * Responsible for setting gain values. Switches gain between low gain and high gain modes. 
 * Writing a 0 selects low gain (1x); writing a 1 selects high gain (16x). 
 *
 * @param gainlevel
 *
 * @return status of I2C operation
 *********************************************************************************************/
sensor_status_t set_gain( int gainlevel )
{
	pthread_mutex_lock(&i2c_mutex);
	uint8_t *data = malloc(sizeof(uint8_t));
	sensor_status_t status = light_read_reg(TIMING_REG,data,NONE); // check data arg
	if(status != READ_REG_SUCCESS){
		perror("Reading register for Setting gain failed");
		free(data);
		pthread_mutex_unlock(&i2c_mutex);
		return READ_REG_FAIL;
	}
	if( gainlevel == LOW_GAIN )
		*data &= ~0x10;
	else if( gainlevel == HIGH_GAIN )
		*data |= 0x10;

	status = light_write_reg(TIMING_REG, *data); //check data arg
	if(status != WRITE_REG_SUCCESS){
		perror("Writing register for Setting gain failed");
		free(data);
		pthread_mutex_unlock(&i2c_mutex);
		return WRITE_REG_FAIL;
	}
	free(data);
	pthread_mutex_unlock(&i2c_mutex);
	return WRITE_REG_SUCCESS;
}
/***********************************************************************************************  
 * @brief Get gain 
 *
 *Responsible for retrieivng gain
 *
 * @param null
 *
 * @return status of I2C operation
 *********************************************************************************************/

// i think this function is not required
sensor_status_t get_gain(uint8_t *data)
{
	pthread_mutex_lock(&i2c_mutex);
	//uint8_t *data = malloc(sizeof(uint8_t));
	sensor_status_t status = light_read_reg(TIMING_REG,data,GAIN); // check data arg
	if(status != READ_REG_SUCCESS){
		perror("Reading register for gain failed");
		pthread_mutex_unlock(&i2c_mutex);
		return READ_REG_FAIL;
	}
	// check if printing is OK!
	/*if( *data == 0x00 )
		printf("\nIntegration time = 13.7ms");
	else if( *data == 0x01 )
		printf("\nIntegration time = 101ms");
	else if( *data == 0x02 )
		printf("\nIntegration time = 402ms");
*/
	pthread_mutex_unlock(&i2c_mutex);
	return READ_REG_SUCCESS;

}


/***********************************************************************************************  
 * @brief Configure Interrupt Controller Register
 *
 * Enables/Disables Interrupt through Interrupt Controller Register
 *
 * @param interrupt_cmd_t command
 *
 * @return status of I2C operation
 *********************************************************************************************/
sensor_status_t config_interrupt_ctrl_reg( uint8_t command )
{
	pthread_mutex_lock(&i2c_mutex);
	uint8_t *data = malloc(sizeof(uint8_t));
	sensor_status_t status = light_read_reg(INTERRUPT_REG,data,NONE);	
	if(status != READ_REG_SUCCESS){
		perror("Reading register for Configuring Interrupt failed");
		free(data);
		pthread_mutex_unlock(&i2c_mutex);
		return READ_REG_FAIL;
	}

	if (command == INTERRUPT_OFF )
		*data &= ~0x30;
	else if (command == INTERRUPT_ON )
		*data |= 0x10;

	status = light_write_reg(INTERRUPT_REG, *data); //check data arg
	if(status != WRITE_REG_SUCCESS){
		perror("Writing register for Configuring Interrupt failed");
		free(data);
		pthread_mutex_unlock(&i2c_mutex);
		return WRITE_REG_FAIL;
	}
	free(data);
	pthread_mutex_unlock(&i2c_mutex);
	return WRITE_REG_SUCCESS;
}

/***********************************************************************************************  
 * @brief Get value of Interrupt control Register 
 *
 *Responsible for retrieving value of Interrupt Control Register
 *
 * @param null
 *
 * @return status of I2C operation
 *********************************************************************************************/

// i think this function is not required
sensor_status_t get_interrupt_ctrl_reg(uint8_t *data)
{
	pthread_mutex_lock(&i2c_mutex);
	//uint8_t *data = malloc(sizeof(uint8_t));
	sensor_status_t status = light_read_reg(INTERRUPT_REG,data,NONE); // check data arg
	if(status != READ_REG_SUCCESS){
		perror("Reading register for gain failed");
		pthread_mutex_unlock(&i2c_mutex);
		return READ_REG_FAIL;
	}

	// check if printing is OK!
	/*if( *data == 0x00 )
		printf("\nIntegration time = 13.7ms");
	else if( *data == 0x01 )
		printf("\nIntegration time = 101ms");
	else if( *data == 0x02 )
		printf("\nIntegration time = 402ms");
*/
	pthread_mutex_unlock(&i2c_mutex);
	return READ_REG_SUCCESS;

}
/***********************************************************************************************  
 * @brief Write low threshold
 *
 *Write to Registers THRESLOWLOW and THRESHLOWHIGH provide the low byte and
 * high byte, respectively, of the lower interrupt threshold 
 *
* @param uint16_t *data
 *
 * @return status of I2C operation
 *********************************************************************************************/
sensor_status_t set_low_threshold(uint16_t data)
{
	sensor_status_t status =0;
	pthread_mutex_lock(&i2c_mutex);
	status = light_write_two_reg(THRESHLOWLOW_REG,data); //check data arg
	if(status != WRITE_REG_SUCCESS){
		perror("Writing register for Configuring low threshold register failed");
		//free(data);
		pthread_mutex_unlock(&i2c_mutex);
		return WRITE_REG_FAIL;
	}
	//free(data);
	pthread_mutex_unlock(&i2c_mutex);
	return WRITE_REG_SUCCESS;

}

/***********************************************************************************************  
 * @brief Read low threshold
 *
 * Registers THRESHLOWLOW and THRESHLOWHIGH provide the low byte and
 * high byte, respectively, of the lower interrupt threshold
 *
 * @param uint16_t *data
 *
 * @return status of I2C operation
 *********************************************************************************************/
sensor_status_t get_low_threshold(uint16_t *data)
{
	pthread_mutex_lock(&i2c_mutex);
	uint8_t *data_low = malloc(sizeof(uint8_t));
	sensor_status_t status = light_read_reg(THRESHLOWLOW_REG, data_low, NONE);	
	if(status != READ_REG_SUCCESS){
		perror("Reading register for getting low threshold value failed");
		free(data_low);
		pthread_mutex_unlock(&i2c_mutex);
		return READ_REG_FAIL;
	}
	//*data <<= 8;

	uint8_t *data_high = malloc(sizeof(uint8_t));
	status = light_read_reg(THRESHLOWHIGH_REG,data_high, NONE);
	if(status != READ_REG_SUCCESS){
		perror("Reading register for getting low threshold value failed");
		free(data_low);
		free(data_high);
		pthread_mutex_unlock(&i2c_mutex);
		return READ_REG_FAIL;
	}
	*data = *data_high << 8 | *data_low ;
	free(data_low);
	free(data_high);
	pthread_mutex_unlock(&i2c_mutex);
	return WRITE_REG_SUCCESS;
}

/***********************************************************************************************  
 * @brief Write high threshold
 *
 *Write to Registers THRESHIGHLOW and THRESHHIGHHIGH provide the low byte and
 * high byte, respectively, of the lower interrupt threshold 
 *
* @param uint16_t *data
 *
 * @return status of I2C operation
 *********************************************************************************************/
sensor_status_t set_high_threshold(uint16_t data)
{
	sensor_status_t status =0;
	pthread_mutex_lock(&i2c_mutex);
	status = light_write_two_reg(THRESHHIGHLOW_REG,data); //check data arg
	if(status != WRITE_REG_SUCCESS){
		perror("Writing register for Configuring high threshold register failed");
		//free(data);
		pthread_mutex_unlock(&i2c_mutex);
		return WRITE_REG_FAIL;
	}
	//free(data);
	pthread_mutex_unlock(&i2c_mutex);
	return WRITE_REG_SUCCESS;


}
/***********************************************************************************************  
 * @brief Read high threshold
 *
 * Registers THRESHIGHLOW and THRESHHIGHHIGH provide the low byte and
 * high byte, respectively, of the lower interrupt threshold
 *
* @param uint16_t *data
 *
 * @return status of I2C operation
 *********************************************************************************************/
sensor_status_t get_high_threshold(uint16_t *data)
{
	pthread_mutex_lock(&i2c_mutex);
	uint8_t *data_low = malloc(sizeof(uint8_t));
	sensor_status_t status = light_read_reg(THRESHHIGHLOW_REG, data_low, NONE);	
	if(status != READ_REG_SUCCESS){
		perror("Reading register for getting high threshold value failed");
		free(data_low);
		pthread_mutex_unlock(&i2c_mutex);
		return READ_REG_FAIL;
	}
	//*data <<= 8;

	uint8_t *data_high = malloc(sizeof(uint8_t));
	status = light_read_reg(THRESHHIGHHIGH_REG,data_high, NONE);
	if(status != READ_REG_SUCCESS){
		perror("Reading register for getting high threshold value failed");
		free(data_low);
		free(data_high);
		pthread_mutex_unlock(&i2c_mutex);
		return READ_REG_FAIL;
	}
	*data = *data_high << 8 | *data_low ;
	free(data_low);
	free(data_high);
	pthread_mutex_unlock(&i2c_mutex);
	return WRITE_REG_SUCCESS;
}


/********************************************************************************************
*					FILENAME: logger.c
**********************************************************************************************/
/* Title: logger.c
 * Brief: Responsible for providing various helper function to support logger functionality
 * Author: Tanmay Chaturvedi, Vikrant Waje
 * Date Created: March 16, 2019
 * Course: Advanced Embedded Software Development
 * Project: 1

 * Reference[1]: http://www.
 * 
 * */
/****************************************************************************************
*					HEADER FILE SECTION
*****************************************************************************************/

#include"logger.h" 

/**************************************************************************************
*					     MACROS
****************************************************************************************/

/**************************************************************************************
*					FUNCTION DEFINITION
***************************************************************************************/






/*********************************************************************************************
 *					FILENAME: server.c
 **********************************************************************************************/

/* Title: server.c
 * Brief: Responsible for providing various helper functions for setting up the server side
 * Author: Tanmay Chaturvedi, Vikrant Waje
 * Date Created: March 10, 2019
 * Course: Advanced Embedded Software Development
 * 
 * This program demonsrates IPC using Sockets for Project 1.
 * This is the Server Side.
 * Reference[1]: http://www.it.uom.gr/teaching/distrubutedSite/dsIdaLiu/labs/lab2_1/sockets.html
 * Reference[2]: https://www.youtube.com/watch?v=pFLQmnmDOo
 */

/*********************************************************************************************
 *					HEADER SECTION
 **********************************************************************************************/
#include"server.h"
#include"temp_sensor.h"

/********************************************************************************************
 *					GLOBAL VARIABLE SECTION
 *********************************************************************************************/
mqd_t mqdes_server;
client_request_t client_request;
request_cmd_t client_temperature_type_request;
client_data_t client_data;


mqd_t mqdes_heartbeat;
heartbeat_flag_t heartbeat_flag;
heartbeat_data_t heartbeat_server_data_src;
pthread_mutex_t heartbeat_queue_mutex;

int sock_stat;
/******************************************************************************************
 *					FUNCTION DEFINITION
 ********************************************************************************************/
/*******************************************************************************************
 * @brief Communicate with external client
 *
 * After connecting with external client, receives command from client and call respective
 * function.

 * @param null
 *
 * @return 0 if error, 1 if success
 ********************************************************************************************/
int server_establish()
{

	/*Server Thread*/
	int recv_stat;
	char str[30];
	int send_data_len = 0;

	int socket_flag = 0;	/*Not Connected*/
	if(socket_setup() != SOCKET_SETUP_SUCCESS){
		perror("Error in setup of socket");
	}
	if( socket_connect() == SOCKET_CONNECT_SUCCESS )
	{
		socket_flag = 1;
	}

	else{
		perror("Error in socket connect");

	}

	while(socket_flag == 1)
	{

		if(heartbeat_flag.heartbeat_server_flag == 1){
			heartbeat_server_data_src.timestamp = record_time(); 
			heartbeat_server_data_src.log_level = 1;
			strcpy(heartbeat_server_data_src.source_ID,"SERVER_TASK ALIVE");
			pthread_mutex_lock(&heartbeat_queue_mutex);
			if(mq_send(mqdes_heartbeat,(char *)&heartbeat_server_data_src,sizeof(heartbeat_data_t),0)==-1){
				perror("Sending server heartbeat to main unsuccessfull");
			}
			pthread_mutex_unlock(&heartbeat_queue_mutex);

			heartbeat_flag.heartbeat_server_flag =0;


		}


		//send heartbeat
		memset(str,0,sizeof(str));
		if (recv_stat =(recv(sock_stat, str,sizeof(str),0)<0))
		{
		
	//	printf("\n\rstat %d",recv_stat);

			
			perror("read error");
			socket_flag = 0;
			break;
		}




		else{
			//RxBuf[0] = str;

			if(strcmp(str,"1") == 0)
			{
				printf("\n\rtemp func received ");
				/*call temp_read()*/
				client_temperature_type_request = REQUEST_CELSIUS;
				client_request.client_get_temp_flag = 1;
				//	strcpy(client_data.sensor_string,"temp: ");
				//	client_data.sensor_data = 26.0;
				if(mq_receive(mqdes_server,(char *)&client_data,sizeof(client_data_t),NULL) ==-1){
					perror("Reception of data from temperature thread unsuccessfull");	
				}	
				if((send(sock_stat,&client_data ,sizeof(client_data_t),0))<0){
					perror("Error while sending temperature structure. Please try again!!");
					client_request.client_get_temp_flag = 0;
				} 


			}

			else if(strcmp(str,"2") == 0)
			{
				printf("\n\rtemp func received ");
				/*call temp_read()*/
				client_temperature_type_request = REQUEST_KELVIN;
				client_request.client_get_temp_flag = 1;
				//	strcpy(client_data.sensor_string,"temp: ");
				//	client_data.sensor_data = 26.0;
				if(mq_receive(mqdes_server,(char *)&client_data,sizeof(client_data_t),NULL) ==-1){
					perror("Reception of data from temperature thread unsuccessfull");	
				}	
				if((send(sock_stat,&client_data ,sizeof(client_data_t),0))<0){
					perror("Error while sending temperature structure. Please try again!!");
					client_request.client_get_temp_flag = 0;
				} 


			}

			else if(strcmp(str,"3") == 0)
			{
				printf("\n\rtemp func received ");
				/*call temp_read()*/
				client_temperature_type_request = REQUEST_FAHRENHEIT;
				client_request.client_get_temp_flag = 1;
				//	strcpy(client_data.sensor_string,"temp: ");
				//	client_data.sensor_data = 26.0;
				if(mq_receive(mqdes_server,(char *)&client_data,sizeof(client_data_t),NULL) ==-1){
					perror("Reception of data from temperature thread unsuccessfull");	
				}	
				if((send(sock_stat,&client_data ,sizeof(client_data_t),0))<0){
					perror("Error while sending temperature structure. Please try again!!");
					client_request.client_get_temp_flag = 0;
				} 


			}

			else if(strcmp(str,"4") == 0)
			{
				printf("\n\rLight val func received ");
				/*call light_val()*/
				client_request.client_get_lux_flag = 1;
				//strcpy(client_data.sensor_string,"light: ");
				//client_data.sensor_data = 1533.0;
				if(mq_receive(mqdes_server,(char *)&client_data,sizeof(client_data_t),NULL) ==-1){
					perror("Reception of data from light sensor thread unsuccessfull");	
				}	

				if((send(sock_stat,&client_data ,sizeof(client_data_t),0))<0){
					perror("Error while sending light structure. Please try again!!");
					client_request.client_get_lux_flag = 0;
				} 
			}

			else if(strcmp(str,"5") == 0)
			{
				printf("LED func received \n");
				/*System State func()*/
				led_on(RED_LED);
				led_on(YELLOW_LED);
				led_on(BLUE_LED);
				led_on(GREEN_LED);
			}	

			else if(strcmp(str,"6") == 0)
			{
				printf("LED func received \n");
				/*System State func()*/
				led_off(RED_LED);
				led_off(YELLOW_LED);
				led_off(BLUE_LED);
				led_off(GREEN_LED);
			}


			else if(strcmp(str,"7") == 0)
			{
				printf("Closing Socket \n");
				socket_flag = 0;
				//		close(socket_fd);	

				exit;
			}

			else 
			{
				printf("Unrecognized command. Please try again!\n");
			}	
		}
	}



}






/*******************************************************************************************
 * @brief Socket Setup Routines
 *
 * Call the socket(), bind() and returns 1 on successful setup

 * @param null
 *
 * @return 0 if error, 1 if success
 ********************************************************************************************/
server_response_t socket_setup()
{
	int sock_opt_true = 1;
	int listen_status = 0;
	socket_fd = socket(AF_INET, SOCK_STREAM,0);

	if(socket_fd < 0)
	{
		perror("Server: socket()");
		return SOCKET_FAIL;
	}

	server_addr.sin_family = AF_INET;
	server_addr.sin_addr.s_addr = INADDR_ANY;
	server_addr.sin_port = htons(PORT_NUM);

	if(bind(socket_fd, (struct sockaddr *)&server_addr, sizeof(server_addr)))
	{
		perror("Server: bind()");
		return BIND_FAIL;
	}

	listen_status=listen(socket_fd, NO_OF_CLIENT);
	if(listen_status == -1){
		LISTEN_FAIL;}

	return SOCKET_SETUP_SUCCESS;
}


/*******************************************************************************************
 * @brief Socket Listening Routines
 *
 * Call the listen() and accept() and returns 1 on successful connection
 * with an external client

 * @param null
 *
 * @return 0 if error, 1 if success
 ********************************************************************************************/
server_response_t socket_connect(void)
{	

	sock_stat = accept(socket_fd, (struct sockaddr *) 0,0);

	if( sock_stat == -1)
	{
		perror("Server: accept()");
		return ACCEPT_FAIL;				
	}

	return SOCKET_CONNECT_SUCCESS;
}



/********************************************************************************************
*					FILENAME: timer.c
**********************************************************************************************/
/* Title: timer.c
 * Brief: Responsible for providing various helper function needed for logger and heartbeat
 * Author: Tanmay Chaturvedi, Vikrant Waje
 * Date Created: March 16, 2019
 * Course: Advanced Embedded Software Development
 * Project: 1

 * Reference[1]: Professor's slides and notes 
 * 
 * */
/****************************************************************************************
*					HEADER FILE SECTION
*****************************************************************************************/
#include "timer.h"

/****************************************************************************************
*				GLOBAL VARIABLE SECTION
*****************************************************************************************/
int log_timer_flag;
logger_flag_t logger_flag;
heartbeat_flag_t heartbeat_flag;
bool logger_heartbeat_indicator;
bool light_heartbeat_indicator ;
bool temp_heartbeat_indicator ;
bool system_shutdown_flag;
bool system_shutdown_main_flag;
/***************************************************************************************
*				FUNCTION DEFINITION
*****************************************************************************************/
/***********************************************************************************************
 * @brief logger  timer handler
 *
 * Handler that executes periodically to generate logging interval
 * @param null
 *
 * @return null
 *********************************************************************************************/
void log_timer_handler(int num){

	//log_timer_flag = 1;
	logger_flag.log_temp_sensor_flag =1;
	logger_flag.log_light_sensor_flag =1;
//	printf("\n\rlogger");
}
/***********************************************************************************************
 * @brief heartbeat timer handler
 *
 * Handler that executes periodically to generate heartbeat interval
 * @param null
 *
 * @return null
 *********************************************************************************************/
void heartbeat_timer_handler(int num){

	heartbeat_flag.heartbeat_temp_sensor_flag = 1;
	heartbeat_flag.heartbeat_light_sensor_flag = 1;
	heartbeat_flag.heartbeat_logger_flag =1;
	heartbeat_flag.heartbeat_server_flag =1;

//	printf("\n\rHi heartbeat");
}

/***********************************************************************************************
 * @brief Create log timer
 *
 * Responsible for creating log timer which expires periodically to collect sensor information an
 * nd socket status that is logged into log file
 * @param null
 *
 * @return bool: Indicates whether intiialisation was successfull or novoidt
 *********************************************************************************************/
bool create_log_timer(){
	signal_specification.sigev_notify = SIGEV_THREAD;
	signal_specification.sigev_notify_function = &log_timer_handler;
	signal_specification.sigev_value.sival_ptr = "State collection timer";
	timer_create(CLOCK_REALTIME,&signal_specification,&log_timer_id);
	timer_setting.it_value.tv_sec =1;
	timer_setting.it_value.tv_nsec = 0;
	timer_setting.it_interval.tv_sec = 5;
	timer_setting.it_interval.tv_nsec = 0;
	timer_settime(log_timer_id,0,&timer_setting,NULL);
	return 0;
}

/***********************************************************************************************
 * @brief Create heartbeat timer
 *
 * Responsible for generating heartbeat for each of the four thread
 * @param null
 *
 * @return bool: Indicates whether intiialisation was successfull or not
 *********************************************************************************************/
bool create_heartbeat_timer(){

	signal_specification.sigev_notify = SIGEV_THREAD;
	signal_specification.sigev_notify_function = &heartbeat_timer_handler;
	signal_specification.sigev_value.sival_ptr = "Heartbeat timer";
	timer_create(CLOCK_REALTIME,&signal_specification,&heartbeat_timer_id);
	timer_setting.it_value.tv_sec =1;
	timer_setting.it_value.tv_nsec = 0;
	timer_setting.it_interval.tv_sec =3 ;
	timer_setting.it_interval.tv_nsec = 0;
	timer_settime(heartbeat_timer_id,0,&timer_setting,NULL);
	return 0;
}

/***********************************************************************************************
 * @brief heartbeat recovery timer handler
 *
 * Handler that executes to check for heartbeat recovery
 * @param num
 *
 * @return null
 *********************************************************************************************/
void heartbeat_recovery_timer_handler(int num){
	if(logger_heartbeat_indicator!=1 || light_heartbeat_indicator!=1 || temp_heartbeat_indicator!=1){
			printf("\n\rHeartbeat recovery sequence initiated");
			system_shutdown_flag =1;
			system_shutdown_main_flag =1;
		}
	else{
	logger_heartbeat_indicator = 0;
	light_heartbeat_indicator = 0;
	temp_heartbeat_indicator =0;
	}
	

//	printf("\n\rHi heartbeat");
}
/***********************************************************************************************
 * @brief Create heartbeat recovery timer
 *
 * Responsible for recovery of system
 * @param null
 *
 * @return bool: Indicates whether intiialisation was successfull or not
 *********************************************************************************************/
bool create_heartbeat_recovery_timer(){

	signal_specification.sigev_notify = SIGEV_THREAD;
	signal_specification.sigev_notify_function = &heartbeat_recovery_timer_handler;
	signal_specification.sigev_value.sival_ptr = "Heartbeat Recovery timer";
	timer_create(CLOCK_REALTIME,&signal_specification,&heartbeat_recovery_timer_id);
	timer_setting.it_value.tv_sec =7;
	timer_setting.it_value.tv_nsec = 0;
	timer_setting.it_interval.tv_sec =15 ;
	timer_setting.it_interval.tv_nsec = 0;
	timer_settime(heartbeat_recovery_timer_id,0,&timer_setting,NULL);
	return 0;
}
/***********************************************************************************************
 * @brief Record the timestamp value
 *
 * Responsible for recording the timestamp value
 * @param null
 *
 * @return double: returns the recorded time value
 *********************************************************************************************/
double record_time(){
	struct timespec timestamp;
	 clock_gettime(CLOCK_MONOTONIC,&timestamp);
	return((timestamp.tv_sec * (SEC_TO_MILLISEC))+ (timestamp.tv_nsec/(NANOSEC_TO_MILLISEC)) );	//Convert into milliseconds


}

/********************************************************************************************
*					FILENAME: synchronization.c
**********************************************************************************************/
/* Title: synchronization.c
 * Brief: Responsible for providing various synchronization constructs
 * Author: Tanmay Chaturvedi, Vikrant Waje
 * Date Created: March 16, 2019
 * Course: Advanced Embedded Software Development
 * Project: 1
 * 
 * 
 * */
/****************************************************************************************
*					HEADER FILE SECTION
*****************************************************************************************/

#include"synchronization.h" 

/**************************************************************************************
*					     MACROS
****************************************************************************************/


/**************************************************************************************
*					FUNCTION DEFINITION
***************************************************************************************/






/********************************************************************************************
 *					FILENAME: led.c
 **********************************************************************************************/
/* Title: led.c
 * Brief: Responsible for providing various helper function needed for initializing and blinking the led
 * Author: Tanmay Chaturvedi, Vikrant Waje
 * Date Created: March 16, 2019
 * Course: Advanced Embedded Software Development
 * Project: 1

 * Reference[1]: http://www.teachmemicro.com/beaglebone-black-blink-led-using-c/#
 * 
 * 
 * */
/****************************************************************************************
 *					HEADER FILE SECTION
 *****************************************************************************************/
#include"led.h"

/**************************************************************************************
 *					     MACROS
 ****************************************************************************************/

/**************************************************************************************
 *					     GLOBAL VARIABLES
 ****************************************************************************************/


/**************************************************************************************
 *					FUNCTION DEFINITION
 ***************************************************************************************/
/*******************************************************************************************
 * @brief Initialise LED gpio pins
 *
 * Initialise GPIO pins as output
 *
 * @param gpio_pin: GPIO pin whose direction is to be set
 *
 * @return null
 ********************************************************************************************/

void led_init(uint8_t gpio_pin[]){
	FILE *export_file = NULL;
	FILE *IO_direction = NULL;
	
	export_file = fopen("/sys/class/gpio/export","w");	//go to export directory
	fwrite(gpio_pin,1,sizeof(*gpio_pin),export_file);
	fclose(export_file);
	
	if(strcmp(gpio_pin,"49")==0){
	IO_direction = fopen("/sys/class/gpio/gpio49/direction","w");
}

	if(strcmp(gpio_pin,"117")==0){
	IO_direction = fopen("/sys/class/gpio/gpio117/direction","w");
}
	if(strcmp(gpio_pin,"115")==0){
	IO_direction = fopen("/sys/class/gpio/gpio115/direction","w");
}
	if(strcmp(gpio_pin,"44")==0){
	IO_direction = fopen("/sys/class/gpio/gpio44/direction","w");
}
	uint8_t *str = "out";
	fwrite(str,1,sizeof(str),IO_direction);
	fclose(IO_direction);
	
}


/*******************************************************************************************
 * @brief Turn ON the led
 *
 * Turn the given LED ON, i.e output logic 1
 *
 * @param gpio_pin: GPIO pin which is to be turned ON
 *
 * @return null
 ********************************************************************************************/

void led_on(uint8_t gpio_pin[]){
	uint8_t value[] ="1";
	FILE *IO_value = NULL;
	if(strcmp(gpio_pin,"49") == 0){
	IO_value = fopen("/sys/class/gpio/gpio49/value","w");
}
	else if(strcmp(gpio_pin,"117")==0){
	IO_value = fopen("/sys/class/gpio/gpio117/value","w");

}
	else if(strcmp(gpio_pin,"115")==0){
	IO_value = fopen("/sys/class/gpio/gpio115/value","w");

}
	else if(strcmp(gpio_pin,"44")==0){
	IO_value = fopen("/sys/class/gpio/gpio44/value","w");

}	
else{
	perror("The gpio pin does not exist");
}
	fwrite(value,1,sizeof(value),IO_value);
	fclose(IO_value);


}


/*******************************************************************************************
 * @brief Turn OFF the led
 *
 * Turn the given LED OFF, i.e output logic 0
 *
 * @param gpio_pin: GPIO pin which is to be turned OFF
 *
 * @return null
 ********************************************************************************************/
void led_off(uint8_t gpio_pin[]){
	uint8_t *value ="0";
	FILE *IO_value = NULL;
	if(strcmp(gpio_pin,"49") == 0){
	IO_value = fopen("/sys/class/gpio/gpio49/value","w");
}
	else if(strcmp(gpio_pin,"117")==0){
	IO_value = fopen("/sys/class/gpio/gpio117/value","w");

}
	else if(strcmp(gpio_pin,"115")==0){
	IO_value = fopen("/sys/class/gpio/gpio115/value","w");

}
	else if(strcmp(gpio_pin,"44")==0){
	IO_value = fopen("/sys/class/gpio/gpio44/value","w");

}	
else{
	perror("The gpio pin does not exist");
}
	fwrite(value,1,sizeof(value),IO_value);
	fclose(IO_value);


}
/********************************************************************************************
*					FILENAME: signal_handler.c
**********************************************************************************************/
/* Title: signal_handler.c
 * Brief: Responsible for providing various synchronization constructs
 * Author: Tanmay Chaturvedi, Vikrant Waje
 * Date Created: March 16, 2019
 * Course: Advanced Embedded Software Development
 * Project: 1
 * 
 * 
 * */
/****************************************************************************************
*					HEADER FILE SECTION
*****************************************************************************************/

#include"signal_handler.h" 

/**************************************************************************************
*					    GLOBAL VARIABLES
****************************************************************************************/
struct sigaction user_defined;
bool system_shutdown_flag;
bool system_shutdown_main_flag;
/**************************************************************************************
*					FUNCTION DEFINITION
***************************************************************************************/
/***********************************************************************************************
 * @brief system shutdown handler
 *
 * Handler invoked when user presses CTRL + C
 * @param num: Checks type of signal
 *
 * @return null
 *********************************************************************************************/
void system_shutdown_handler(int num){
	if(num == SIGINT){
	printf("\n\rSystem shutdown activated. Cleaning up the resources............");
	system_shutdown_flag = 1;
	system_shutdown_main_flag =1;
}

}
/***********************************************************************************************
* @brief Initialise system shutdown handler
*
* Initialising parameter for system shutdown handler
* @param null
*
* @return null
*********************************************************************************************/

void signal_handler_init(){
	user_defined.sa_flags = 0;
	user_defined.sa_handler = system_shutdown_handler;
	sigemptyset(&user_defined.sa_mask);
	sigaction(SIGINT,&user_defined,NULL);


}

/********************************************************************************************
*					FILENAME:temp_sensor.c
**********************************************************************************************/
/* Title: temp_sensor.c
 * Brief: Responsible for providing various helper function needed to communicate with temperature sensor
 * Author: Tanmay Chaturvedi, Vikrant Waje
 * Date Created: March 16, 2019
 * Course: Advanced Embedded Software Development
 * Project: 1

 * Reference[1]: http://www.sparkfun.com/products/13314
 * 
 * 
 * */
/****************************************************************************************
*					HEADER FILE SECTION
*****************************************************************************************/
#include "temp_sensor.h"
#include"synchronization.h"

/**************************************************************************************
*					GLOBAL VARIABLE
*******************************************************************************************/
const char *temp_i2c_path_name = "/dev/i2c-2";
pthread_mutex_t i2c_mutex;


/**********************************************************************************
*				FUNCTION DEFINITION
***************************************************************************************/
/***********************************************************************************************
 * @brief write pointer register
 *
 *Responsible for writing into pointer registerof temperature sensor TMP102
 *
 * @param address: address of pointer register TMP102
 *
 * @return status of I2C operation
 *********************************************************************************************/

sensor_status_t write_ptr_reg(uint8_t address){
	int status = 0;
	int n =0;
	int fptr = open(temp_i2c_path_name,O_RDWR);	
	if(fptr == -1){
		perror("Error in opening the file");
		return WRITE_REG_FAIL;
	}
	status = ioctl(fptr,I2C_SLAVE,TEMP_SENSOR_I2C_ADDRESS);
	if(status !=0){
		perror("IOCTL function failed");
		return WRITE_REG_FAIL;
	}
	n= write(fptr,&address,1);
	if(n == -1){
		perror("Write not successfull");
		return WRITE_REG_FAIL;
	}
	close(fptr);
	return WRITE_REG_SUCCESS;
}

/*********************************************************************************************** 
 * @brief write register in temperature register
 *
 *Responsible for writing into  register of temperature sensor TMP102
 *
 * @param address: address of  register  of TMP102
 * @param data: data to be written into register of TMP102
 *
 * @return status of I2C operation
 *********************************************************************************************/

sensor_status_t temperature_write_reg(uint8_t address, uint16_t data){
	int status =0;
	int fptr = 0;
	int n = 0;
	uint8_t *buffer = malloc(sizeof(uint8_t) *5);
	if( buffer == NULL )
	{
		return WRITE_REG_FAIL;
	}
	*(buffer + 0) = (address);
	*(buffer + 1) = ((data & 0xFF00)>>8);
	*(buffer + 2) = ((data) & 0x00FF);

	fptr = open(temp_i2c_path_name,O_RDWR);	
	if(fptr == -1){
		perror("Error in opening the file");
		free(buffer);
		return WRITE_REG_FAIL;
	}
	status = ioctl(fptr,I2C_SLAVE,TEMP_SENSOR_I2C_ADDRESS);
	if(status !=0){
		perror("IOCTL function failed");
		free(buffer);
		return WRITE_REG_FAIL;
	}
	n = write(fptr,buffer,3);
	if(n ==-1){
		perror("Write not successfull");
		free(buffer);
		return WRITE_REG_FAIL;
	}
	close(fptr);
	free(buffer);
	return WRITE_REG_SUCCESS;
}

/***********************************************************************************************  
 * @brief Read register in temperature register
 *
 *Responsible for reading from  register of temperature sensor TMP102
 *
 * @param address: address of  register  of TMP102
 * @param data: data to be read from  register of TMP102
 * @param command: register bits which are to be read
 * @return status of I2C operation
 *********************************************************************************************/



sensor_status_t temperature_read_reg(uint8_t address, uint8_t *data,reg_read_cmd_t command){
	int status =0;
	int fptr = 0;
	int n = 0;
	fptr = open(temp_i2c_path_name,O_RDWR);	
	if(fptr == -1){
		perror("Error in opening the file");
		return WRITE_REG_FAIL;
	}
	status = ioctl(fptr,I2C_SLAVE,TEMP_SENSOR_I2C_ADDRESS);
	if(status !=0){
		perror("IOCTL function failed");
		return WRITE_REG_FAIL;
	}
	n =write(fptr,&address,1);
	if(n==-1){
		perror("Write not successfull");
		return WRITE_REG_FAIL;
	}

	n = read(fptr,(data ),2);
	if(n ==-1){
		perror("Read not successfull");
		return READ_REG_FAIL;
	}

	//swap the values: Using XOR swap
	*(data + 0) = *(data +0) ^ *(data +1);
	*(data +1) = *(data +0) ^ *(data +1);
	*(data +0) = *(data +0) ^ *(data +1);
	if(command == SD_MODE){
		*(data + 0) =*(data + 1);
		*(data + 1) =0;
	}	
	else if(command == FAULT){
		*(data + 0) = *(data + 1)>>3;
		*(data + 1) = 0;
	}

	else if(command == EM){
		*(data + 0) = *(data +0)>>4;
		*(data + 1) = 0;
	}

	else if(command == CONVERSION_RATE){

		*(data +0) = *(data + 0)>>6;
		*(data +1) =0;
	}
	else if(command == RESOLUTION){
		*(data + 0) = *(data + 1)>>5;
		*(data + 1) =0;

	}
	else{
		*(data +0 )= *(data +0);
		*(data + 1) = *(data +1);
	}
	close(fptr);
	return READ_REG_SUCCESS;

}
/*********************************************************************************************** 
 * @brief Get temperature
 *
 * Read the value from temperature register
 *
 * @param request: Temperature value in kelvin, celsius and farhenheit to be returned
 * @return double: Value of converted temperature
 *********************************************************************************************/


double get_temperature(request_cmd_t request){


	pthread_mutex_lock(&i2c_mutex);

	//double result = 0;
	double multiplier =0;
	uint8_t *data = malloc(sizeof(uint8_t) * 2);
	if ( data == NULL )
	{
		return READ_REG_FAIL;
	}
    multiplier = 0.0625;	
	int status = temperature_read_reg(TEMPERATURE_REG,data,ALL);
	if(status !=READ_REG_SUCCESS){

		perror("Reading configuration register failed");
		free( data );
		pthread_mutex_unlock(&i2c_mutex);
		return READ_TEMPERATURE_ERROR;
	}
	//printf("%x %x",*(data + 0),*(data +1));

	int32_t digitalTemp =0;

	// Bit 0 of second byte will always be 0 in 12-bit readings and 1 in 13-bit
	if(*(data + 0)&0x01)	// 13 bit mode
	{
		// Combine bytes to create a signed int
		digitalTemp = (*(data + 1) << 5) | (*(data + 0) >> 3);
		// Temperature data can be + or -, if it should be negative,
		// convert 13 bit to 16 bit and use the 2s compliment.
		if(digitalTemp > 0xFFF)
		{
			digitalTemp |= 0xE000;
		}
	}
	else	// 12 bit mode
	{
		// Combine bytes to create a signed int 
		digitalTemp = (*(data + 1) << 4) | (*(data + 0) >> 4);
		// Temperature data can be + or -, if it should be negative,
		// convert 12 bit to 16 bit and use the 2s compliment.
		if(digitalTemp > 0x7FF)
		{
			digitalTemp |= 0xF000;
		}
	}
	// Convert digital reading to analog temperature (1-bit is equal to 0.0625 C)

	free(data);

	pthread_mutex_unlock(&i2c_mutex);

	if ( request == REQUEST_KELVIN )
	{
		return(digitalTemp*multiplier + 273.15);		
	}
	else if ( request == REQUEST_FAHRENHEIT )
	{
		return ((digitalTemp*multiplier * 9.0/5.0) + 32.0);
	}
	else
		return(digitalTemp*multiplier);
}

/*********************************************************************************************** 
 * @brief Write tlow
 *
 * Write the value of tlow 
 *
 * @param :null
 * @return sensor_stat_t: Status of I2C operation
 *********************************************************************************************/
sensor_status_t write_tlow(float temperature){

	sensor_status_t sensor_stat = 0;	
	pthread_mutex_lock(&i2c_mutex);
	uint8_t *data = malloc(sizeof(uint8_t)*2);
	if(temperature > 150.0){
		temperature = 150.0;
	}
	if(temperature <-55){
		temperature = -55.0;
	}
  	
	temperature = temperature/0.0625;
	*(data + 1) =(int)(temperature) >> 4;
	*(data +0)= (int)(temperature) << 4;
	sensor_stat = temperature_write_reg(TLOW_REG,(*(data + 0) | *(data + 1) << 8));
	if( sensor_stat != WRITE_REG_SUCCESS )
	{
		perror("Configuring Temp low registerfailed");
		free(data);
		pthread_mutex_unlock(&i2c_mutex);
		return WRITE_REG_FAIL;
	}
	free(data);
	pthread_mutex_unlock(&i2c_mutex);
	return WRITE_REG_SUCCESS;


}

/*********************************************************************************************** 
 * @brief Read tlow
 *
 * Read the value from tlow 
 *
 * @param :null
 * @return double: tempearture register low value
 *********************************************************************************************/


double get_Tlow(request_cmd_t request){

	pthread_mutex_lock(&i2c_mutex);
	double multiplier =0;
	multiplier = 0.0625;
	uint8_t *data = malloc(sizeof(uint8_t) * 2);
	int status = temperature_read_reg(TLOW_REG,data,ALL);
	if(status !=READ_REG_SUCCESS){

		perror("Reading configuration register failed");
		free(data);
		pthread_mutex_unlock(&i2c_mutex);
	}

	//printf("%x %x",*(data + 0),*(data +1));

	int32_t digitalTemp =0;

	
	// Combine bytes to create a signed int 
	digitalTemp = (*(data + 1) << 4) | (*(data + 0) >> 4);
	// Temperature data can be + or -, if it should be negative,
	// convert 12 bit to 16 bit and use the 2s compliment.
	if(digitalTemp > 0x7FF)
	{
	digitalTemp |= 0xF000;
	}
	
	// Convert digital reading to analog temperature (1-bit is equal to 0.0625 C)

	free(data);

	pthread_mutex_unlock(&i2c_mutex);

	if ( request == REQUEST_KELVIN )
	{
		return(digitalTemp*multiplier + 273.15);		
	}
	else if ( request == REQUEST_FAHRENHEIT )
	{
		return ((digitalTemp*multiplier * 9.0/5.0) + 32.0);
	}
	else
		return(digitalTemp*multiplier);
}
/*********************************************************************************************** 
 * @brief Write thigh
 *
 * Write the value of thigh 
 *
 * @param :null
 * @return sensor_stat_t: Status of I2C operation
 *********************************************************************************************/
sensor_status_t write_thigh(float temperature){

	sensor_status_t sensor_stat = 0;	
	pthread_mutex_lock(&i2c_mutex);
	uint8_t *data = malloc(sizeof(uint8_t)*2);
	if(temperature > 150.0){
		temperature = 150.0;
	}
	if(temperature <-55){
		temperature = -55.0;
	}
  	
	temperature = temperature/0.0625;
	*(data + 1) =(int)(temperature) >> 4;
	*(data +0)= (int)(temperature) << 4;
	sensor_stat = temperature_write_reg(THIGH_REG,(*(data + 0) | *(data + 1) << 8));
	if( sensor_stat != WRITE_REG_SUCCESS )
	{
		perror("Configuring Temp low registerfailed");
		free(data);
		pthread_mutex_unlock(&i2c_mutex);
		return WRITE_REG_FAIL;
	}
	free(data);
	pthread_mutex_unlock(&i2c_mutex);
	return WRITE_REG_SUCCESS;


}

/*********************************************************************************************** 
 * @brief Read thigh
 *
 * Read the value from thigh 
 *
 * @param :null
 * @return double: tempearture register high value
 *********************************************************************************************/


double get_Thigh(request_cmd_t request){

	pthread_mutex_lock(&i2c_mutex);
	double multiplier =0;
	uint8_t *data = malloc(sizeof(uint8_t) * 2);
	multiplier = 0.0625;
	int status = temperature_read_reg(THIGH_REG,data,ALL);
	if(status !=READ_REG_SUCCESS){

		perror("Reading THIGH register failed");
		free(data);
		pthread_mutex_unlock(&i2c_mutex);
	}

	//printf("%x %x",*(data + 0),*(data +1));

	int32_t digitalTemp =0;

	
	// Combine bytes to create a signed int 
	digitalTemp = (*(data + 1) << 4) | (*(data + 0) >> 4);
	// Temperature data can be + or -, if it should be negative,
	// convert 12 bit to 16 bit and use the 2s compliment.
	if(digitalTemp > 0x7FF)
	{
	digitalTemp |= 0xF000;
	}
	
	// Convert digital reading to analog temperature (1-bit is equal to 0.0625 C)

	free(data);

	pthread_mutex_unlock(&i2c_mutex);

	if ( request == REQUEST_KELVIN )
	{
		return(digitalTemp*multiplier + 273.15);		
	}
	else if ( request == REQUEST_FAHRENHEIT )
	{
		return ((digitalTemp*multiplier * 9.0/5.0) + 32.0);
	}
	else
		return(digitalTemp*multiplier);

}

/*********************************************************************************************** 
 * @brief set sensor in shutdown mode
 *
 * set the configuration register in shutdown mode
 *
 * @param :null
 * @return :status of I2C operation
 *********************************************************************************************/


sensor_status_t configure_temp_shutdown(void){

	pthread_mutex_lock(&i2c_mutex);
	uint8_t *data = malloc(sizeof(uint8_t)*2);
	sensor_status_t sensor_stat = temperature_read_reg(CONFIGURATION_REG,data, ALL);
	if( sensor_stat != READ_REG_SUCCESS )
	{
		perror("Configuring Shutdown mode failed");
		free(data);
		pthread_mutex_unlock(&i2c_mutex);
		return READ_REG_FAIL;
	}
	*(data + 1) |= SHUTDOWN_ON;
	sensor_stat = temperature_write_reg(CONFIGURATION_REG,(*(data + 0) | *(data + 1) << 8));
	if( sensor_stat != WRITE_REG_SUCCESS )
	{
		perror("Configuring Shutdown mode failed");
		free(data);
		pthread_mutex_unlock(&i2c_mutex);
		return WRITE_REG_FAIL;
	}
	free(data);
	pthread_mutex_unlock(&i2c_mutex);
	return WRITE_REG_SUCCESS;
}

/*********************************************************************************************** 
 * @brief Write fault bits
 *
 * Write the fault bits in configuration register 
 *
 * @param :null
 * @return sensor_stat_t: Status of I2C operation
 *********************************************************************************************/
sensor_status_t configure_temp_fault(uint8_t mode){

	pthread_mutex_lock(&i2c_mutex);
	uint8_t *data = malloc(sizeof(uint8_t)*2);
	sensor_status_t sensor_stat = temperature_read_reg(CONFIGURATION_REG,data, ALL);
	if( sensor_stat != READ_REG_SUCCESS )
	{
		perror("Reading fault bits failed failed");
		free(data);
		pthread_mutex_unlock(&i2c_mutex);
		return READ_REG_FAIL;
	}

	*(data + 1) &= 0xE7;	
   	*(data + 1) |= mode << 3;	


	sensor_stat = temperature_write_reg(CONFIGURATION_REG,(*(data + 0) | *(data + 1) << 8));
	if( sensor_stat != WRITE_REG_SUCCESS )
	{
		perror("Configuring fault bits failed");
		free(data);
		pthread_mutex_unlock(&i2c_mutex);
		return WRITE_REG_FAIL;
	}
	free(data);
	pthread_mutex_unlock(&i2c_mutex);
	return WRITE_REG_SUCCESS;

}


/*********************************************************************************************** 
 * @brief Read fault bits from configuration register
 *
 *  Read fault bits
 *
 * @param :uint8_t* data
 * @return :status of I2C operation
 *********************************************************************************************/


sensor_status_t read_temp_fault(uint8_t *data){

	pthread_mutex_lock(&i2c_mutex);
	uint8_t *temp_data = malloc(sizeof(uint8_t)*2);
	if (temp_data == NULL)
	{
		pthread_mutex_unlock(&i2c_mutex);
		return READ_REG_FAIL;
	}

	sensor_status_t sensor_stat = temperature_read_reg(CONFIGURATION_REG,temp_data,ALL);
	if(sensor_stat != READ_REG_SUCCESS)
	{
		perror("read temp fault failed");
		free(temp_data);
		pthread_mutex_unlock(&i2c_mutex);
		return READ_REG_FAIL;
	}
	*(data + 0) = *(temp_data + 1)>>3;
	free(temp_data);
	pthread_mutex_unlock(&i2c_mutex);
	return READ_REG_SUCCESS;
}

/*********************************************************************************************** 
 * @brief set sensor in EM mode
 *
 * set the configuration register in EM mode
 *
 * @param :mode
 * @return :status of I2C operation
 *********************************************************************************************/

sensor_status_t configure_temp_EMmode(uint8_t mode){

	pthread_mutex_lock(&i2c_mutex);
	uint8_t *data = malloc(sizeof(uint8_t)*2);
	sensor_status_t sensor_stat = temperature_read_reg(CONFIGURATION_REG,data, ALL);
	if( sensor_stat != READ_REG_SUCCESS )
	{
		perror("Configuring Extended mode failed");
		free(data);
		pthread_mutex_unlock(&i2c_mutex);
		return READ_REG_FAIL;
	}

	*(data + 0) &= 0xEF;		// Clear EM (bit 4 of second byte)
   	*(data + 0) |= mode<<4;	// Shift in new exentended mode bit


	sensor_stat = temperature_write_reg(CONFIGURATION_REG,(*(data + 0) | *(data + 1) << 8));
	if( sensor_stat != WRITE_REG_SUCCESS )
	{
		perror("Configuring Extended mode failed");
		free(data);
		pthread_mutex_unlock(&i2c_mutex);
		return WRITE_REG_FAIL;
	}
	free(data);
	pthread_mutex_unlock(&i2c_mutex);
	return WRITE_REG_SUCCESS;
}



/*********************************************************************************************** 
 * @brief Read EM mode from configuration register
 *
 *  Read Em mode bits
 *
 * @param :uint8_t *data
 * @return :status of I2C operation
 *********************************************************************************************/


sensor_status_t read_temp_EM(uint8_t *data){

	pthread_mutex_lock(&i2c_mutex);
	uint8_t *temp_data = malloc(sizeof(uint8_t)*2);
	if (temp_data == NULL)
	{
		pthread_mutex_unlock(&i2c_mutex);
		return READ_REG_FAIL;
	}

	sensor_status_t sensor_stat = temperature_read_reg(CONFIGURATION_REG,temp_data,ALL);
	if(sensor_stat != READ_REG_SUCCESS)
	{
		perror("read temp EM failed");
		free(temp_data);
		pthread_mutex_unlock(&i2c_mutex);
		return READ_REG_FAIL;
	}
	*(data + 0) = *(temp_data + 0)>>4;
	free(temp_data);
	pthread_mutex_unlock(&i2c_mutex);
	return READ_REG_SUCCESS;
}

/*********************************************************************************************** 
 * @brief set sensor conversion rate
 *
 * set the conversion rate of temperature sensor
 *
 * @param :data: To Set the conversion rate
 * @return :status of I2C operation
 *********************************************************************************************/


sensor_status_t configure_temp_conversion_rate(uint8_t rate){


	pthread_mutex_lock(&i2c_mutex);
	uint8_t *data = malloc(sizeof(uint8_t)*2);
	sensor_status_t sensor_stat = temperature_read_reg(CONFIGURATION_REG,data, ALL);
	if( sensor_stat != READ_REG_SUCCESS )
	{
		perror("Configuring Temp conversion rate failed");
		free(data);
		pthread_mutex_unlock(&i2c_mutex);
		return READ_REG_FAIL;
	}

  	*(data + 0) &= 0x3F;  // Clear CR0/1 (bit 6 and 7 of second byte)
  	*(data + 0) |= rate<<6;	// Shift in new conversion rate


	sensor_stat = temperature_write_reg(CONFIGURATION_REG,(*(data + 0) | *(data + 1) << 8));
	if( sensor_stat != WRITE_REG_SUCCESS )
	{
		perror("Configuring Temp conversion ratefailed");
		free(data);
		pthread_mutex_unlock(&i2c_mutex);
		return WRITE_REG_FAIL;
	}
	free(data);
	pthread_mutex_unlock(&i2c_mutex);
	return WRITE_REG_SUCCESS;




}
/*********************************************************************************************** 
 * @brief Read conversion rate from configuration register
 *
 *  Read Conversion rate
 *
 * @param :uint8_t *data
 * @return :status of I2C operations
 *********************************************************************************************/

sensor_status_t read_temp_conversion_rate(uint8_t *data){

	pthread_mutex_lock(&i2c_mutex);
	uint8_t *temp_data = malloc(sizeof(uint8_t)*2);
	if (temp_data == NULL)
	{
		pthread_mutex_unlock(&i2c_mutex);
		return READ_REG_FAIL;
	}

	sensor_status_t sensor_stat = temperature_read_reg(CONFIGURATION_REG,temp_data,ALL);
	if(sensor_stat != READ_REG_SUCCESS)
	{
		perror("read temp conversion failed");
		free(temp_data);
		pthread_mutex_unlock(&i2c_mutex);
		return READ_REG_FAIL;
	}
	*(data + 0) = *(temp_data + 0)>>6;
	free(temp_data);
	pthread_mutex_unlock(&i2c_mutex);
	return READ_REG_SUCCESS;

}


/*********************************************************************************************** 
 * @brief Read sensor resolution from configuration register
 *
 *  Read sensor resolution
 *
 * @param :uint8_t *data
 * @return :status of I2C operations
 *********************************************************************************************/

sensor_status_t read_temp_sensor_resolution(uint8_t *data){

	pthread_mutex_lock(&i2c_mutex);
	uint8_t *temp_data = malloc(sizeof(uint8_t)*2);
	if (temp_data == NULL)
	{
		pthread_mutex_unlock(&i2c_mutex);
		return READ_REG_FAIL;
	}

	sensor_status_t sensor_stat = temperature_read_reg(CONFIGURATION_REG,temp_data,ALL);
	if(sensor_stat != READ_REG_SUCCESS)
	{
		perror("read temp conversion failed");
		free(temp_data);
		pthread_mutex_unlock(&i2c_mutex);
		return READ_REG_FAIL;
	}
	*(data + 0) = *(temp_data + 1)>>5;
	free(temp_data);
	pthread_mutex_unlock(&i2c_mutex);
	return READ_REG_SUCCESS;

}
/********************************************************************************************
 *					FILENAME: bist.c
 **********************************************************************************************/
/* Title bist.c
 * Brief: Contains function that are used for built in self test
 * Author: Tanmay Chaturvedi, Vikrant Waje
 * Date Created: March 16, 2019
 * Course: Advanced Embedded Software Development
 * Project: 1

 * Reference[1]: http://www.
 * 
 * 
 * */
/****************************************************************************************
 *					HEADER FILE SECTION
 *****************************************************************************************/
#include "bist.h"
/***************************************************************************************
 *					MACROS AND ENUMS
 ****************************************************************************************/

/***************************************************************************************
 *					GLOBAL VARIABLE
 ****************************************************************************************/
pthread_t thread1, thread2, thread3, thread4;
mqd_t mqdes_logger;
log_t log_temp_data_src;
log_t log_light_data_src;
pthread_mutex_t logger_queue_mutex;


/***************************************************************************************
 *				FUNCTION DEFINITION
 ***********************************************************************************************/
void built_in_self_test(char *argv){
	double return_data = 0.0;
	sensor_status_t sensor_stat;	
	uint8_t sensor_data = 0;
	uint8_t *data = malloc(sizeof(uint8_t));
	uint16_t *data_16 = malloc(sizeof(uint16_t));
	bool flag_temp = 0;	//To check whether there is any error in temperature sensor initialisation
	bool flag_light = 0;	// To check whether there is any error in light sensor initialisation
	bool flag_thread = 0;	//To check whether there is any error in pthread creation
	int ret_status =0;
	led_init(RED_LED);
	led_init(BLUE_LED);
	led_init(GREEN_LED);
	led_init(YELLOW_LED);

	if(data == NULL || data_16 == NULL){
		printf("Malloc failed");
	}
	else{

		/* Socket thread creation*/

		// Check whether temperature sensor is working properly

		ret_status = write_thigh(THIGH_VAL);
		if(ret_status!= WRITE_REG_SUCCESS){
	
			led_on(RED_LED);

			printf("\n\rTemperature sensor initialisation failed. Failed to write  Thigh register");
			flag_temp = 1;
		}


		return_data = get_Thigh(REQUEST_CELSIUS);
		if(return_data !=THIGH_VAL){
			printf("\n\rTemperature sensor initialisation failed.Incorrect Thigh value =%lf",return_data);
			flag_temp =1;
		}

		ret_status = write_tlow(TLOW_VAL);
		if(ret_status!= WRITE_REG_SUCCESS){
			printf("\n\rTemperature sensor initialisation failed. Failed to write  Tlow register");
			flag_temp =1;
		}

		return_data = get_Tlow(REQUEST_CELSIUS);
		if(return_data != TLOW_VAL){
			printf("\n\rTemperature sensor initialisation failed.Incorrect Tlow value. Tlow temp =%lf",return_data);
			flag_temp =1;
		}

		ret_status = configure_temp_fault(FAULT_1);
		if(ret_status!= WRITE_REG_SUCCESS){
			printf("\n\rTemperature sensor initialisation failed. Failed to write fault bits. ");
			flag_temp =1;
		}


		ret_status = read_temp_fault(data);
		if(((*(data) & FAULT_MASK) !=FAULT_1) && ret_status!=READ_REG_SUCCESS){
			printf("\n\rTemperature sensor initialisation failed. Incorrect fault bit values data = %x",*data);
			flag_temp = 1;
		}

		ret_status = configure_temp_EMmode(EM_OFF);
		if(ret_status!= WRITE_REG_SUCCESS){
			printf("\n\rTemperature sensor initialisation failed. Failed to write EM bits");
			flag_temp =1;
		}

		ret_status = read_temp_EM(data);
		if((*(data) & EM_MASK)!=EM_OFF && ret_status!=READ_REG_SUCCESS){
			printf("\n\rTemperature sensor initialisation failed. Incorrect EM bit value data =%x",*data);
			flag_temp = 1;
		}

		ret_status = configure_temp_conversion_rate(CONVERSION_RATE_4);
		if(ret_status!= WRITE_REG_SUCCESS){
			printf("\n\rTemperature sensor initialisation failed. Failed to write conversion rate bits");
			flag_temp = 1;
		}

		ret_status = read_temp_conversion_rate(data);
		if((*(data) & CONVERSION_RATE_MASK)!=CONVERSION_RATE_4 && ret_status!=READ_REG_SUCCESS){
		

			printf("\n\rTemperature sensor initialisation failed. Incorrect conversion rate bit value data =%x",*data);
			flag_temp = 1;
		}		


		ret_status = read_temp_sensor_resolution(data);
		if((*(data) & RESOLUTION_MASK)!=SENSOR_RESOLUTION_12_BIT && ret_status!=READ_REG_SUCCESS){
		

			printf("\n\rTemperature sensor initialisation failed. Incorrect sensor resolution bit value data =%x",*data);
			flag_temp =1;
		}		




		// Check whether light sensor is working properly

		sensor_stat=light_sensor_power_on();
		if(sensor_stat != WRITE_REG_SUCCESS){
		
			led_on("YELLOW");

			printf("\n\rLight sensor initialisation failed");
			flag_light =1;

		}


		sensor_stat =read_identification_reg(data);	
		if(*data != IDENTIFICATION_MASK && sensor_stat!=READ_REG_SUCCESS){
			printf("\n\rLight sensor initialisation failed. Incorrect identification read data = %d",*data);
			flag_light = 1;
		}

		ret_status = set_integration_time(INTEGRATION_402);
		if(ret_status!= WRITE_REG_SUCCESS){
			printf("\n\rLight sensor initialisation failed. Failed to write Integration bits");
			flag_light = 1;
		}

		ret_status = get_integration_time(data);
		if((*(data) & INTEGRATION_MASK)!=INTEGRATION_402 && ret_status!=READ_REG_SUCCESS){
			printf("\n\rLight sensor initialisation failed. Incorrect integration rate bit  data =%x",*data);
			flag_light =1;
		}		


		ret_status = set_gain(HIGH_GAIN);
		if(ret_status!= WRITE_REG_SUCCESS){
			printf("\n\rLight sensor initialisation failed. Failed to write gain bits");
			flag_light =1;
		}


		ret_status = get_gain(data);
		if((*(data) & GAIN_MASK)!=HIGH_GAIN && ret_status!=READ_REG_SUCCESS){
			printf("\n\rLight sensor initialisation failed. Incorrect gain bit  data =%x",*data);
			flag_light =1;
		}


		ret_status = config_interrupt_ctrl_reg(INTERRUPT_ON);
		if(ret_status!= WRITE_REG_SUCCESS){
			printf("\n\rLight sensor initialisation failed. Failed to write Interrupt control register bits");
			flag_light =1;
		}
		ret_status = get_interrupt_ctrl_reg(data);
		if(*data!= INTERRUPT_ON && ret_status!= READ_REG_SUCCESS){
			printf("\n\rLight sensor initialisation failed. Failed to read Interrupt control register bits");
			flag_light =1;
		}	

		ret_status = set_high_threshold(THRESHOLD_HIGH);
		if(ret_status!= WRITE_REG_SUCCESS){
			printf("\n\rLight sensor initialisation failed. Failed to write Interrupt high threshold register ");
			flag_light =1;
		}

		ret_status = get_high_threshold(data_16);
		if( *data_16 !=THRESHOLD_HIGH && ret_status!= READ_REG_SUCCESS ){
			printf("\n\rLight sensor initialisation failed. Failed to read Interrupt high threshold,val =%ld",*(data_16));
			flag_light =1;
		}

		ret_status = set_low_threshold(THRESHOLD_LOW);
		if(ret_status!= WRITE_REG_SUCCESS){
			printf("\n\rLight sensor initialisation failed. Failed to write Interrupt high threshold register ");
			flag_light = 1;
		}

		ret_status = get_low_threshold(data_16);
		if( *data_16 !=THRESHOLD_LOW && ret_status!= READ_REG_SUCCESS ){
			printf("\n\rLight sensor initialisation failed. Failed to read Interrupt high threshold,val =%ld",*(data_16));
			flag_light =1;
		}


		//	printf("\n\rValue = %ld",*(data_16));
		//Check whether threads have been created successfully or not



		// Notify success/no success to logger


		ret_status = pthread_create( &thread1, NULL, socket_thread,0);
		if( ret_status )
		{
			printf(  "socket_thread not created, Error Code: %d\n", ret_status);
			flag_thread =1;
		}

		/*Temperature thread creation*/
		ret_status = pthread_create( &thread2, NULL, temperature_thread,0);
		if( ret_status )
		{
			printf(  "temperature_thread not created, Error Code: %d\n", ret_status);
			flag_thread =1;
		}

		/*light sensor thread creation*/
		ret_status = pthread_create( &thread3, NULL, light_sensor_thread,0);
		if( ret_status )
		{
			printf(  "light_sensor_thread not created, Error Code: %d\n", ret_status);
			flag_thread =1;
		}


		/*logger thread creation*/
		ret_status = pthread_create( &thread4, NULL, logger_thread,argv);

		if( ret_status )
		{
			printf(  "logger_thread not created, Error Code: %d\n", ret_status);
			flag_thread =1;
		}





		if(flag_thread == 1){
			led_on(RED_LED);
			pthread_mutex_lock(&logger_queue_mutex);

			log_light_data_src.timestamp = record_time();
			log_light_data_src.log_level = 4;
			log_light_data_src.sensor_data = 0;
			strcpy(log_light_data_src.source_ID,"THREAD INIT FAILED");

			if(mq_send(mqdes_logger,(char *)&log_light_data_src,sizeof(log_t),0)==-1){
				perror("PTHREAD INITIALISATION FAILED");
			}
			pthread_mutex_unlock(&logger_queue_mutex);



		}

		if(flag_temp == 1){
			led_on(RED_LED);
			pthread_mutex_lock(&logger_queue_mutex);

			log_temp_data_src.timestamp = record_time();
			log_temp_data_src.log_level = 4;
			log_temp_data_src.sensor_data = 0;
			strcpy(log_temp_data_src.source_ID,"TEMP INIT FAILED");

			if(mq_send(mqdes_logger,(char *)&log_temp_data_src,sizeof(log_t),0)==-1){
				perror("TEMPERATURE SENSOR INITIALISATION FAILED");
			}
			pthread_mutex_unlock(&logger_queue_mutex);



		}
		if(flag_light == 1){
			led_on(RED_LED);
			pthread_mutex_lock(&logger_queue_mutex);

			log_light_data_src.timestamp = record_time();
			log_light_data_src.log_level = 4;
			log_light_data_src.sensor_data = 0;
			strcpy(log_light_data_src.source_ID,"LIGHT INIT FAILED");

			if(mq_send(mqdes_logger,(char *)&log_light_data_src,sizeof(log_t),0)==-1){
				perror("LIGHT SENSOR INITIALISATION FAILED");
			}
			pthread_mutex_unlock(&logger_queue_mutex);



		}

		else{
			led_on(BLUE_LED);
			pthread_mutex_lock(&logger_queue_mutex);
			log_light_data_src.timestamp = record_time();
			log_light_data_src.log_level = 4;
			log_light_data_src.sensor_data = 0;
			strcpy(log_light_data_src.source_ID,"BIST SUCCESS");

			if(mq_send(mqdes_logger,(char *)&log_light_data_src,sizeof(log_t),0)==-1){
				perror("BIST INITIALISATION FAILED");
			}
			pthread_mutex_unlock(&logger_queue_mutex);


		}	
	}
}
/********************************************************************************************
 *					FILENAME: main.c
 **********************************************************************************************/
/* Title: main.c
 * Brief: Responsible for creating threads, joining them and initiating built in self test
 * Author: Tanmay Chaturvedi, Vikrant Waje
 * Date Created: March 16, 2019
 * Course: Advanced Embedded Software Development
 * Project: 1
 * 
 * */
/****************************************************************************************
 *					HEADER FILE SECTION
 *****************************************************************************************/
#include "main.h"


/****************************************************************************************
 *				GLOBAL VARIABLE SECTION
 *****************************************************************************************/
mqd_t mqdes_server;
struct mq_attr attribute_server;
mqd_t mqdes_logger;
struct mq_attr attribute_logger;
mqd_t mqdes_heartbeat;
struct mq_attr attribute_heartbeat;
pthread_t thread1, thread2, thread3, thread4;
bool system_shutdown_main_flag;
int socket_fd;
pthread_mutex_t logger_queue_mutex;
log_t log_main_data_src;
 bool logger_heartbeat_indicator;
 bool light_heartbeat_indicator ;
 bool temp_heartbeat_indicator ;

/*******************************************************************************************
 * @brief Main function
 *
 * Responsible for creating four threads for execution namely light sensor thread, temperature th * read, logger thread and socket thread
 *
 * @param null
 *
 * @return null
 ********************************************************************************************/
int main(int argc, char **argv)
{
	int ret_status;
	char last_state = '0';
	char ret_interrupt_val;
	heartbeat_data_t heartbeat_temp_data;
	sensor_status_t stat;
	/*stat=light_sensor_power_on();
	  if(stat !=WRITE_REG_SUCCESS){
	  perror("Power ON of light sensor failed");
	  }*/

	signal_handler_init();
	 ret_status=GPIO_init();
	if(ret_status ==1){
	printf("Error in log file");
	}
	if(remove(argv[1])==0){
	printf("Deleting the contenyt of old file");
	}
	else{
	printf("File did not exist previously in system");
	}
	open_message_queue_server(&mqdes_server, &attribute_server);
	open_message_queue_logger(&mqdes_logger,&attribute_logger);
	open_message_queue_heartbeat(&mqdes_heartbeat,&attribute_heartbeat);


	built_in_self_test(argv[1]);
	create_log_timer();
	create_heartbeat_timer();
 	create_heartbeat_recovery_timer();
	system_shutdown_main_flag =0;
	system_shutdown_flag =0;
	while(1){


		if(system_shutdown_main_flag == 1){
		
				close_message_queue_server(&mqdes_server);
			close_message_queue_logger(&mqdes_logger);
			close_message_queue_heartbeat(&mqdes_heartbeat);
			close(socket_fd);
			pthread_cancel(thread1);
			pthread_cancel(thread4);
			printf("\n\rCLosing server and logger task");
			break;
		}


		 if(mq_receive(mqdes_heartbeat,(char *)&heartbeat_temp_data,sizeof(heartbeat_data_t),NULL) ==-1){
			perror("Reception of data from temp sensor thread unsuccessfull");	
		
		}
		else{
			printf("\n\r%s,[%lf]",heartbeat_temp_data.source_ID,heartbeat_temp_data.sensor_data);
				if(strcmp(heartbeat_temp_data.source_ID,"TEMP_TASK ALIVE")==0){
					temp_heartbeat_indicator = 1;
				}
				if(strcmp(heartbeat_temp_data.source_ID,"LIGHT_TASK ALIVE")==0){
					light_heartbeat_indicator = 1;
				}
				if(strcmp(heartbeat_temp_data.source_ID,"LOGGER_TASK ALIVE")==0){
					logger_heartbeat_indicator = 1;
				}
				pthread_mutex_lock(&logger_queue_mutex);
				strcpy(log_main_data_src.source_ID,heartbeat_temp_data.source_ID);
				log_main_data_src.timestamp = record_time();
				log_main_data_src.log_level = 1;

				if(mq_send(mqdes_logger,(char *)&log_main_data_src,sizeof(log_t),0)==-1){
					perror("Sending Heartbeat to logger unsuccessfull");
				}
				pthread_mutex_unlock(&logger_queue_mutex);

		}

		ret_interrupt_val = IRQ_handler();

		if( ret_interrupt_val == '1' && last_state!=ret_interrupt_val )
		{
			printf("\n\rInterrupt Received");
				pthread_mutex_lock(&logger_queue_mutex);
				strcpy(log_main_data_src.source_ID,"TMP_SWING_INTERRUPT");
				log_main_data_src.timestamp = record_time();
				log_main_data_src.log_level = 3;

				if(mq_send(mqdes_logger,(char *)&log_main_data_src,sizeof(log_t),0)==-1){
					perror("Sending temperature swing to logger unsuccessfull");
				}
				pthread_mutex_unlock(&logger_queue_mutex);
				last_state = ret_interrupt_val;

		}
		else if ( ret_interrupt_val == '0' )
		{
			printf("\n\r No Interrupt");
			last_state = ret_interrupt_val;
		}
	}	

	/*Socket thread join*/
	ret_status = pthread_join( thread1, NULL);
	if(ret_status){
		fprintf( stderr, "socket thread not joined successfully, Error Code: %d\n", ret_status);
	}
	/*Temperature thread join*/
	ret_status =	pthread_join( thread2, NULL);
	if(ret_status){
		fprintf( stderr, "temperature_thread not joined successfully, Error Code: %d\n", ret_status);
	}

	/*Light sensor thread join*/
	ret_status =	pthread_join( thread3, NULL);
	if(ret_status){
		fprintf( stderr, "light_sensor thread not joined successfully, Error Code: %d\n", ret_status);
	}

	/*Logger thread join*/
	ret_status =	pthread_join( thread4, NULL);
	if(ret_status){
		fprintf( stderr, "logger thread not joined successfully, Error Code: %d\n", ret_status);
	}
	printf("\n\rMain Thread Exited Successfully \n");

	/*close_message_queue_server(&mqdes_server);
	close_message_queue_logger(&mqdes_logger);
	close_message_queue_heartbeat(&mqdes_heartbeat);
*/
return 0;
}


/********************************************************************************************
 *					FILENAME: gpiointerrupt.c
 **********************************************************************************************/
/* Title bist.c
 * Brief: Contains function that are used for built in self test
 * Author: Tanmay Chaturvedi, Vikrant Waje
 * Date Created: March 16, 2019
 * Course: Advanced Embedded Software Development
 * Project: 1

 * Reference[1]: Mastering in Embedded Linux Book
 * 
 * 
 * */
/****************************************************************************************
 *					HEADER FILE SECTION
 *****************************************************************************************/
#include "gpiointerrupt.h"

/****************************************************************************************
 *					GLOBAL SECTION
 *****************************************************************************************/

int file_gpio;
char val[4];
struct pollfd filedes[1];

/***********************************************************************************************
 * @brief IRQ handler
 *
 * Handler that returns state of GPIO pin 
 * @param null
 *
 * @return char
 *********************************************************************************************/

char IRQ_handler(void)
{
	int ret = 0;

	ret = poll( filedes , 1, 10);
//	printf("Ret %d",ret);
	ret = read(file_gpio, val, sizeof(val));
	if( ret > 0)
	{
		//printf(" Value = %c\n", val[0]);
		lseek(file_gpio, 0 , SEEK_SET);
	}



	/*if( ret > 0 )
	{
		ret = read(file_gpio, &val, sizeof(val));
		printf("Value = %c",val[0]);
		lseek(file_gpio,0,SEEK_SET);
	}*/		
	
//	printf("returning = %c", val[0]);
	return val[0];
	
}

/***********************************************************************************************
 * @brief GPIO initilisation function
 *
 * Initialises GPIO pin
 * @param null
 *
 * @return int: error status
 *********************************************************************************************/
int GPIO_init(void)
{
	int ret = 0;
	FILE *export_file = NULL;
	char gpio_pin[] = "60";
	export_file = fopen("/sys/class/gpio/export","w");	//go to export directory
	fwrite(gpio_pin,1,sizeof(gpio_pin),export_file);
	fclose(export_file);
	
	file_gpio = open("/sys/class/gpio/gpio60/value", O_RDONLY);

	if( file_gpio == -1 )
	{
		perror("Failed in GPIO60");
		return 1;
	} 

	ret = read(file_gpio, val, sizeof(val));
	if( ret > 0)
	{
		printf("Initial Value = %c\n", val[0]);
		lseek(file_gpio, 0 , SEEK_SET);
	}

	filedes[0].fd = file_gpio;
	filedes[0].events = POLLPRI | POLLERR;
	return 0;	
}
/********************************************************************************************
 *					FILENAME: ipc.c
 **********************************************************************************************/
/* Title: ipc.c
 * Brief: Responsible for implementing various helper function that helps in setting up interthread communication 
 * Author: Tanmay Chaturvedi, Vikrant Waje
 * Date Created: March 16, 2019
 * Course: Advanced Embedded Software Development
 * Project: 1
 *
 * 
 * 
 * */
/****************************************************************************************
 *					HEADER FILE SECTION
 *****************************************************************************************/


#include"ipc.h"


/**************************************************************************************
 *					     MACROS
 ****************************************************************************************/

/**************************************************************************************
 *					     GLOBAL VARIABLES
 ****************************************************************************************/


/**************************************************************************************
 *					     FUNCTION DEFINITION
/ ****************************************************************************************/

 /* @brief Open message queue for server
 *
 * Initialises a message queue that can be used to transfer sensor values to server when client requests it
 *
 * @param mqdes: Message queue descriptor
 * @param attribute: Attribute of message queue 
 *
 * @return null
 ********************************************************************************************/

void open_message_queue_server(mqd_t *mqdes, struct mq_attr * attribute){
	attribute->mq_maxmsg= 10;
	attribute->mq_msgsize = sizeof(client_data_t);
	*mqdes = mq_open("/msgqueue4",O_CREAT|O_RDWR,0666,attribute); 
	if(*mqdes == -1){
		perror("Failed to open message queue fro server");

	}
}


/*******************************************************************************************
 * @brief Close message queue for server
 *
 * Unlinks and Closes  message queue that was used to transfer sensor values to server when client requests it
 *
 * @param mqdes: Message queue descriptor
 * @param attribute: Attribute of message queue 
 *
 * @return null
 ********************************************************************************************/


void close_message_queue_server(mqd_t *mqdes){
	if(mq_close(*mqdes)==-1){
		perror("Message queue for server failed to close");
	}

	if(mq_unlink("/msgqueue4")<0){
		perror("Message queue for server failed to unlinked");
	}

}

/******************************************************************************************
 * @brief Open message queue for logger
 *
 * Initialises a message queue that can be used to transfer logs periodically to logger task
 *
 * @param mqdes: Message queue descriptor
 * @param attribute: Attribute of message queue 
 *
 * @return null
 ********************************************************************************************/

void open_message_queue_logger(mqd_t *mqdes, struct mq_attr * attribute){
	attribute->mq_maxmsg= 10;
	attribute->mq_msgsize = sizeof(log_t);
	*mqdes = mq_open("/msgqueue5",O_CREAT|O_RDWR,0666,attribute); 
	if(*mqdes == -1){
		perror("Failed to open message queue for logger");

	}
}

/*******************************************************************************************
 * @brief Close message queue for logger
 *
 * Unlinks and Closes  message queue that was used to transfer sensor values to logger task periodically
 *
 * @param mqdes: Message queue descriptor
 * @param attribute: Attribute of message queue 
 *
 * @return null
 ********************************************************************************************/


void close_message_queue_logger(mqd_t *mqdes){
	if(mq_close(*mqdes)==-1){
		perror("Message queue for logger failed to close");
	}

	if(mq_unlink("/msgqueue5")<0){
		perror("Message queue for logger failed to unlinked");
	}

}

/***************************************************************************************

 * @brief Open message queue for logging heartbeat to main task
 *
 * Initialises a message queue that can be used to transfer keep alive notification to main task
 *
 * @param mqdes: Message queue descriptor
 * @param attribute: Attribute of message queue 
 *
 * @return null
 ********************************************************************************************/

void open_message_queue_heartbeat(mqd_t *mqdes, struct mq_attr * attribute){
	attribute->mq_maxmsg= 10;
	attribute->mq_msgsize = sizeof(heartbeat_data_t);
	*mqdes = mq_open("/msgqueue6",O_CREAT|O_RDWR,0666,attribute); 
	if(*mqdes == -1){
		perror("Failed to open message queue for logging heartbeat");

	}
}


/*******************************************************************************************
 * @brief Close message queue for logger
 *
 * Unlinks and Closes  message queue that was used to transfer sensor values to logger task periodically
 *
 * @param mqdes: Message queue descriptor
 * @param attribute: Attribute of message queue 
 *
 * @return null
 ********************************************************************************************/


void close_message_queue_heartbeat(mqd_t *mqdes){
	if(mq_close(*mqdes)==-1){
		perror("Message queue for heartbeat failed to close");
	}

	if(mq_unlink("/msgqueue6")<0){
		perror("Message queue for heartbeat failed to unlinked");
	}

}


/********************************************************************************************
 *					FILENAME: thread.c
 **********************************************************************************************/
/* Title:thread.c
 * Brief: Responsible for providing callback function for the four threads created in main function
 * Author: Tanmay Chaturvedi, Vikrant Waje
 * Date Created: March 16, 2019
 * Course: Advanced Embedded Software Development
 * Project: 1
 * 
 * 
 * */
/****************************************************************************************
 *					HEADER FILE SECTION
 *****************************************************************************************/

#include"main.h" 

/**************************************************************************************
 *					     MACROS
 ****************************************************************************************/

/**************************************************************************************
 *					     GLOBAL VARIABLES
 ****************************************************************************************/
/*bool client_get_temp_flag;
  bool client_get_system_stat_flag;
  bool client_get_lux_flag;
 */

pthread_t thread1,thread2,thread3,thread4;
mqd_t mqdes_server;
client_request_t client_request;
request_cmd_t client_temperature_type_request ;
client_data_t client_data;

mqd_t mqdes_logger;
logger_flag_t logger_flag;
log_t log_temp_data_src;
log_t log_light_data_src;
pthread_mutex_t logger_queue_mutex;

mqd_t mqdes_heartbeat;
heartbeat_flag_t heartbeat_flag;
heartbeat_data_t heartbeat_temp_data_src;
heartbeat_data_t heartbeat_light_data_src;
heartbeat_data_t heartbeat_logger_data_src;
pthread_mutex_t heartbeat_queue_mutex;

bool system_shutdown_flag;
bool temperature_shutdown_flag ;
bool light_shutdown_flag;
bool system_shutdown_main_flag;
/**************************************************************************************
 *					FUNCTION DEFINITION
 ***************************************************************************************/

/*******************************************************************************************
 * @brief Socket thread
 *
 * Waits for a connection initiated by an external client.
 * Once connected, accepts commands from client and acts accordingly.
 * If clients commands the connection to "close", server thread disconnects,
 * closes the socket connection and waits for a new connection.
 *
 * @param null
 *
 * @return null
 ********************************************************************************************/
void *socket_thread( void* arg){
	int ret_status = server_establish();
}


/***********************************************************************************************
 * @brief Temperature thread
 *
 * Get the temperature value periodically from temperature sensor and logs 
 * into file opened by logger thread
 *
 * @param null
 *
 * @return null
 *********************************************************************************************/

void *temperature_thread( void* arg){
	double temperature_data = 0;
	temperature_data = get_temperature(client_temperature_type_request); 
	while(1){
		if(system_shutdown_flag ==1){
			printf("\n\rClosing temperature thread");
			pthread_mutex_unlock(&logger_queue_mutex);
			pthread_mutex_unlock(&heartbeat_queue_mutex);
			pthread_exit(NULL);
		}
		else{
			//printf("\n\rTlow = %lf , Thigh =%lf",get_Tlow(client_temperature_type_request),get_Thigh(client_temperature_type_request));
			//sleep(1);
			if(client_request.client_get_temp_flag == 1){



				//send message through queue to server task
				//printf("\n\rTemperature data called from client: %lf",temperature_data);


				if(client_temperature_type_request == REQUEST_CELSIUS){	

					temperature_data = get_temperature(client_temperature_type_request);

					strcpy(client_data.sensor_string,"Temperature value in celsius:");

					strcpy(log_temp_data_src.source_ID,"EXT REQ(TEMP IN C)");	

					client_data.sensor_data = temperature_data;
					log_temp_data_src.sensor_data = temperature_data;

				}
				else if(client_temperature_type_request == REQUEST_KELVIN){	
					temperature_data = get_temperature(client_temperature_type_request);
					log_temp_data_src.sensor_data = temperature_data;
					client_data.sensor_data = temperature_data;
					strcpy(log_temp_data_src.source_ID,"EXT REQ(TEMP IN K)");	

					strcpy(client_data.sensor_string,"Temperature value in Kelvin:");
				}
				else /*(client_temperature_type_request == REQUEST_FAHRENHEIT)*/{	
					temperature_data = get_temperature(client_temperature_type_request);
					log_temp_data_src.sensor_data = temperature_data;
					client_data.sensor_data = temperature_data;

					strcpy(log_temp_data_src.source_ID,"EXT REQ(TEMP IN F)");

					strcpy(client_data.sensor_string,"Temperature value in Fahrenheit:");
				}


				if(mq_send(mqdes_server,(char *)&client_data,sizeof(client_data_t),0)==-1){
					perror("Sending temperature value to server unsuccessfull");
				}
				client_request.client_get_temp_flag =0;



				pthread_mutex_lock(&logger_queue_mutex);

				log_temp_data_src.timestamp = record_time();
				log_temp_data_src.log_level = 3;

				if(mq_send(mqdes_logger,(char *)&log_temp_data_src,sizeof(log_t),0)==-1){
					perror("Sending temperature value to logger unsuccessfull");
				}
				pthread_mutex_unlock(&logger_queue_mutex);




			}
			if(logger_flag.log_temp_sensor_flag == 1){
				temperature_data = get_temperature(client_temperature_type_request); 
				if(temperature_data == READ_TEMPERATURE_ERROR){	
					strcpy(log_temp_data_src.source_ID,"TEMPSENSOR_REMOVED");
					log_temp_data_src.timestamp = record_time(); 
					log_temp_data_src.log_level = 4;
					pthread_mutex_lock(&logger_queue_mutex);
					if(mq_send(mqdes_logger,(char *)&log_temp_data_src,sizeof(log_t),0)==-1){
						perror("Temperature sensor removed");
					}
					pthread_mutex_unlock(&logger_queue_mutex);



				}
				if(client_temperature_type_request == REQUEST_CELSIUS){
					strcpy(log_temp_data_src.source_ID,"TEMPERATURE(C)");

				}
				else if(client_temperature_type_request == REQUEST_FAHRENHEIT){
					strcpy(log_temp_data_src.source_ID,"TEMPERATURE(F)");
				}
				else if(client_temperature_type_request == REQUEST_KELVIN){
					strcpy(log_temp_data_src.source_ID,"TEMPERATURE(K)");
				}
				log_temp_data_src.sensor_data = temperature_data;	

				log_temp_data_src.timestamp = record_time(); 
				log_temp_data_src.log_level = 2;	
				pthread_mutex_lock(&logger_queue_mutex);
				if(mq_send(mqdes_logger,(char *)&log_temp_data_src,sizeof(log_t),0)==-1){
					perror("Sending temperature value to logger unsuccessfull");
				}
				pthread_mutex_unlock(&logger_queue_mutex);

				logger_flag.log_temp_sensor_flag =0;


			}

			if(heartbeat_flag.heartbeat_temp_sensor_flag == 1){
				temperature_data = get_temperature(client_temperature_type_request);
				heartbeat_temp_data_src.timestamp = record_time(); 
				heartbeat_temp_data_src.log_level = 1;
				strcpy(heartbeat_temp_data_src.source_ID,"TEMP_TASK ALIVE");
				heartbeat_temp_data_src.sensor_data = temperature_data;	
				pthread_mutex_lock(&heartbeat_queue_mutex);
				if(mq_send(mqdes_heartbeat,(char *)&heartbeat_temp_data_src,sizeof(heartbeat_data_t),0)==-1){
					perror("Sending temperature value to main unsuccessfull");
				}
				pthread_mutex_unlock(&heartbeat_queue_mutex);

				heartbeat_flag.heartbeat_temp_sensor_flag =0;


			}

		}
	}
}




/***********************************************************************************************
 * @brief light sensor thread
 *
 * Get the LUX values from light sensor attached using I2C interface and report it periodically t * o logger thread
 *
 * @param null
 *
 * @return null
 *********************************************************************************************/

void *light_sensor_thread( void* arg){
	double lux_data = 0;
	double force_lux_data = 0;
	last_state_t last_state = INITIAL;
	while(1){
		if(system_shutdown_flag ==1){
			printf("\n\rClosing light sensor thread");
			pthread_mutex_unlock(&logger_queue_mutex);
			pthread_mutex_unlock(&heartbeat_queue_mutex);
			pthread_exit(NULL);
		}
		else{
			if(lux_data !=READ_LIGHT_ERROR){

				lux_data = read_lux();

				if(lux_data >=75 && last_state ==DARK){
					log_light_data_src.sensor_data = lux_data;
					strcpy(log_light_data_src.source_ID,"DARK_TO_LIGHTCHANGE");
					log_light_data_src.timestamp = record_time();
					log_light_data_src.log_level = 3;

					pthread_mutex_lock(&logger_queue_mutex);

					if(mq_send(mqdes_logger,(char *)&log_light_data_src,sizeof(log_t),0)==-1){
						perror("Sending light value to logger unsuccessfull");
					}
					last_state = LIGHT;
					pthread_mutex_unlock(&logger_queue_mutex);

				}
				else if(lux_data<75 && last_state == LIGHT){
					//strcpy(log_light_data_src.source_ID,"DARK_TO_LIGHTCHANGE");

					strcpy(log_light_data_src.source_ID,"LIGHT_TO_DARKCHANGE");
					log_light_data_src.sensor_data = lux_data;
					log_light_data_src.timestamp = record_time();
					log_light_data_src.log_level = 3;

					pthread_mutex_lock(&logger_queue_mutex);

					if(mq_send(mqdes_logger,(char *)&log_light_data_src,sizeof(log_t),0)==-1){
						perror("Sending light value to logger unsuccessfull");
					}
					last_state =DARK;
					pthread_mutex_unlock(&logger_queue_mutex);

				}
				else{
					if(lux_data>=75){
						last_state = LIGHT;
					}
					else if(lux_data<75){
						last_state = DARK;
					}
					//	printf("\n\rNo change");
				}

			}
			//client_get_lux_flag = 1;
			if(client_request.client_get_lux_flag == 1){
				//send message through queue to server task
				lux_data = read_lux(); 

				if ( lux_data >= 75 )
				{
					strcpy(client_data.sensor_string,"Lux value in lumens(STATE=LIGHT):"); 	
					strcpy(log_light_data_src.source_ID,"EXT REQ(LIGHT STATE)");

				}
				else if ( lux_data < 75 ) 
				{
					strcpy(client_data.sensor_string,"Lux value in lumens(STATE=DARK):"); 	
					strcpy(log_light_data_src.source_ID,"EXT REQ(DARK STATE)");

				}
				//	printf("\n\rLight data called from client:%lf",lux_data);
				client_data.sensor_data = lux_data;	
				if(mq_send(mqdes_server,(char *)&client_data,sizeof(client_data_t),0)==-1){
					perror("Sending light value to server unsuccessfull");
				}

				pthread_mutex_lock(&logger_queue_mutex);

				log_light_data_src.timestamp = record_time();
				log_light_data_src.log_level = 3;

				if(mq_send(mqdes_logger,(char *)&log_light_data_src,sizeof(log_t),0)==-1){
					perror("Sending light value to logger unsuccessfull");
				}
				pthread_mutex_unlock(&logger_queue_mutex);





				client_request.client_get_lux_flag = 0;

			}
			if(logger_flag.log_light_sensor_flag == 1){
				lux_data = read_lux(); 


				if(lux_data == READ_LIGHT_ERROR){
					log_light_data_src.timestamp = record_time();
					log_light_data_src.log_level = 4;
					strcpy(log_light_data_src.source_ID,"LIGHTSENSOR_REMOVED");
					pthread_mutex_lock(&logger_queue_mutex);
					if(mq_send(mqdes_logger,(char *)&log_light_data_src,sizeof(log_t),0)==-1){
						perror("Light sensor removed");
					}
					logger_flag.log_light_sensor_flag =0;
					pthread_mutex_unlock(&logger_queue_mutex);


				}

				if( lux_data <75){
					strcpy(log_light_data_src.source_ID,"LIGHT(DARK STATE)");
				}
				else if(lux_data >=75){
					strcpy(log_light_data_src.source_ID,"LIGHT(LIGHT STATE)");

				}
				log_light_data_src.timestamp = record_time(); 
				log_light_data_src.log_level = 2;

				log_light_data_src.sensor_data = lux_data;	
				pthread_mutex_lock(&logger_queue_mutex);
				if(mq_send(mqdes_logger,(char *)&log_light_data_src,sizeof(log_t),0)==-1){
					perror("Sending light value to logger unsuccessfull");
				}
				logger_flag.log_light_sensor_flag =0;
				pthread_mutex_unlock(&logger_queue_mutex);


			}

			if(heartbeat_flag.heartbeat_light_sensor_flag == 1){
				lux_data = read_lux(); 
				heartbeat_light_data_src.timestamp = record_time(); 
				heartbeat_light_data_src.log_level = 2;
				strcpy(heartbeat_light_data_src.source_ID,"LIGHT_TASK ALIVE");
				heartbeat_light_data_src.sensor_data = lux_data;	
				pthread_mutex_lock(&heartbeat_queue_mutex);
				if(mq_send(mqdes_heartbeat,(char *)&heartbeat_light_data_src,sizeof(heartbeat_data_t),0)==-1){
					perror("Sending light value to main unsuccessfull");
				}
				pthread_mutex_unlock(&heartbeat_queue_mutex);

				heartbeat_flag.heartbeat_light_sensor_flag =0;


			}


		}
	}

}




/***********************************************************************************************
 * @brief logger thread
 *
 * Log the values of temperature, light sensor and socket status in log file created by logger task 
 * into file opened by logger thread
 *
 * @param null
 *
 * @return null
 *********************************************************************************************/

void *logger_thread( void* arg){
	log_t log_temp_data;
	FILE *log_file = NULL;
	while(1){
		//	printf("\n\rClosed log files");


		if(system_shutdown_flag ==1){

			printf("\n\rClosed log files");

			fclose(log_file);

			pthread_mutex_unlock(&logger_queue_mutex);
			pthread_mutex_unlock(&heartbeat_queue_mutex);
			pthread_exit(NULL);
		}

		else{
			if(heartbeat_flag.heartbeat_logger_flag == 1){
				heartbeat_logger_data_src.timestamp = record_time(); 
				heartbeat_logger_data_src.log_level = 2;
				strcpy(heartbeat_logger_data_src.source_ID,"LOGGER_TASK ALIVE");	
				pthread_mutex_lock(&heartbeat_queue_mutex);
				if(mq_send(mqdes_heartbeat,(char *)&heartbeat_logger_data_src,sizeof(heartbeat_data_t),0)==-1){
					perror("Sending logger value to main unsuccessfull");
				}
				pthread_mutex_unlock(&heartbeat_queue_mutex);

				heartbeat_flag.heartbeat_logger_flag =0;


			}

			if(mq_receive(mqdes_logger,(char *)&log_temp_data,sizeof(log_t),NULL) ==-1){
				perror("Reception of data from temp sensor thread unsuccessfull");	
			}



			log_file = fopen(arg,"a+");
			if(strcmp(log_temp_data.source_ID,"BIST SUCCESS")==0 ||strcmp(log_temp_data.source_ID,"TEMPSENSOR_REMOVED")==0 ||strcmp(log_temp_data.source_ID,"LIGHTSENSOR_REMOVED")==0 || \
			strcmp(log_temp_data.source_ID,"LIGHT_TASK ALIVE")==0 ||strcmp(log_temp_data.source_ID,"TEMP_TASK ALIVE")==0 ||strcmp(log_temp_data.source_ID,"LOGGER_TASK ALIVE")==0 || \
			strcmp(log_temp_data.source_ID,"TMP_SWING_INTERRUPT")==0){
				LOG_GENERAL(log_file,log_temp_data.timestamp,log_temp_data.log_level,log_temp_data.source_ID);

			}
			else if(strcmp(log_temp_data.source_ID,"BIST SUCCESS")!=0){
				LOG(log_file,log_temp_data.timestamp,log_temp_data.log_level,log_temp_data.source_ID,log_temp_data.sensor_data);
			}
			fclose(log_file);


		}

	}

}






